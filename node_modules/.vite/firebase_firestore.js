import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-O63PWHED.js";
import "./chunk-T6TLBVIZ.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  const d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (let f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    const c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (const d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b) {
    const c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var vb = new class {
  constructor(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new wb(), (a) => a.reset());
var wb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = class extends v {
  constructor(a, b) {
    super();
    this.m = a;
    this.j = b;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  const b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  const b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  const b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const ca2 = a.g;
              if (ca2) {
                const Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = class {
  constructor(a, b) {
    this.h = a;
    this.g = b;
  }
};
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d = c || "";
  try {
    Kc(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d = new Image();
    d.onload = ja(od, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(od, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(od, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(od, c, d, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  const e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  let b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        const e = new M(this, this.h, a, void 0);
        let f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  let d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    const e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = esm.ErrorCode = Wb;
var EventType = esm.EventType = Xb;
var Event = esm.Event = H;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = pd;
var WebChannel = esm.WebChannel = $b;
var XhrIo = esm.XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var D2 = "@firebase/firestore";
var C2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
C2.UNAUTHENTICATED = new C2(null), C2.GOOGLE_CREDENTIALS = new C2("google-credentials-uid"), C2.FIRST_PARTY = new C2("first-party-uid"), C2.MOCK_USER = new C2("mock-user");
var N2 = "9.6.5";
var k2 = new Logger("@firebase/firestore");
function x2() {
  return k2.logLevel;
}
function $(t2) {
  k2.setLogLevel(t2);
}
function O2(t2, ...e) {
  if (k2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(L2);
    k2.debug(`Firestore (${N2}): ${t2}`, ...n);
  }
}
function M2(t2, ...e) {
  if (k2.logLevel <= LogLevel.ERROR) {
    const n = e.map(L2);
    k2.error(`Firestore (${N2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (k2.logLevel <= LogLevel.WARN) {
    const n = e.map(L2);
    k2.warn(`Firestore (${N2}): ${t2}`, ...n);
  }
}
function L2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function B2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${N2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw M2(e), new Error(e);
}
function U2(t2, e) {
  t2 || B2();
}
function q2(t2, e) {
  t2 || B2();
}
function K2(t2, e) {
  return t2;
}
var j = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var Q2 = class extends FirebaseError {
  constructor(t2, e) {
    super(t2, e), this.code = t2, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var W2 = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var G = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var z2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var H2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var J2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = C2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new W2();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new W2(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      O2("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (O2("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new W2());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (O2("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (U2(typeof e2.accessToken == "string"), new G(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return U2(t2 === null || typeof t2 == "string"), new C2(t2);
  }
};
var Y2 = class {
  constructor(t2, e, n) {
    this.type = "FirstParty", this.user = C2.FIRST_PARTY, this.headers = new Map(), this.headers.set("X-Goog-AuthUser", e);
    const s = t2.auth.getAuthHeaderValueForFirstParty([]);
    s && this.headers.set("Authorization", s), n && this.headers.set("X-Goog-Iam-Authorization-Token", n);
  }
};
var X2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new Y2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(C2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Z2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var tt = class {
  constructor(t2) {
    this.g = t2, this.forceRefresh = false, this.appCheck = null;
  }
  start(t2, e) {
    this.o = (n2) => {
      t2.enqueueRetryable(() => ((t3) => (t3.error != null && O2("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`), e(t3.token)))(n2));
    };
    const n = (t3) => {
      O2("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t3) => n(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.g.getImmediate({
          optional: true
        });
        t3 ? n(t3) : O2("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (U2(typeof t3.token == "string"), new Z2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var et = class {
  getToken() {
    return Promise.resolve(new Z2(""));
  }
  invalidateToken() {
  }
  start(t2, e) {
  }
  shutdown() {
  }
};
var nt = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.p(t3), this.T = (t3) => e.writeSequenceNumber(t3));
  }
  p(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.T && this.T(t2), t2;
  }
};
function st(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
nt.I = -1;
var it = class {
  static A() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = st(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function rt(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function ot(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function ct(t2) {
  return t2 + "\0";
}
var at = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new Q2(j.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new Q2(j.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new Q2(j.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new Q2(j.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return at.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return at.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new at(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? rt(this.nanoseconds, t2.nanoseconds) : rt(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var ut = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new ut(t2);
  }
  static min() {
    return new ut(new at(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function ht(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function lt(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function ft(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var dt = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && B2(), n === void 0 ? n = t2.length - e : n > t2.length - e && B2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return dt.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof dt ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var wt = class extends dt {
  construct(t2, e, n) {
    return new wt(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new Q2(j.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new wt(e);
  }
  static emptyPath() {
    return new wt([]);
  }
};
var _t = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var mt = class extends dt {
  construct(t2, e, n) {
    return new mt(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return _t.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), mt.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new mt(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new Q2(j.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new Q2(j.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new Q2(j.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new Q2(j.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new mt(e);
  }
  static emptyPath() {
    return new mt([]);
  }
};
var gt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(mt.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return ot(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function yt() {
  return typeof atob != "undefined";
}
var pt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new pt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new pt(e);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return rt(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
pt.EMPTY_BYTE_STRING = new pt("");
var Tt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Et(t2) {
  if (U2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = Tt.exec(t2);
    if (U2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: It(t2.seconds),
    nanos: It(t2.nanos)
  };
}
function It(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function At(t2) {
  return typeof t2 == "string" ? pt.fromBase64String(t2) : pt.fromUint8Array(t2);
}
function Rt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function bt(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Rt(e) ? bt(e) : e;
}
function Pt(t2) {
  const e = Et(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new at(e.seconds, e.nanos);
}
function vt(t2) {
  return t2 == null;
}
function Vt(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function St(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !Vt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var Dt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new Dt(wt.fromString(t2));
  }
  static fromName(t2) {
    return new Dt(wt.fromString(t2).popFirst(5));
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  isEqual(t2) {
    return t2 !== null && wt.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return wt.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new Dt(new wt(t2.slice()));
  }
};
function Ct(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Rt(t2) ? 4 : 10 : B2();
}
function Nt(t2, e) {
  if (t2 === e)
    return true;
  const n = Ct(t2);
  if (n !== Ct(e))
    return false;
  switch (n) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return Pt(t2).isEqual(Pt(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = Et(t3.timestampValue), s = Et(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return At(t3.bytesValue).isEqual(At(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return It(t3.geoPointValue.latitude) === It(e2.geoPointValue.latitude) && It(t3.geoPointValue.longitude) === It(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return It(t3.integerValue) === It(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = It(t3.doubleValue), s = It(e2.doubleValue);
          return n2 === s ? Vt(n2) === Vt(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return ot(t2.arrayValue.values || [], e.arrayValue.values || [], Nt);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (ht(n2) !== ht(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !Nt(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return B2();
  }
}
function kt(t2, e) {
  return (t2.values || []).find((t3) => Nt(t3, e)) !== void 0;
}
function xt(t2, e) {
  if (t2 === e)
    return 0;
  const n = Ct(t2), s = Ct(e);
  if (n !== s)
    return rt(n, s);
  switch (n) {
    case 0:
      return 0;
    case 1:
      return rt(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = It(t3.integerValue || t3.doubleValue), s2 = It(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return $t(t2.timestampValue, e.timestampValue);
    case 4:
      return $t(Pt(t2), Pt(e));
    case 5:
      return rt(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = At(t3), s2 = At(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = rt(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = rt(It(t3.latitude), It(e2.latitude));
        if (n2 !== 0)
          return n2;
        return rt(It(t3.longitude), It(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = xt(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return rt(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = rt(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = xt(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return rt(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw B2();
  }
}
function $t(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return rt(t2, e);
  const n = Et(t2), s = Et(e), i = rt(n.seconds, s.seconds);
  return i !== 0 ? i : rt(n.nanos, s.nanos);
}
function Ot(t2) {
  return Mt(t2);
}
function Mt(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = Et(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? At(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, Dt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Mt(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Mt(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : B2();
  var e, n;
}
function Ft(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function Lt(t2) {
  return !!t2 && "integerValue" in t2;
}
function Bt(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Ut(t2) {
  return !!t2 && "nullValue" in t2;
}
function qt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Kt(t2) {
  return !!t2 && "mapValue" in t2;
}
function jt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return lt(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = jt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = jt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
var Qt = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new Qt({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Kt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = jt(e);
  }
  setAll(t2) {
    let e = mt.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = jt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Kt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Nt(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Kt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    lt(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new Qt(jt(this.value));
  }
};
function Wt(t2) {
  const e = [];
  return lt(t2.fields, (t3, n) => {
    const s = new mt([t3]);
    if (Kt(n)) {
      const t4 = Wt(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new gt(e);
}
var Gt = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.documentType = e, this.version = n, this.data = s, this.documentState = i;
  }
  static newInvalidDocument(t2) {
    return new Gt(t2, 0, ut.min(), Qt.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new Gt(t2, 1, e, n, 0);
  }
  static newNoDocument(t2, e) {
    return new Gt(t2, 2, e, Qt.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new Gt(t2, 3, e, Qt.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = Qt.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = Qt.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof Gt && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new Gt(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var zt = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.R = null;
  }
};
function Ht(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new zt(t2, e, n, s, i, r, o);
}
function Jt(t2) {
  const e = K2(t2);
  if (e.R === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => ee(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), vt(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += le(e.startAt)), e.endAt && (t3 += "|ub:", t3 += le(e.endAt)), e.R = t3;
  }
  return e.R;
}
function Yt(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Ot(e2.value)}`;
    var e2;
  }).join(", ")}]`), vt(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: " + le(t2.startAt)), t2.endAt && (e += ", endAt: " + le(t2.endAt)), `Target(${e})`;
}
function Xt(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!de(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !Nt(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!_e(t2.startAt, e.startAt) && _e(t2.endAt, e.endAt)));
}
function Zt(t2) {
  return Dt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
var te = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.P(t2, e, n) : new ne(t2, e, n) : e === "array-contains" ? new oe(t2, n) : e === "in" ? new ce(t2, n) : e === "not-in" ? new ae(t2, n) : e === "array-contains-any" ? new ue(t2, n) : new te(t2, e, n);
  }
  static P(t2, e, n) {
    return e === "in" ? new se(t2, n) : new ie(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.v(xt(e, this.value)) : e !== null && Ct(this.value) === Ct(e) && this.v(xt(e, this.value));
  }
  v(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return B2();
    }
  }
  V() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
function ee(t2) {
  return t2.field.canonicalString() + t2.op.toString() + Ot(t2.value);
}
var ne = class extends te {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = Dt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = Dt.comparator(t2.key, this.key);
    return this.v(e);
  }
};
var se = class extends te {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = re("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var ie = class extends te {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = re("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function re(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => Dt.fromName(t3.referenceValue));
}
var oe = class extends te {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Bt(e) && kt(e.arrayValue, this.value);
  }
};
var ce = class extends te {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && kt(this.value.arrayValue, e);
  }
};
var ae = class extends te {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (kt(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !kt(this.value.arrayValue, e);
  }
};
var ue = class extends te {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Bt(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => kt(this.value.arrayValue, t3));
  }
};
var he = class {
  constructor(t2, e) {
    this.position = t2, this.before = e;
  }
};
function le(t2) {
  return `${t2.before ? "b" : "a"}:${t2.position.map((t3) => Ot(t3)).join(",")}`;
}
var fe = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function de(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function we(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = Dt.comparator(Dt.fromName(o.referenceValue), n.key);
    else {
      s = xt(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return t2.before ? s <= 0 : s < 0;
}
function _e(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.before !== e.before || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Nt(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var me = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, c = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = c, this.S = null, this.D = null, this.startAt, this.endAt;
  }
};
function ge(t2, e, n, s, i, r, o, c) {
  return new me(t2, e, n, s, i, r, o, c);
}
function ye(t2) {
  return new me(t2);
}
function pe(t2) {
  return !vt(t2.limit) && t2.limitType === "F";
}
function Te(t2) {
  return !vt(t2.limit) && t2.limitType === "L";
}
function Ee(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function Ie(t2) {
  for (const e of t2.filters)
    if (e.V())
      return e.field;
  return null;
}
function Ae(t2) {
  return t2.collectionGroup !== null;
}
function Re(t2) {
  const e = K2(t2);
  if (e.S === null) {
    e.S = [];
    const t3 = Ie(e), n = Ee(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.S.push(new fe(t3)), e.S.push(new fe(mt.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.S.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.S.push(new fe(mt.keyField(), t5));
      }
    }
  }
  return e.S;
}
function be(t2) {
  const e = K2(t2);
  if (!e.D)
    if (e.limitType === "F")
      e.D = Ht(e.path, e.collectionGroup, Re(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of Re(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new fe(n2.field, e2));
      }
      const n = e.endAt ? new he(e.endAt.position, !e.endAt.before) : null, s = e.startAt ? new he(e.startAt.position, !e.startAt.before) : null;
      e.D = Ht(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.D;
}
function Pe(t2, e, n) {
  return new me(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function ve(t2, e) {
  return Xt(be(t2), be(e)) && t2.limitType === e.limitType;
}
function Ve(t2) {
  return `${Jt(be(t2))}|lt:${t2.limitType}`;
}
function Se(t2) {
  return `Query(target=${Yt(be(t2))}; limitType=${t2.limitType})`;
}
function De(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : Dt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !we(t3.startAt, Re(t3), e2))
      return false;
    if (t3.endAt && we(t3.endAt, Re(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function Ce(t2) {
  return (e, n) => {
    let s = false;
    for (const i of Re(t2)) {
      const t3 = Ne(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function Ne(t2, e, n) {
  const s = t2.field.isKeyField() ? Dt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? xt(s2, i) : B2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return B2();
  }
}
function ke(t2, e) {
  if (t2.C) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: Vt(e) ? "-0" : e
  };
}
function xe(t2) {
  return {
    integerValue: "" + t2
  };
}
function $e(t2, e) {
  return St(e) ? xe(e) : ke(t2, e);
}
var Oe = class {
  constructor() {
    this._ = void 0;
  }
};
function Me(t2, e, n) {
  return t2 instanceof Be ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Ue ? qe(t2, e) : t2 instanceof Ke ? je(t2, e) : function(t3, e2) {
    const n2 = Le(t3, e2), s = We(n2) + We(t3.N);
    return Lt(n2) && Lt(t3.N) ? xe(s) : ke(t3.k, s);
  }(t2, e);
}
function Fe(t2, e, n) {
  return t2 instanceof Ue ? qe(t2, e) : t2 instanceof Ke ? je(t2, e) : n;
}
function Le(t2, e) {
  return t2 instanceof Qe ? Lt(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var Be = class extends Oe {
};
var Ue = class extends Oe {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function qe(t2, e) {
  const n = Ge(e);
  for (const e2 of t2.elements)
    n.some((t3) => Nt(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var Ke = class extends Oe {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function je(t2, e) {
  let n = Ge(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Nt(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var Qe = class extends Oe {
  constructor(t2, e) {
    super(), this.k = t2, this.N = e;
  }
};
function We(t2) {
  return It(t2.integerValue || t2.doubleValue);
}
function Ge(t2) {
  return Bt(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var ze = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function He(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Ue && e2 instanceof Ue || t3 instanceof Ke && e2 instanceof Ke ? ot(t3.elements, e2.elements, Nt) : t3 instanceof Qe && e2 instanceof Qe ? Nt(t3.N, e2.N) : t3 instanceof Be && e2 instanceof Be;
  }(t2.transform, e.transform);
}
var Je = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var Ye = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new Ye();
  }
  static exists(t2) {
    return new Ye(void 0, t2);
  }
  static updateTime(t2) {
    return new Ye(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function Xe(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var Ze = class {
};
function tn(t2, e, n) {
  t2 instanceof on ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = un(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof cn ? function(t3, e2, n2) {
    if (!Xe(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = un(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(an(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function en(t2, e, n) {
  t2 instanceof on ? function(t3, e2, n2) {
    if (!Xe(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = hn(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(rn(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof cn ? function(t3, e2, n2) {
    if (!Xe(t3.precondition, e2))
      return;
    const s = hn(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(an(t3)), i.setAll(s), e2.convertToFoundDocument(rn(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    Xe(t3.precondition, e2) && e2.convertToNoDocument(ut.min());
  }(t2, e);
}
function nn(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = Le(s.transform, t3 || null);
    i != null && (n == null && (n = Qt.empty()), n.set(s.field, i));
  }
  return n || null;
}
function sn(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && ot(t3, e2, (t4, e3) => He(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function rn(t2) {
  return t2.isFoundDocument() ? t2.version : ut.min();
}
var on = class extends Ze {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var cn = class extends Ze {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function an(t2) {
  const e = new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function un(t2, e, n) {
  const s = new Map();
  U2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, c = e.data.field(r.field);
    s.set(r.field, Fe(o, c, n[i]));
  }
  return s;
}
function hn(t2, e, n) {
  const s = new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Me(t3, r, e));
  }
  return s;
}
var ln = class extends Ze {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var fn = class extends Ze {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var dn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var wn;
var _n;
function mn(t2) {
  switch (t2) {
    default:
      return B2();
    case j.CANCELLED:
    case j.UNKNOWN:
    case j.DEADLINE_EXCEEDED:
    case j.RESOURCE_EXHAUSTED:
    case j.INTERNAL:
    case j.UNAVAILABLE:
    case j.UNAUTHENTICATED:
      return false;
    case j.INVALID_ARGUMENT:
    case j.NOT_FOUND:
    case j.ALREADY_EXISTS:
    case j.PERMISSION_DENIED:
    case j.FAILED_PRECONDITION:
    case j.ABORTED:
    case j.OUT_OF_RANGE:
    case j.UNIMPLEMENTED:
    case j.DATA_LOSS:
      return true;
  }
}
function gn(t2) {
  if (t2 === void 0)
    return M2("GRPC error has no .code"), j.UNKNOWN;
  switch (t2) {
    case wn.OK:
      return j.OK;
    case wn.CANCELLED:
      return j.CANCELLED;
    case wn.UNKNOWN:
      return j.UNKNOWN;
    case wn.DEADLINE_EXCEEDED:
      return j.DEADLINE_EXCEEDED;
    case wn.RESOURCE_EXHAUSTED:
      return j.RESOURCE_EXHAUSTED;
    case wn.INTERNAL:
      return j.INTERNAL;
    case wn.UNAVAILABLE:
      return j.UNAVAILABLE;
    case wn.UNAUTHENTICATED:
      return j.UNAUTHENTICATED;
    case wn.INVALID_ARGUMENT:
      return j.INVALID_ARGUMENT;
    case wn.NOT_FOUND:
      return j.NOT_FOUND;
    case wn.ALREADY_EXISTS:
      return j.ALREADY_EXISTS;
    case wn.PERMISSION_DENIED:
      return j.PERMISSION_DENIED;
    case wn.FAILED_PRECONDITION:
      return j.FAILED_PRECONDITION;
    case wn.ABORTED:
      return j.ABORTED;
    case wn.OUT_OF_RANGE:
      return j.OUT_OF_RANGE;
    case wn.UNIMPLEMENTED:
      return j.UNIMPLEMENTED;
    case wn.DATA_LOSS:
      return j.DATA_LOSS;
    default:
      return B2();
  }
}
(_n = wn || (wn = {}))[_n.OK = 0] = "OK", _n[_n.CANCELLED = 1] = "CANCELLED", _n[_n.UNKNOWN = 2] = "UNKNOWN", _n[_n.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", _n[_n.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", _n[_n.NOT_FOUND = 5] = "NOT_FOUND", _n[_n.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", _n[_n.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", _n[_n.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", _n[_n.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", _n[_n.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", _n[_n.ABORTED = 10] = "ABORTED", _n[_n.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", _n[_n.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", _n[_n.INTERNAL = 13] = "INTERNAL", _n[_n.UNAVAILABLE = 14] = "UNAVAILABLE", _n[_n.DATA_LOSS = 15] = "DATA_LOSS";
var yn = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || Tn.EMPTY;
  }
  insert(t2, e) {
    return new yn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, Tn.BLACK, null, null));
  }
  remove(t2) {
    return new yn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Tn.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new pn(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new pn(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new pn(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new pn(this.root, t2, this.comparator, true);
  }
};
var pn = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var Tn = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : Tn.RED, this.left = s != null ? s : Tn.EMPTY, this.right = i != null ? i : Tn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new Tn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Tn.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return Tn.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Tn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Tn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw B2();
    if (this.right.isRed())
      throw B2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw B2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
Tn.EMPTY = null, Tn.RED = true, Tn.BLACK = false;
Tn.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw B2();
  }
  get value() {
    throw B2();
  }
  get color() {
    throw B2();
  }
  get left() {
    throw B2();
  }
  get right() {
    throw B2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new Tn(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var En = class {
  constructor(t2) {
    this.comparator = t2, this.data = new yn(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new In(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new In(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof En))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new En(this.comparator);
    return e.data = t2, e;
  }
};
var In = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
var An = new yn(Dt.comparator);
function Rn() {
  return An;
}
var bn = new yn(Dt.comparator);
function Pn() {
  return bn;
}
var vn = new yn(Dt.comparator);
function Vn() {
  return vn;
}
var Sn = new En(Dt.comparator);
function Dn(...t2) {
  let e = Sn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var Cn = new En(rt);
function Nn() {
  return Cn;
}
var kn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = new Map();
    return n.set(t2, xn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new kn(ut.min(), n, Nn(), Rn(), Dn());
  }
};
var xn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new xn(pt.EMPTY_BYTE_STRING, e, Dn(), Dn(), Dn());
  }
};
var $n = class {
  constructor(t2, e, n, s) {
    this.$ = t2, this.removedTargetIds = e, this.key = n, this.O = s;
  }
};
var On = class {
  constructor(t2, e) {
    this.targetId = t2, this.M = e;
  }
};
var Mn = class {
  constructor(t2, e, n = pt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var Fn = class {
  constructor() {
    this.F = 0, this.L = Un(), this.B = pt.EMPTY_BYTE_STRING, this.U = false, this.q = true;
  }
  get current() {
    return this.U;
  }
  get resumeToken() {
    return this.B;
  }
  get K() {
    return this.F !== 0;
  }
  get j() {
    return this.q;
  }
  W(t2) {
    t2.approximateByteSize() > 0 && (this.q = true, this.B = t2);
  }
  G() {
    let t2 = Dn(), e = Dn(), n = Dn();
    return this.L.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          B2();
      }
    }), new xn(this.B, this.U, t2, e, n);
  }
  H() {
    this.q = false, this.L = Un();
  }
  J(t2, e) {
    this.q = true, this.L = this.L.insert(t2, e);
  }
  Y(t2) {
    this.q = true, this.L = this.L.remove(t2);
  }
  X() {
    this.F += 1;
  }
  Z() {
    this.F -= 1;
  }
  tt() {
    this.q = true, this.U = true;
  }
};
var Ln = class {
  constructor(t2) {
    this.et = t2, this.nt = new Map(), this.st = Rn(), this.it = Bn(), this.rt = new En(rt);
  }
  ot(t2) {
    for (const e of t2.$)
      t2.O && t2.O.isFoundDocument() ? this.ct(e, t2.O) : this.at(e, t2.key, t2.O);
    for (const e of t2.removedTargetIds)
      this.at(e, t2.key, t2.O);
  }
  ut(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.ht(e);
      switch (t2.state) {
        case 0:
          this.lt(e) && n.W(t2.resumeToken);
          break;
        case 1:
          n.Z(), n.K || n.H(), n.W(t2.resumeToken);
          break;
        case 2:
          n.Z(), n.K || this.removeTarget(e);
          break;
        case 3:
          this.lt(e) && (n.tt(), n.W(t2.resumeToken));
          break;
        case 4:
          this.lt(e) && (this.ft(e), n.W(t2.resumeToken));
          break;
        default:
          B2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.nt.forEach((t3, n) => {
      this.lt(n) && e(n);
    });
  }
  dt(t2) {
    const e = t2.targetId, n = t2.M.count, s = this.wt(e);
    if (s) {
      const t3 = s.target;
      if (Zt(t3))
        if (n === 0) {
          const n2 = new Dt(t3.path);
          this.at(e, n2, Gt.newNoDocument(n2, ut.min()));
        } else
          U2(n === 1);
      else {
        this._t(e) !== n && (this.ft(e), this.rt = this.rt.add(e));
      }
    }
  }
  gt(t2) {
    const e = new Map();
    this.nt.forEach((n2, s2) => {
      const i = this.wt(s2);
      if (i) {
        if (n2.current && Zt(i.target)) {
          const e2 = new Dt(i.target.path);
          this.st.get(e2) !== null || this.yt(s2, e2) || this.at(s2, e2, Gt.newNoDocument(e2, t2));
        }
        n2.j && (e.set(s2, n2.G()), n2.H());
      }
    });
    let n = Dn();
    this.it.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.wt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    });
    const s = new kn(t2, e, this.rt, this.st, n);
    return this.st = Rn(), this.it = Bn(), this.rt = new En(rt), s;
  }
  ct(t2, e) {
    if (!this.lt(t2))
      return;
    const n = this.yt(t2, e.key) ? 2 : 0;
    this.ht(t2).J(e.key, n), this.st = this.st.insert(e.key, e), this.it = this.it.insert(e.key, this.Tt(e.key).add(t2));
  }
  at(t2, e, n) {
    if (!this.lt(t2))
      return;
    const s = this.ht(t2);
    this.yt(t2, e) ? s.J(e, 1) : s.Y(e), this.it = this.it.insert(e, this.Tt(e).delete(t2)), n && (this.st = this.st.insert(e, n));
  }
  removeTarget(t2) {
    this.nt.delete(t2);
  }
  _t(t2) {
    const e = this.ht(t2).G();
    return this.et.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  X(t2) {
    this.ht(t2).X();
  }
  ht(t2) {
    let e = this.nt.get(t2);
    return e || (e = new Fn(), this.nt.set(t2, e)), e;
  }
  Tt(t2) {
    let e = this.it.get(t2);
    return e || (e = new En(rt), this.it = this.it.insert(t2, e)), e;
  }
  lt(t2) {
    const e = this.wt(t2) !== null;
    return e || O2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  wt(t2) {
    const e = this.nt.get(t2);
    return e && e.K ? null : this.et.Et(t2);
  }
  ft(t2) {
    this.nt.set(t2, new Fn());
    this.et.getRemoteKeysForTarget(t2).forEach((e) => {
      this.at(t2, e, null);
    });
  }
  yt(t2, e) {
    return this.et.getRemoteKeysForTarget(t2).has(e);
  }
};
function Bn() {
  return new yn(Dt.comparator);
}
function Un() {
  return new yn(Dt.comparator);
}
var qn = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var Kn = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var jn = class {
  constructor(t2, e) {
    this.databaseId = t2, this.C = e;
  }
};
function Qn(t2, e) {
  if (t2.C) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Wn(t2, e) {
  return t2.C ? e.toBase64() : e.toUint8Array();
}
function Gn(t2, e) {
  return Qn(t2, e.toTimestamp());
}
function zn(t2) {
  return U2(!!t2), ut.fromTimestamp(function(t3) {
    const e = Et(t3);
    return new at(e.seconds, e.nanos);
  }(t2));
}
function Hn(t2, e) {
  return function(t3) {
    return new wt(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Jn(t2) {
  const e = wt.fromString(t2);
  return U2(Rs(e)), e;
}
function Yn(t2, e) {
  return Hn(t2.databaseId, e.path);
}
function Xn(t2, e) {
  const n = Jn(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new Q2(j.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new Q2(j.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new Dt(ns(n));
}
function Zn(t2, e) {
  return Hn(t2.databaseId, e);
}
function ts(t2) {
  const e = Jn(t2);
  return e.length === 4 ? wt.emptyPath() : ns(e);
}
function es(t2) {
  return new wt(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function ns(t2) {
  return U2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function ss(t2, e, n) {
  return {
    name: Yn(t2, e),
    fields: n.value.mapValue.fields
  };
}
function is(t2, e, n) {
  const s = Xn(t2, e.name), i = zn(e.updateTime), r = new Qt({
    mapValue: {
      fields: e.fields
    }
  }), o = Gt.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function rs(t2, e) {
  return "found" in e ? function(t3, e2) {
    U2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Xn(t3, e2.found.name), s = zn(e2.found.updateTime), i = new Qt({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return Gt.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    U2(!!e2.missing), U2(!!e2.readTime);
    const n = Xn(t3, e2.missing), s = zn(e2.readTime);
    return Gt.newNoDocument(n, s);
  }(t2, e) : B2();
}
function os(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : B2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.C ? (U2(e2 === void 0 || typeof e2 == "string"), pt.fromBase64String(e2 || "")) : (U2(e2 === void 0 || e2 instanceof Uint8Array), pt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, c = o && function(t3) {
      const e2 = t3.code === void 0 ? j.UNKNOWN : gn(t3.code);
      return new Q2(e2, t3.message || "");
    }(o);
    n = new Mn(s, i, r, c || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Xn(t2, s.document.name), r = zn(s.document.updateTime), o = new Qt({
      mapValue: {
        fields: s.document.fields
      }
    }), c = Gt.newFoundDocument(i, r, o), a = s.targetIds || [], u = s.removedTargetIds || [];
    n = new $n(a, u, c.key, c);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Xn(t2, s.document), r = s.readTime ? zn(s.readTime) : ut.min(), o = Gt.newNoDocument(i, r), c = s.removedTargetIds || [];
    n = new $n([], c, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Xn(t2, s.document), r = s.removedTargetIds || [];
    n = new $n([], r, i, null);
  } else {
    if (!("filter" in e))
      return B2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new dn(s), r = t3.targetId;
      n = new On(r, i);
    }
  }
  return n;
}
function cs(t2, e) {
  let n;
  if (e instanceof on)
    n = {
      update: ss(t2, e.key, e.value)
    };
  else if (e instanceof ln)
    n = {
      delete: Yn(t2, e.key)
    };
  else if (e instanceof cn)
    n = {
      update: ss(t2, e.key, e.data),
      updateMask: As(e.fieldMask)
    };
  else {
    if (!(e instanceof fn))
      return B2();
    n = {
      verify: Yn(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof Be)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Ue)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Ke)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Qe)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.N
      };
    throw B2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: Gn(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : B2();
  }(t2, e.precondition)), n;
}
function as(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? Ye.updateTime(zn(t3.updateTime)) : t3.exists !== void 0 ? Ye.exists(t3.exists) : Ye.none();
  }(e.currentDocument) : Ye.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      U2(e3.setToServerValue === "REQUEST_TIME"), n2 = new Be();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Ue(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new Ke(t4);
    } else
      "increment" in e3 ? n2 = new Qe(t3, e3.increment) : B2();
    const s2 = mt.fromServerFormat(e3.fieldPath);
    return new ze(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Xn(t2, e.update.name), r = new Qt({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new gt(e2.map((t5) => mt.fromServerFormat(t5)));
      }(e.updateMask);
      return new cn(i, r, t3, n, s);
    }
    return new on(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Xn(t2, e.delete);
    return new ln(s2, n);
  }
  if (e.verify) {
    const s2 = Xn(t2, e.verify);
    return new fn(s2, n);
  }
  return B2();
}
function us(t2, e) {
  return t2 && t2.length > 0 ? (U2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? zn(t4.updateTime) : zn(e2);
    return n.isEqual(ut.min()) && (n = zn(e2)), new Je(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function hs(t2, e) {
  return {
    documents: [Zn(t2, e.path)]
  };
}
function ls(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = Zn(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = Zn(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (qt(t5.value))
          return {
            unaryFilter: {
              field: ps(t5.field),
              op: "IS_NAN"
            }
          };
        if (Ut(t5.value))
          return {
            unaryFilter: {
              field: ps(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (qt(t5.value))
          return {
            unaryFilter: {
              field: ps(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Ut(t5.value))
          return {
            unaryFilter: {
              field: ps(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: ps(t5.field),
          op: ys(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: ps(t5.field),
        direction: gs(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.C || vt(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = _s(e.startAt)), e.endAt && (n.structuredQuery.endAt = _s(e.endAt)), n;
}
function fs(t2) {
  let e = ts(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    U2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = ws(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new fe(Ts(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let c = null;
  n.limit && (c = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, vt(e2) ? null : e2;
  }(n.limit));
  let a = null;
  n.startAt && (a = ms(n.startAt));
  let u = null;
  return n.endAt && (u = ms(n.endAt)), ge(e, i, o, r, c, "F", a, u);
}
function ds(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return B2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function ws(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [Is(t2)] : t2.fieldFilter !== void 0 ? [Es(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => ws(t3)).reduce((t3, e) => t3.concat(e)) : B2() : [];
}
function _s(t2) {
  return {
    before: t2.before,
    values: t2.position
  };
}
function ms(t2) {
  const e = !!t2.before, n = t2.values || [];
  return new he(n, e);
}
function gs(t2) {
  return qn[t2];
}
function ys(t2) {
  return Kn[t2];
}
function ps(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function Ts(t2) {
  return mt.fromServerFormat(t2.fieldPath);
}
function Es(t2) {
  return te.create(Ts(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return B2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function Is(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = Ts(t2.unaryFilter.field);
      return te.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = Ts(t2.unaryFilter.field);
      return te.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = Ts(t2.unaryFilter.field);
      return te.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = Ts(t2.unaryFilter.field);
      return te.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return B2();
  }
}
function As(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function Rs(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function bs(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = vs(e)), e = Ps(t2.get(n), e);
  return vs(e);
}
function Ps(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function vs(t2) {
  return t2 + "";
}
function Vs(t2) {
  const e = t2.length;
  if (U2(e >= 2), e === 2)
    return U2(t2.charAt(0) === "" && t2.charAt(1) === ""), wt.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && B2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        B2();
    }
    r = e2 + 2;
  }
  return new wt(s);
}
var Ss = class {
  constructor(t2, e) {
    this.seconds = t2, this.nanoseconds = e;
  }
};
var Ds = class {
  constructor(t2, e, n) {
    this.ownerId = t2, this.allowTabSynchronization = e, this.leaseTimestampMs = n;
  }
};
Ds.store = "owner", Ds.key = "owner";
var Cs = class {
  constructor(t2, e, n) {
    this.userId = t2, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;
  }
};
Cs.store = "mutationQueues", Cs.keyPath = "userId";
var Ns = class {
  constructor(t2, e, n, s, i) {
    this.userId = t2, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = s, this.mutations = i;
  }
};
Ns.store = "mutations", Ns.keyPath = "batchId", Ns.userMutationsIndex = "userMutationsIndex", Ns.userMutationsKeyPath = ["userId", "batchId"];
var ks = class {
  constructor() {
  }
  static prefixForUser(t2) {
    return [t2];
  }
  static prefixForPath(t2, e) {
    return [t2, bs(e)];
  }
  static key(t2, e, n) {
    return [t2, bs(e), n];
  }
};
ks.store = "documentMutations", ks.PLACEHOLDER = new ks();
var xs = class {
  constructor(t2, e) {
    this.path = t2, this.readTime = e;
  }
};
var $s = class {
  constructor(t2, e) {
    this.path = t2, this.version = e;
  }
};
var Os = class {
  constructor(t2, e, n, s, i, r) {
    this.unknownDocument = t2, this.noDocument = e, this.document = n, this.hasCommittedMutations = s, this.readTime = i, this.parentPath = r;
  }
};
Os.store = "remoteDocuments", Os.readTimeIndex = "readTimeIndex", Os.readTimeIndexPath = "readTime", Os.collectionReadTimeIndex = "collectionReadTimeIndex", Os.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var Ms = class {
  constructor(t2) {
    this.byteSize = t2;
  }
};
Ms.store = "remoteDocumentGlobal", Ms.key = "remoteDocumentGlobalKey";
var Fs = class {
  constructor(t2, e, n, s, i, r, o) {
    this.targetId = t2, this.canonicalId = e, this.readTime = n, this.resumeToken = s, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = r, this.query = o;
  }
};
Fs.store = "targets", Fs.keyPath = "targetId", Fs.queryTargetsIndexName = "queryTargetsIndex", Fs.queryTargetsKeyPath = ["canonicalId", "targetId"];
var Ls = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.path = e, this.sequenceNumber = n;
  }
};
Ls.store = "targetDocuments", Ls.keyPath = ["targetId", "path"], Ls.documentTargetsIndex = "documentTargetsIndex", Ls.documentTargetsKeyPath = ["path", "targetId"];
var Bs = class {
  constructor(t2, e, n, s) {
    this.highestTargetId = t2, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = s;
  }
};
Bs.key = "targetGlobalKey", Bs.store = "targetGlobal";
var Us = class {
  constructor(t2, e) {
    this.collectionId = t2, this.parent = e;
  }
};
Us.store = "collectionParents", Us.keyPath = ["collectionId", "parent"];
var qs = class {
  constructor(t2, e, n, s) {
    this.clientId = t2, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = s;
  }
};
qs.store = "clientMetadata", qs.keyPath = "clientId";
var Ks = class {
  constructor(t2, e, n) {
    this.bundleId = t2, this.createTime = e, this.version = n;
  }
};
Ks.store = "bundles", Ks.keyPath = "bundleId";
var js = class {
  constructor(t2, e, n) {
    this.name = t2, this.readTime = e, this.bundledQuery = n;
  }
};
js.store = "namedQueries", js.keyPath = "name";
var Qs = [...[...[...[...[Cs.store, Ns.store, ks.store, Os.store, Fs.store, Ds.store, Bs.store, Ls.store], qs.store], Ms.store], Us.store], Ks.store, js.store];
var Ws = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var Gs = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var zs = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && B2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new zs((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof zs ? e : zs.resolve(e);
    } catch (t3) {
      return zs.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : zs.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : zs.reject(e);
  }
  static resolve(t2) {
    return new zs((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new zs((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new zs((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = zs.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? zs.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var Hs = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.It = new W2(), this.transaction.oncomplete = () => {
      this.It.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.It.reject(new Xs(t2, e.error)) : this.It.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = si(e2.target.error);
      this.It.reject(new Xs(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new Hs(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Xs(e, t3);
    }
  }
  get At() {
    return this.It.promise;
  }
  abort(t2) {
    t2 && this.It.reject(t2), this.aborted || (O2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new ti(e);
  }
};
var Js = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.Rt = n;
    Js.bt(getUA()) === 12.2 && M2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return O2("SimpleDb", "Removing database:", t2), ei(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static Pt() {
    if (!isIndexedDBAvailable())
      return false;
    if (Js.vt())
      return true;
    const t2 = getUA(), e = Js.bt(t2), n = 0 < e && e < 10, s = Js.Vt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static vt() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.St) === "YES";
  }
  static Dt(t2, e) {
    return t2.store(e);
  }
  static bt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static Vt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async Ct(t2) {
    return this.db || (O2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Xs(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new Q2(j.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new Q2(j.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new Xs(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        O2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.Rt.Nt(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          O2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.kt && (this.db.onversionchange = (t3) => this.kt(t3)), this.db;
  }
  xt(t2) {
    this.kt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.Ct(t2);
        const e2 = Hs.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).catch((t3) => (e2.abort(t3), zs.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.At, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if (O2("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var Ys = class {
  constructor(t2) {
    this.$t = t2, this.Ot = false, this.Mt = null;
  }
  get isDone() {
    return this.Ot;
  }
  get Ft() {
    return this.Mt;
  }
  set cursor(t2) {
    this.$t = t2;
  }
  done() {
    this.Ot = true;
  }
  Lt(t2) {
    this.Mt = t2;
  }
  delete() {
    return ei(this.$t.delete());
  }
};
var Xs = class extends Q2 {
  constructor(t2, e) {
    super(j.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Zs(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var ti = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? (O2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (O2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), ei(n);
  }
  add(t2) {
    O2("SimpleDb", "ADD", this.store.name, t2, t2);
    return ei(this.store.add(t2));
  }
  get(t2) {
    return ei(this.store.get(t2)).next((e) => (e === void 0 && (e = null), O2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    O2("SimpleDb", "DELETE", this.store.name, t2);
    return ei(this.store.delete(t2));
  }
  count() {
    O2("SimpleDb", "COUNT", this.store.name);
    return ei(this.store.count());
  }
  Bt(t2, e) {
    const n = this.cursor(this.options(t2, e)), s = [];
    return this.Ut(n, (t3, e2) => {
      s.push(e2);
    }).next(() => s);
  }
  qt(t2, e) {
    O2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.Kt = false;
    const s = this.cursor(n);
    return this.Ut(s, (t3, e2, n2) => n2.delete());
  }
  jt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Ut(s, e);
  }
  Qt(t2) {
    const e = this.cursor({});
    return new zs((n, s) => {
      e.onerror = (t3) => {
        const e2 = si(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Ut(t2, e) {
    const n = [];
    return new zs((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new Ys(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof zs) {
          const t4 = o.catch((t5) => (r.done(), zs.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Ft === null ? i2.continue() : i2.continue(r.Ft);
      };
    }).next(() => zs.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.Kt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function ei(t2) {
  return new zs((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = si(t3.target.error);
      n(e2);
    };
  });
}
var ni = false;
function si(t2) {
  const e = Js.bt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new Q2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return ni || (ni = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var ii = class extends Gs {
  constructor(t2, e) {
    super(), this.Wt = t2, this.currentSequenceNumber = e;
  }
};
function ri(t2, e) {
  const n = K2(t2);
  return Js.Dt(n.Wt, e);
}
var oi = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        tn(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && en(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && en(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(ut.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), Dn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && ot(this.mutations, t2.mutations, (t3, e) => sn(t3, e)) && ot(this.baseMutations, t2.baseMutations, (t3, e) => sn(t3, e));
  }
};
var ci = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    U2(t2.mutations.length === n.length);
    let s = Vn();
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new ci(t2, e, n, s);
  }
};
var ai = class {
  constructor(t2, e, n, s, i = ut.min(), r = ut.min(), o = pt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new ai(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new ai(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new ai(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var ui = class {
  constructor(t2) {
    this.Gt = t2;
  }
};
function hi(t2, e) {
  if (e.document)
    return is(t2.Gt, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    const t3 = Dt.fromSegments(e.noDocument.path), n = _i(e.noDocument.readTime), s = Gt.newNoDocument(t3, n);
    return e.hasCommittedMutations ? s.setHasCommittedMutations() : s;
  }
  if (e.unknownDocument) {
    const t3 = Dt.fromSegments(e.unknownDocument.path), n = _i(e.unknownDocument.version);
    return Gt.newUnknownDocument(t3, n);
  }
  return B2();
}
function li(t2, e, n) {
  const s = fi(n), i = e.key.path.popLast().toArray();
  if (e.isFoundDocument()) {
    const n2 = function(t3, e2) {
      return {
        name: Yn(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Qn(t3, e2.version.toTimestamp())
      };
    }(t2.Gt, e), r = e.hasCommittedMutations;
    return new Os(null, null, n2, r, s, i);
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), n2 = wi(e.version), r = e.hasCommittedMutations;
    return new Os(null, new xs(t3, n2), null, r, s, i);
  }
  if (e.isUnknownDocument()) {
    const t3 = e.key.path.toArray(), n2 = wi(e.version);
    return new Os(new $s(t3, n2), null, null, true, s, i);
  }
  return B2();
}
function fi(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function di(t2) {
  const e = new at(t2[0], t2[1]);
  return ut.fromTimestamp(e);
}
function wi(t2) {
  const e = t2.toTimestamp();
  return new Ss(e.seconds, e.nanoseconds);
}
function _i(t2) {
  const e = new at(t2.seconds, t2.nanoseconds);
  return ut.fromTimestamp(e);
}
function mi(t2, e) {
  const n = (e.baseMutations || []).map((e2) => as(t2.Gt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => as(t2.Gt, e2)), i = at.fromMillis(e.localWriteTimeMs);
  return new oi(e.batchId, i, n, s);
}
function gi(t2) {
  const e = _i(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? _i(t2.lastLimboFreeSnapshotVersion) : ut.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (U2((i = t2.query).documents.length === 1), s = be(ye(ts(i.documents[0])))) : s = function(t3) {
    return be(fs(t3));
  }(t2.query), new ai(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, pt.fromBase64String(t2.resumeToken));
}
function yi(t2, e) {
  const n = wi(e.snapshotVersion), s = wi(e.lastLimboFreeSnapshotVersion);
  let i;
  i = Zt(e.target) ? hs(t2.Gt, e.target) : ls(t2.Gt, e.target);
  const r = e.resumeToken.toBase64();
  return new Fs(e.targetId, Jt(e.target), n, r, e.sequenceNumber, s, i);
}
function pi(t2) {
  const e = fs({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Pe(e, e.limit, "L") : e;
}
var Ti = class {
  getBundleMetadata(t2, e) {
    return Ei(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: _i(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return Ei(t2).put({
      bundleId: (n = e).id,
      createTime: wi(zn(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return Ii(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: pi(e2.bundledQuery),
          readTime: _i(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return Ii(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: wi(zn(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function Ei(t2) {
  return ri(t2, Ks.store);
}
function Ii(t2) {
  return ri(t2, js.store);
}
var Ai = class {
  constructor() {
    this.zt = new Ri();
  }
  addToCollectionParentIndex(t2, e) {
    return this.zt.add(e), zs.resolve();
  }
  getCollectionParents(t2, e) {
    return zs.resolve(this.zt.getEntries(e));
  }
};
var Ri = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new En(wt.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new En(wt.comparator)).toArray();
  }
};
var bi = class {
  constructor() {
    this.Ht = new Ri();
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.Ht.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.Ht.add(e);
      });
      const i = {
        collectionId: n,
        parent: bs(s)
      };
      return Pi(t2).put(i);
    }
    return zs.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [ct(e), ""], false, true);
    return Pi(t2).Bt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(Vs(s2.parent));
      }
      return n;
    });
  }
};
function Pi(t2) {
  return ri(t2, Us.store);
}
var vi = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var Vi = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new Vi(t2, Vi.DEFAULT_COLLECTION_PERCENTILE, Vi.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function Si(t2, e, n) {
  const s = t2.store(Ns.store), i = t2.store(ks.store), r = [], o = IDBKeyRange.only(n.batchId);
  let c = 0;
  const a = s.jt({
    range: o
  }, (t3, e2, n2) => (c++, n2.delete()));
  r.push(a.next(() => {
    U2(c === 1);
  }));
  const u = [];
  for (const t3 of n.mutations) {
    const s2 = ks.key(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), u.push(t3.key);
  }
  return zs.waitFor(r).next(() => u);
}
function Di(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw B2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
Vi.DEFAULT_COLLECTION_PERCENTILE = 10, Vi.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Vi.DEFAULT = new Vi(41943040, Vi.DEFAULT_COLLECTION_PERCENTILE, Vi.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Vi.DISABLED = new Vi(-1, 0, 0);
var Ci = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.k = e, this.Jt = n, this.referenceDelegate = s, this.Yt = {};
  }
  static Xt(t2, e, n, s) {
    U2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new Ci(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return ki(t2).jt({
      index: Ns.userMutationsIndex,
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = xi(t2), r = ki(t2);
    return r.add({}).next((o) => {
      U2(typeof o == "number");
      const c = new oi(o, e, n, s), a = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => cs(t3.Gt, e3)), i2 = n2.mutations.map((e3) => cs(t3.Gt, e3));
        return new Ns(e2, n2.batchId, n2.localWriteTime.toMillis(), s2, i2);
      }(this.k, this.userId, c), u = [];
      let h = new En((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = ks.key(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), u.push(r.put(a)), u.push(i.put(e2, ks.PLACEHOLDER));
      }
      return h.forEach((e2) => {
        u.push(this.Jt.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.Yt[o] = c.keys();
      }), zs.waitFor(u).next(() => c);
    });
  }
  lookupMutationBatch(t2, e) {
    return ki(t2).get(e).next((t3) => t3 ? (U2(t3.userId === this.userId), mi(this.k, t3)) : null);
  }
  Zt(t2, e) {
    return this.Yt[e] ? zs.resolve(this.Yt[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.Yt[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return ki(t2).jt({
      index: Ns.userMutationsIndex,
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (U2(e2.batchId >= n), i = mi(this.k, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return ki(t2).jt({
      index: Ns.userMutationsIndex,
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return ki(t2).Bt(Ns.userMutationsIndex, e).next((t3) => t3.map((t4) => mi(this.k, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = ks.prefixForPath(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return xi(t2).jt({
      range: s
    }, (n2, s2, r) => {
      const [o, c, a] = n2, u = Vs(c);
      if (o === this.userId && e.path.isEqual(u))
        return ki(t2).get(a).next((t3) => {
          if (!t3)
            throw B2();
          U2(t3.userId === this.userId), i.push(mi(this.k, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new En(rt);
    const s = [];
    return e.forEach((e2) => {
      const i = ks.prefixForPath(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = xi(t2).jt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, c] = t3, a = Vs(o2);
        r2 === this.userId && e2.path.isEqual(a) ? n = n.add(c) : i2.done();
      });
      s.push(o);
    }), zs.waitFor(s).next(() => this.te(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = ks.prefixForPath(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new En(rt);
    return xi(t2).jt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, c, a] = t3, u = Vs(c);
      r2 === this.userId && n.isPrefixOf(u) ? u.length === s && (o = o.add(a)) : i2.done();
    }).next(() => this.te(t2, o));
  }
  te(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(ki(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw B2();
        U2(t3.userId === this.userId), n.push(mi(this.k, t3));
      }));
    }), zs.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return Si(t2.Wt, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.ee(e.batchId);
    }), zs.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  ee(t2) {
    delete this.Yt[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return zs.resolve();
      const n = IDBKeyRange.lowerBound(ks.prefixForUser(this.userId)), s = [];
      return xi(t2).jt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = Vs(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        U2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return Ni(t2, this.userId, e);
  }
  ne(t2) {
    return $i(t2).get(this.userId).next((t3) => t3 || new Cs(this.userId, -1, ""));
  }
};
function Ni(t2, e, n) {
  const s = ks.prefixForPath(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return xi(t2).jt({
    range: r,
    Kt: true
  }, (t3, n2, s2) => {
    const [r2, c, a] = t3;
    r2 === e && c === i && (o = true), s2.done();
  }).next(() => o);
}
function ki(t2) {
  return ri(t2, Ns.store);
}
function xi(t2) {
  return ri(t2, ks.store);
}
function $i(t2) {
  return ri(t2, Cs.store);
}
var Oi = class {
  constructor(t2) {
    this.se = t2;
  }
  next() {
    return this.se += 2, this.se;
  }
  static ie() {
    return new Oi(0);
  }
  static re() {
    return new Oi(-1);
  }
};
var Mi = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.k = e;
  }
  allocateTargetId(t2) {
    return this.oe(t2).next((e) => {
      const n = new Oi(e.highestTargetId);
      return e.highestTargetId = n.next(), this.ce(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.oe(t2).next((t3) => ut.fromTimestamp(new at(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.oe(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.oe(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.ce(t2, s)));
  }
  addTargetData(t2, e) {
    return this.ae(t2, e).next(() => this.oe(t2).next((n) => (n.targetCount += 1, this.ue(e, n), this.ce(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.ae(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => Fi(t2).delete(e.targetId)).next(() => this.oe(t2)).next((e2) => (U2(e2.targetCount > 0), e2.targetCount -= 1, this.ce(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return Fi(t2).jt((r, o) => {
      const c = gi(o);
      c.sequenceNumber <= e && n.get(c.targetId) === null && (s++, i.push(this.removeTargetData(t2, c)));
    }).next(() => zs.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return Fi(t2).jt((t3, n) => {
      const s = gi(n);
      e(s);
    });
  }
  oe(t2) {
    return Li(t2).get(Bs.key).next((t3) => (U2(t3 !== null), t3));
  }
  ce(t2, e) {
    return Li(t2).put(Bs.key, e);
  }
  ae(t2, e) {
    return Fi(t2).put(yi(this.k, e));
  }
  ue(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.oe(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = Jt(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return Fi(t2).jt({
      range: s,
      index: Fs.queryTargetsIndexName
    }, (t3, n2, s2) => {
      const r = gi(n2);
      Xt(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = Bi(t2);
    return e.forEach((e2) => {
      const r = bs(e2.path);
      s.push(i.put(new Ls(n, r))), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), zs.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = Bi(t2);
    return zs.forEach(e, (e2) => {
      const i = bs(e2.path);
      return zs.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = Bi(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = Bi(t2);
    let i = Dn();
    return s.jt({
      range: n,
      Kt: true
    }, (t3, e2, n2) => {
      const s2 = Vs(t3[1]), r = new Dt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = bs(e.path), s = IDBKeyRange.bound([n], [ct(n)], false, true);
    let i = 0;
    return Bi(t2).jt({
      index: Ls.documentTargetsIndex,
      Kt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Et(t2, e) {
    return Fi(t2).get(e).next((t3) => t3 ? gi(t3) : null);
  }
};
function Fi(t2) {
  return ri(t2, Fs.store);
}
function Li(t2) {
  return ri(t2, Bs.store);
}
function Bi(t2) {
  return ri(t2, Ls.store);
}
async function Ui(t2) {
  if (t2.code !== j.FAILED_PRECONDITION || t2.message !== Ws)
    throw t2;
  O2("LocalStore", "Unexpectedly lost primary lease");
}
function qi([t2, e], [n, s]) {
  const i = rt(t2, n);
  return i === 0 ? rt(e, s) : i;
}
var Ki = class {
  constructor(t2) {
    this.he = t2, this.buffer = new En(qi), this.le = 0;
  }
  fe() {
    return ++this.le;
  }
  de(t2) {
    const e = [t2, this.fe()];
    if (this.buffer.size < this.he)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      qi(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var ji = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.we = false, this._e = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this.me(t2);
  }
  stop() {
    this._e && (this._e.cancel(), this._e = null);
  }
  get started() {
    return this._e !== null;
  }
  me(t2) {
    const e = this.we ? 3e5 : 6e4;
    O2("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this._e = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this._e = null, this.we = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Zs(t3) ? O2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Ui(t3);
      }
      await this.me(t2);
    });
  }
};
var Qi = class {
  constructor(t2, e) {
    this.ge = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.ge.ye(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return zs.resolve(nt.I);
    const n = new Ki(e);
    return this.ge.forEachTarget(t2, (t3) => n.de(t3.sequenceNumber)).next(() => this.ge.pe(t2, (t3) => n.de(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.ge.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.ge.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (O2("LruGarbageCollector", "Garbage collection skipped; disabled"), zs.resolve(vi)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (O2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), vi) : this.Te(t2, e));
  }
  getCacheSize(t2) {
    return this.ge.getCacheSize(t2);
  }
  Te(t2, e) {
    let n, s, i, r, o, a, u;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (O2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, a = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (u = Date.now(), x2() <= LogLevel.DEBUG) {
        O2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (a - o) + `ms
	Removed ${t3} documents in ` + (u - a) + `ms
Total Duration: ${u - h}ms`);
      }
      return zs.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Wi = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new Qi(t3, e2);
    }(this, e);
  }
  ye(t2) {
    const e = this.Ee(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  Ee(t2) {
    let e = 0;
    return this.pe(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  pe(t2, e) {
    return this.Ie(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Gi(t2, n);
  }
  removeReference(t2, e, n) {
    return Gi(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Gi(t2, e);
  }
  Ae(t2, e) {
    return function(t3, e2) {
      let n = false;
      return $i(t3).Qt((s) => Ni(t3, s, e2).next((t4) => (t4 && (n = true), zs.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Ie(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Ae(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r), Bi(t2).delete([0, bs(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => zs.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Gi(t2, e);
  }
  Ie(t2, e) {
    const n = Bi(t2);
    let s, i = nt.I;
    return n.jt({
      index: Ls.documentTargetsIndex
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== nt.I && e(new Dt(Vs(s)), i), i = o, s = r) : i = nt.I;
    }).next(() => {
      i !== nt.I && e(new Dt(Vs(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Gi(t2, e) {
  return Bi(t2).put(function(t3, e2) {
    return new Ls(0, bs(t3.path), e2);
  }(e, t2.currentSequenceNumber));
}
var zi = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s !== void 0) {
      for (let n2 = 0; n2 < s.length; n2++)
        if (this.equalsFn(s[n2][0], t2))
          return void (s[n2] = [t2, e]);
      s.push([t2, e]);
    } else
      this.inner[n] = [[t2, e]];
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), true;
    return false;
  }
  forEach(t2) {
    lt(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return ft(this.inner);
  }
};
var Hi = class {
  constructor() {
    this.changes = new zi((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  getReadTime(t2) {
    const e = this.changes.get(t2);
    return e ? e.readTime : ut.min();
  }
  addEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2.key, {
      document: t2,
      readTime: e
    });
  }
  removeEntry(t2, e = null) {
    this.assertNotApplied(), this.changes.set(t2, {
      document: Gt.newInvalidDocument(t2),
      readTime: e
    });
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? zs.resolve(n.document) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var Ji = class {
  constructor(t2, e) {
    this.k = t2, this.Jt = e;
  }
  addEntry(t2, e, n) {
    return Zi(t2).put(tr(e), n);
  }
  removeEntry(t2, e) {
    const n = Zi(t2), s = tr(e);
    return n.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.Re(t2, n)));
  }
  getEntry(t2, e) {
    return Zi(t2).get(tr(e)).next((t3) => this.be(e, t3));
  }
  Pe(t2, e) {
    return Zi(t2).get(tr(e)).next((t3) => ({
      document: this.be(e, t3),
      size: Di(t3)
    }));
  }
  getEntries(t2, e) {
    let n = Rn();
    return this.ve(t2, e, (t3, e2) => {
      const s = this.be(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  Ve(t2, e) {
    let n = Rn(), s = new yn(Dt.comparator);
    return this.ve(t2, e, (t3, e2) => {
      const i = this.be(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Di(e2));
    }).next(() => ({
      documents: n,
      Se: s
    }));
  }
  ve(t2, e, n) {
    if (e.isEmpty())
      return zs.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r = i.getNext();
    return Zi(t2).jt({
      range: s
    }, (t3, e2, s2) => {
      const o = Dt.fromSegments(t3);
      for (; r && Dt.comparator(r, o) < 0; )
        n(r, null), r = i.getNext();
      r && r.isEqual(o) && (n(r, e2), r = i.hasNext() ? i.getNext() : null), r ? s2.Lt(r.path.toArray()) : s2.done();
    }).next(() => {
      for (; r; )
        n(r, null), r = i.hasNext() ? i.getNext() : null;
    });
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = Rn();
    const i = e.path.length + 1, r = {};
    if (n.isEqual(ut.min())) {
      const t3 = e.path.toArray();
      r.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.path.toArray(), s2 = fi(n);
      r.range = IDBKeyRange.lowerBound([t3, s2], true), r.index = Os.collectionReadTimeIndex;
    }
    return Zi(t2).jt(r, (t3, n2, r2) => {
      if (t3.length !== i)
        return;
      const o = hi(this.k, n2);
      e.path.isPrefixOf(o.key.path) ? De(e, o) && (s = s.insert(o.key, o)) : r2.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Yi(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Xi(t2).get(Ms.key).next((t3) => (U2(!!t3), t3));
  }
  Re(t2, e) {
    return Xi(t2).put(Ms.key, e);
  }
  be(t2, e) {
    if (e) {
      const t3 = hi(this.k, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(ut.min())))
        return t3;
    }
    return Gt.newInvalidDocument(t2);
  }
};
var Yi = class extends Hi {
  constructor(t2, e) {
    super(), this.De = t2, this.trackRemovals = e, this.Ce = new zi((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new En((t3, e2) => rt(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Ce.get(i);
      if (r.document.isValidDocument()) {
        const c = li(this.De.k, r.document, this.getReadTime(i));
        s = s.add(i.path.popLast());
        const a = Di(c);
        n += a - o, e.push(this.De.addEntry(t2, i, c));
      } else if (n -= o, this.trackRemovals) {
        const n2 = li(this.De.k, Gt.newNoDocument(i, ut.min()), this.getReadTime(i));
        e.push(this.De.addEntry(t2, i, n2));
      } else
        e.push(this.De.removeEntry(t2, i));
    }), s.forEach((n2) => {
      e.push(this.De.Jt.addToCollectionParentIndex(t2, n2));
    }), e.push(this.De.updateMetadata(t2, n)), zs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.De.Pe(t2, e).next((t3) => (this.Ce.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.De.Ve(t2, e).next(({ documents: t3, Se: e2 }) => (e2.forEach((t4, e3) => {
      this.Ce.set(t4, e3);
    }), t3));
  }
};
function Xi(t2) {
  return ri(t2, Ms.store);
}
function Zi(t2) {
  return ri(t2, Os.store);
}
function tr(t2) {
  return t2.path.toArray();
}
var er = class {
  constructor(t2) {
    this.k = t2;
  }
  Nt(t2, e, n, s) {
    U2(n < s && n >= 0 && s <= 11);
    const i = new Hs("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore(Ds.store);
    }(t2), function(t3) {
      t3.createObjectStore(Cs.store, {
        keyPath: Cs.keyPath
      });
      t3.createObjectStore(Ns.store, {
        keyPath: Ns.keyPath,
        autoIncrement: true
      }).createIndex(Ns.userMutationsIndex, Ns.userMutationsKeyPath, {
        unique: true
      }), t3.createObjectStore(ks.store);
    }(t2), nr(t2), function(t3) {
      t3.createObjectStore(Os.store);
    }(t2));
    let r = zs.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore(Ls.store), t3.deleteObjectStore(Fs.store), t3.deleteObjectStore(Bs.store);
    }(t2), nr(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store(Bs.store), n2 = new Bs(0, 0, ut.min().toTimestamp(), 0);
      return e2.put(Bs.key, n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store(Ns.store).Bt().next((n2) => {
        t3.deleteObjectStore(Ns.store);
        t3.createObjectStore(Ns.store, {
          keyPath: Ns.keyPath,
          autoIncrement: true
        }).createIndex(Ns.userMutationsIndex, Ns.userMutationsKeyPath, {
          unique: true
        });
        const s2 = e2.store(Ns.store), i2 = n2.map((t4) => s2.put(t4));
        return zs.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(qs.store, {
          keyPath: qs.keyPath
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Ne(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore(Ms.store);
    }(t2), this.ke(i)))), n < 7 && s >= 7 && (r = r.next(() => this.xe(i))), n < 8 && s >= 8 && (r = r.next(() => this.$e(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore(Os.store);
        e2.createIndex(Os.readTimeIndex, Os.readTimeIndexPath, {
          unique: false
        }), e2.createIndex(Os.collectionReadTimeIndex, Os.collectionReadTimeIndexPath, {
          unique: false
        });
      }(e);
    })), n < 10 && s >= 10 && (r = r.next(() => this.Oe(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Ks.store, {
          keyPath: Ks.keyPath
        });
      }(t2), function(t3) {
        t3.createObjectStore(js.store, {
          keyPath: js.keyPath
        });
      }(t2);
    })), r;
  }
  ke(t2) {
    let e = 0;
    return t2.store(Os.store).jt((t3, n) => {
      e += Di(n);
    }).next(() => {
      const n = new Ms(e);
      return t2.store(Ms.store).put(Ms.key, n);
    });
  }
  Ne(t2) {
    const e = t2.store(Cs.store), n = t2.store(Ns.store);
    return e.Bt().next((e2) => zs.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.Bt(Ns.userMutationsIndex, s).next((n2) => zs.forEach(n2, (n3) => {
        U2(n3.userId === e3.userId);
        const s2 = mi(this.k, n3);
        return Si(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  xe(t2) {
    const e = t2.store(Ls.store), n = t2.store(Os.store);
    return t2.store(Bs.store).get(Bs.key).next((t3) => {
      const s = [];
      return n.jt((n2, i) => {
        const r = new wt(n2), o = function(t4) {
          return [0, bs(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? zs.resolve() : ((n4) => e.put(new Ls(0, bs(n4), t3.highestListenSequenceNumber)))(r)));
      }).next(() => zs.waitFor(s));
    });
  }
  $e(t2, e) {
    t2.createObjectStore(Us.store, {
      keyPath: Us.keyPath
    });
    const n = e.store(Us.store), s = new Ri(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: bs(s2)
        });
      }
    };
    return e.store(Os.store).jt({
      Kt: true
    }, (t3, e2) => {
      const n2 = new wt(t3);
      return i(n2.popLast());
    }).next(() => e.store(ks.store).jt({
      Kt: true
    }, ([t3, e2, n2], s2) => {
      const r = Vs(e2);
      return i(r.popLast());
    }));
  }
  Oe(t2) {
    const e = t2.store(Fs.store);
    return e.jt((t3, n) => {
      const s = gi(n), i = yi(this.k, s);
      return e.put(i);
    });
  }
};
function nr(t2) {
  t2.createObjectStore(Ls.store, {
    keyPath: Ls.keyPath
  }).createIndex(Ls.documentTargetsIndex, Ls.documentTargetsKeyPath, {
    unique: true
  });
  t2.createObjectStore(Fs.store, {
    keyPath: Fs.keyPath
  }).createIndex(Fs.queryTargetsIndexName, Fs.queryTargetsKeyPath, {
    unique: true
  }), t2.createObjectStore(Bs.store);
}
var sr = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var ir = class {
  constructor(t2, e, n, s, i, r, o, c, a, u) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Me = i, this.window = r, this.document = o, this.Fe = a, this.Le = u, this.Be = null, this.Ue = false, this.isPrimary = false, this.networkEnabled = true, this.qe = null, this.inForeground = false, this.Ke = null, this.je = null, this.Qe = Number.NEGATIVE_INFINITY, this.We = (t3) => Promise.resolve(), !ir.Pt())
      throw new Q2(j.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Wi(this, s), this.Ge = e + "main", this.k = new ui(c), this.ze = new Js(this.Ge, 11, new er(this.k)), this.He = new Mi(this.referenceDelegate, this.k), this.Jt = new bi(), this.Je = function(t3, e2) {
      return new Ji(t3, e2);
    }(this.k, this.Jt), this.Ye = new Ti(), this.window && this.window.localStorage ? this.Xe = this.window.localStorage : (this.Xe = null, u === false && M2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.Ze().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new Q2(j.FAILED_PRECONDITION, sr);
      return this.tn(), this.en(), this.nn(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.He.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Be = new nt(t2, this.Fe);
    }).then(() => {
      this.Ue = true;
    }).catch((t2) => (this.ze && this.ze.close(), Promise.reject(t2)));
  }
  sn(t2) {
    return this.We = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.ze.xt(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Me.enqueueAndForget(async () => {
      this.started && await this.Ze();
    }));
  }
  Ze() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => or(t2).put(new qs(this.clientId, Date.now(), this.networkEnabled, this.inForeground)).next(() => {
      if (this.isPrimary)
        return this.rn(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Me.enqueueRetryable(() => this.We(false)));
        });
    }).next(() => this.on(t2)).next((e) => this.isPrimary && !e ? this.cn(t2).next(() => false) : !!e && this.an(t2).next(() => true))).catch((t2) => {
      if (Zs(t2))
        return O2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return O2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Me.enqueueRetryable(() => this.We(t2)), this.isPrimary = t2;
    });
  }
  rn(t2) {
    return rr(t2).get(Ds.key).next((t3) => zs.resolve(this.un(t3)));
  }
  hn(t2) {
    return or(t2).delete(this.clientId);
  }
  async ln() {
    if (this.isPrimary && !this.fn(this.Qe, 18e5)) {
      this.Qe = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = ri(t3, qs.store);
        return e.Bt().next((t4) => {
          const n = this.dn(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return zs.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.Xe)
        for (const e of t2)
          this.Xe.removeItem(this.wn(e.clientId));
    }
  }
  nn() {
    this.je = this.Me.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.Ze().then(() => this.ln()).then(() => this.nn()));
  }
  un(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  on(t2) {
    if (this.Le)
      return zs.resolve(true);
    return rr(t2).get(Ds.key).next((e) => {
      if (e !== null && this.fn(e.leaseTimestampMs, 5e3) && !this._n(e.ownerId)) {
        if (this.un(e) && this.networkEnabled)
          return true;
        if (!this.un(e)) {
          if (!e.allowTabSynchronization)
            throw new Q2(j.FAILED_PRECONDITION, sr);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || or(t2).Bt().next((t3) => this.dn(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && O2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.Ue = false, this.mn(), this.je && (this.je.cancel(), this.je = null), this.gn(), this.yn(), await this.ze.runTransaction("shutdown", "readwrite", [Ds.store, qs.store], (t2) => {
      const e = new ii(t2, nt.I);
      return this.cn(e).next(() => this.hn(e));
    }), this.ze.close(), this.pn();
  }
  dn(t2, e) {
    return t2.filter((t3) => this.fn(t3.updateTimeMs, e) && !this._n(t3.clientId));
  }
  Tn() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => or(t2).Bt().next((t3) => this.dn(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.Ue;
  }
  getMutationQueue(t2) {
    return Ci.Xt(t2, this.k, this.Jt, this.referenceDelegate);
  }
  getTargetCache() {
    return this.He;
  }
  getRemoteDocumentCache() {
    return this.Je;
  }
  getIndexManager() {
    return this.Jt;
  }
  getBundleCache() {
    return this.Ye;
  }
  runTransaction(t2, e, n) {
    O2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite";
    let i;
    return this.ze.runTransaction(t2, s, Qs, (s2) => (i = new ii(s2, this.Be ? this.Be.next() : nt.I), e === "readwrite-primary" ? this.rn(i).next((t3) => !!t3 || this.on(i)).next((e2) => {
      if (!e2)
        throw M2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Me.enqueueRetryable(() => this.We(false)), new Q2(j.FAILED_PRECONDITION, Ws);
      return n(i);
    }).next((t3) => this.an(i).next(() => t3)) : this.En(i).next(() => n(i)))).then((t3) => (i.raiseOnCommittedEvent(), t3));
  }
  En(t2) {
    return rr(t2).get(Ds.key).next((t3) => {
      if (t3 !== null && this.fn(t3.leaseTimestampMs, 5e3) && !this._n(t3.ownerId) && !this.un(t3) && !(this.Le || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new Q2(j.FAILED_PRECONDITION, sr);
    });
  }
  an(t2) {
    const e = new Ds(this.clientId, this.allowTabSynchronization, Date.now());
    return rr(t2).put(Ds.key, e);
  }
  static Pt() {
    return Js.Pt();
  }
  cn(t2) {
    const e = rr(t2);
    return e.get(Ds.key).next((t3) => this.un(t3) ? (O2("IndexedDbPersistence", "Releasing primary lease."), e.delete(Ds.key)) : zs.resolve());
  }
  fn(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (M2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  tn() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.Ke = () => {
      this.Me.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.Ze()));
    }, this.document.addEventListener("visibilitychange", this.Ke), this.inForeground = this.document.visibilityState === "visible");
  }
  gn() {
    this.Ke && (this.document.removeEventListener("visibilitychange", this.Ke), this.Ke = null);
  }
  en() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.qe = () => {
      this.mn(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.Me.enterRestrictedMode(true), this.Me.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.qe));
  }
  yn() {
    this.qe && (this.window.removeEventListener("pagehide", this.qe), this.qe = null);
  }
  _n(t2) {
    var e;
    try {
      const n = ((e = this.Xe) === null || e === void 0 ? void 0 : e.getItem(this.wn(t2))) !== null;
      return O2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return M2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  mn() {
    if (this.Xe)
      try {
        this.Xe.setItem(this.wn(this.clientId), String(Date.now()));
      } catch (t2) {
        M2("Failed to set zombie client id.", t2);
      }
  }
  pn() {
    if (this.Xe)
      try {
        this.Xe.removeItem(this.wn(this.clientId));
      } catch (t2) {
      }
  }
  wn(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function rr(t2) {
  return ri(t2, Ds.store);
}
function or(t2) {
  return ri(t2, qs.store);
}
function cr(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var ar = class {
  constructor(t2, e) {
    this.progress = t2, this.In = e;
  }
};
var ur = class {
  constructor(t2, e, n) {
    this.Je = t2, this.An = e, this.Jt = n;
  }
  Rn(t2, e) {
    return this.An.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.bn(t2, e, n));
  }
  bn(t2, e, n) {
    return this.Je.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  Pn(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  vn(t2, e) {
    return this.Je.getEntries(t2, e).next((e2) => this.Vn(t2, e2).next(() => e2));
  }
  Vn(t2, e) {
    return this.An.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.Pn(e, t3));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return Dt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Sn(t2, e.path) : Ae(e) ? this.Dn(t2, e, n) : this.Cn(t2, e, n);
  }
  Sn(t2, e) {
    return this.Rn(t2, new Dt(e)).next((t3) => {
      let e2 = Pn();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  Dn(t2, e, n) {
    const s = e.collectionGroup;
    let i = Pn();
    return this.Jt.getCollectionParents(t2, s).next((r) => zs.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new me(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.Cn(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  Cn(t2, e, n) {
    let s, i;
    return this.Je.getDocumentsMatchingQuery(t2, e, n).next((n2) => (s = n2, this.An.getAllMutationBatchesAffectingQuery(t2, e))).next((e2) => (i = e2, this.Nn(t2, i, s).next((t3) => {
      s = t3;
      for (const t4 of i)
        for (const e3 of t4.mutations) {
          const n2 = e3.key;
          let i2 = s.get(n2);
          i2 == null && (i2 = Gt.newInvalidDocument(n2), s = s.insert(n2, i2)), en(e3, i2, t4.localWriteTime), i2.isFoundDocument() || (s = s.remove(n2));
        }
    }))).next(() => (s.forEach((t3, n2) => {
      De(e, n2) || (s = s.remove(t3));
    }), s));
  }
  Nn(t2, e, n) {
    let s = Dn();
    for (const t3 of e)
      for (const e2 of t3.mutations)
        e2 instanceof cn && n.get(e2.key) === null && (s = s.add(e2.key));
    let i = n;
    return this.Je.getEntries(t2, s).next((t3) => (t3.forEach((t4, e2) => {
      e2.isFoundDocument() && (i = i.insert(t4, e2));
    }), i));
  }
};
var hr = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.kn = n, this.xn = s;
  }
  static $n(t2, e) {
    let n = Dn(), s = Dn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new hr(t2, e.fromCache, n, s);
  }
};
var lr = class {
  On(t2) {
    this.Mn = t2;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(ut.min()) ? this.Fn(t2, e) : this.Mn.vn(t2, s).next((i) => {
      const r = this.Ln(e, i);
      return (pe(e) || Te(e)) && this.Bn(e.limitType, r, s, n) ? this.Fn(t2, e) : (x2() <= LogLevel.DEBUG && O2("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), Se(e)), this.Mn.getDocumentsMatchingQuery(t2, e, n).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  Ln(t2, e) {
    let n = new En(Ce(t2));
    return e.forEach((e2, s) => {
      De(t2, s) && (n = n.add(s));
    }), n;
  }
  Bn(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Fn(t2, e) {
    return x2() <= LogLevel.DEBUG && O2("QueryEngine", "Using full collection scan to execute query:", Se(e)), this.Mn.getDocumentsMatchingQuery(t2, e, ut.min());
  }
};
var fr = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Un = e, this.k = s, this.qn = new yn(rt), this.Kn = new zi((t3) => Jt(t3), Xt), this.jn = ut.min(), this.An = t2.getMutationQueue(n), this.Qn = t2.getRemoteDocumentCache(), this.He = t2.getTargetCache(), this.Wn = new ur(this.Qn, this.An, this.persistence.getIndexManager()), this.Ye = t2.getBundleCache(), this.Un.On(this.Wn);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.qn));
  }
};
function dr(t2, e, n, s) {
  return new fr(t2, e, n, s);
}
async function wr(t2, e) {
  const n = K2(t2);
  let s = n.An, i = n.Wn;
  const r = await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let r2;
    return n.An.getAllMutationBatches(t3).next((o) => (r2 = o, s = n.persistence.getMutationQueue(e), i = new ur(n.Qn, s, n.persistence.getIndexManager()), s.getAllMutationBatches(t3))).next((e2) => {
      const n2 = [], s2 = [];
      let o = Dn();
      for (const t4 of r2) {
        n2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        s2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return i.vn(t3, o).next((t4) => ({
        Gn: t4,
        removedBatchIds: n2,
        addedBatchIds: s2
      }));
    });
  });
  return n.An = s, n.Wn = i, n.Un.On(n.Wn), r;
}
function _r(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.Qn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = zs.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          U2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && s2.addEntry(e3, n2.commitVersion));
        });
      }), o.next(() => t4.An.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.An.performConsistencyCheck(t3)).next(() => n.Wn.vn(t3, s));
  });
}
function mr(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.He.getLastRemoteSnapshotVersion(t3));
}
function gr(t2, e) {
  const n = K2(t2), s = e.snapshotVersion;
  let i = n.qn;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.Qn.newChangeBuffer({
      trackRemovals: true
    });
    i = n.qn;
    const o = [];
    e.targetChanges.forEach((r2, c2) => {
      const a = i.get(c2);
      if (!a)
        return;
      o.push(n.He.removeMatchingKeys(t3, r2.removedDocuments, c2).next(() => n.He.addMatchingKeys(t3, r2.addedDocuments, c2)));
      let u = a.withSequenceNumber(t3.currentSequenceNumber);
      e.targetMismatches.has(c2) ? u = u.withResumeToken(pt.EMPTY_BYTE_STRING, ut.min()).withLastLimboFreeSnapshotVersion(ut.min()) : r2.resumeToken.approximateByteSize() > 0 && (u = u.withResumeToken(r2.resumeToken, s)), i = i.insert(c2, u), function(t4, e2, n2) {
        if (t4.resumeToken.approximateByteSize() === 0)
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(a, u, r2) && o.push(n.He.updateTargetData(t3, u));
    });
    let c = Rn();
    if (e.documentUpdates.forEach((s2, i2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(yr(t3, r, e.documentUpdates, s, void 0).next((t4) => {
      c = t4;
    })), !s.isEqual(ut.min())) {
      const e2 = n.He.getLastRemoteSnapshotVersion(t3).next((e3) => n.He.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return zs.waitFor(o).next(() => r.apply(t3)).next(() => n.Wn.Vn(t3, c)).next(() => c);
  }).then((t3) => (n.qn = i, t3));
}
function yr(t2, e, n, s, i) {
  let r = Dn();
  return n.forEach((t3) => r = r.add(t3)), e.getEntries(t2, r).next((t3) => {
    let r2 = Rn();
    return n.forEach((n2, o) => {
      const c = t3.get(n2), a = (i == null ? void 0 : i.get(n2)) || s;
      o.isNoDocument() && o.version.isEqual(ut.min()) ? (e.removeEntry(n2, a), r2 = r2.insert(n2, o)) : !c.isValidDocument() || o.version.compareTo(c.version) > 0 || o.version.compareTo(c.version) === 0 && c.hasPendingWrites ? (e.addEntry(o, a), r2 = r2.insert(n2, o)) : O2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", c.version, " Watch version:", o.version);
    }), r2;
  });
}
function pr(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.An.getNextMutationBatchAfterBatchId(t3, e)));
}
function Tr(t2, e) {
  const n = K2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.He.getTargetData(t3, e).next((i) => i ? (s = i, zs.resolve(s)) : n.He.allocateTargetId(t3).next((i2) => (s = new ai(e, i2, 0, t3.currentSequenceNumber), n.He.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.qn.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.qn = n.qn.insert(t3.targetId, t3), n.Kn.set(e, t3.targetId)), t3;
  });
}
async function Er(t2, e, n) {
  const s = K2(t2), i = s.qn.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Zs(t3))
      throw t3;
    O2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.qn = s.qn.remove(e), s.Kn.delete(i.target);
}
function Ir(t2, e, n) {
  const s = K2(t2);
  let i = ut.min(), r = Dn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = K2(t4), i2 = s2.Kn.get(n2);
    return i2 !== void 0 ? zs.resolve(s2.qn.get(i2)) : s2.He.getTargetData(e2, n2);
  }(s, t3, be(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.He.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Un.getDocumentsMatchingQuery(t3, e, n ? i : ut.min(), n ? r : Dn())).next((t4) => ({
    documents: t4,
    zn: r
  })));
}
function Ar(t2, e) {
  const n = K2(t2), s = K2(n.He), i = n.qn.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Et(t3, e).next((t4) => t4 ? t4.target : null));
}
function Rr(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n) {
    const s = K2(t4);
    let i = Rn(), r = fi(n);
    const o = Zi(e2), c = IDBKeyRange.lowerBound(r, true);
    return o.jt({
      index: Os.readTimeIndex,
      range: c
    }, (t5, e3) => {
      const n2 = hi(s.k, e3);
      i = i.insert(n2.key, n2), r = e3.readTime;
    }).next(() => ({
      In: i,
      readTime: di(r)
    }));
  }(e.Qn, t3, e.jn)).then(({ In: t3, readTime: n }) => (e.jn = n, t3));
}
async function br(t2) {
  const e = K2(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = Zi(t4);
    let n = ut.min();
    return e2.jt({
      index: Os.readTimeIndex,
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n = di(e3.readTime)), s.done();
    }).next(() => n);
  }(t3)).then((t3) => {
    e.jn = t3;
  });
}
async function Pr(t2, e, n, s) {
  const i = K2(t2);
  let r = Dn(), o = Rn(), c = Vn();
  for (const t3 of n) {
    const n2 = e.Hn(t3.metadata.name);
    t3.document && (r = r.add(n2)), o = o.insert(n2, e.Jn(t3)), c = c.insert(n2, e.Yn(t3.metadata.readTime));
  }
  const a = i.Qn.newChangeBuffer({
    trackRemovals: true
  }), u = await Tr(i, function(t3) {
    return be(ye(wt.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => yr(t3, a, o, ut.min(), c).next((e2) => (a.apply(t3), e2)).next((e2) => i.He.removeMatchingKeysForTargetId(t3, u.targetId).next(() => i.He.addMatchingKeys(t3, r, u.targetId)).next(() => i.Wn.Vn(t3, e2)).next(() => e2)));
}
async function vr(t2, e, n = Dn()) {
  const s = await Tr(t2, be(pi(e.bundledQuery))), i = K2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = zn(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Ye.saveNamedQuery(t3, e);
    const o = s.withResumeToken(pt.EMPTY_BYTE_STRING, r);
    return i.qn = i.qn.insert(o.targetId, o), i.He.updateTargetData(t3, o).next(() => i.He.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.He.addMatchingKeys(t3, n, s.targetId)).next(() => i.Ye.saveNamedQuery(t3, e));
  });
}
var Vr = class {
  constructor(t2) {
    this.k = t2, this.Xn = new Map(), this.Zn = new Map();
  }
  getBundleMetadata(t2, e) {
    return zs.resolve(this.Xn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Xn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: zn(n.createTime)
    }), zs.resolve();
  }
  getNamedQuery(t2, e) {
    return zs.resolve(this.Zn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.Zn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: pi(t3.bundledQuery),
        readTime: zn(t3.readTime)
      };
    }(e)), zs.resolve();
  }
};
var Sr = class {
  constructor() {
    this.ts = new En(Dr.es), this.ns = new En(Dr.ss);
  }
  isEmpty() {
    return this.ts.isEmpty();
  }
  addReference(t2, e) {
    const n = new Dr(t2, e);
    this.ts = this.ts.add(n), this.ns = this.ns.add(n);
  }
  rs(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.os(new Dr(t2, e));
  }
  cs(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  us(t2) {
    const e = new Dt(new wt([])), n = new Dr(e, t2), s = new Dr(e, t2 + 1), i = [];
    return this.ns.forEachInRange([n, s], (t3) => {
      this.os(t3), i.push(t3.key);
    }), i;
  }
  hs() {
    this.ts.forEach((t2) => this.os(t2));
  }
  os(t2) {
    this.ts = this.ts.delete(t2), this.ns = this.ns.delete(t2);
  }
  ls(t2) {
    const e = new Dt(new wt([])), n = new Dr(e, t2), s = new Dr(e, t2 + 1);
    let i = Dn();
    return this.ns.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new Dr(t2, 0), n = this.ts.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var Dr = class {
  constructor(t2, e) {
    this.key = t2, this.fs = e;
  }
  static es(t2, e) {
    return Dt.comparator(t2.key, e.key) || rt(t2.fs, e.fs);
  }
  static ss(t2, e) {
    return rt(t2.fs, e.fs) || Dt.comparator(t2.key, e.key);
  }
};
var Cr = class {
  constructor(t2, e) {
    this.Jt = t2, this.referenceDelegate = e, this.An = [], this.ds = 1, this.ws = new En(Dr.es);
  }
  checkEmpty(t2) {
    return zs.resolve(this.An.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.ds;
    this.ds++, this.An.length > 0 && this.An[this.An.length - 1];
    const r = new oi(i, e, n, s);
    this.An.push(r);
    for (const e2 of s)
      this.ws = this.ws.add(new Dr(e2.key, i)), this.Jt.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return zs.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return zs.resolve(this._s(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.gs(n), i = s < 0 ? 0 : s;
    return zs.resolve(this.An.length > i ? this.An[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return zs.resolve(this.An.length === 0 ? -1 : this.ds - 1);
  }
  getAllMutationBatches(t2) {
    return zs.resolve(this.An.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new Dr(e, 0), s = new Dr(e, Number.POSITIVE_INFINITY), i = [];
    return this.ws.forEachInRange([n, s], (t3) => {
      const e2 = this._s(t3.fs);
      i.push(e2);
    }), zs.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new En(rt);
    return e.forEach((t3) => {
      const e2 = new Dr(t3, 0), s = new Dr(t3, Number.POSITIVE_INFINITY);
      this.ws.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.fs);
      });
    }), zs.resolve(this.ys(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    Dt.isDocumentKey(i) || (i = i.child(""));
    const r = new Dr(new Dt(i), 0);
    let o = new En(rt);
    return this.ws.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.fs)), true);
    }, r), zs.resolve(this.ys(o));
  }
  ys(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this._s(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    U2(this.ps(e.batchId, "removed") === 0), this.An.shift();
    let n = this.ws;
    return zs.forEach(e.mutations, (s) => {
      const i = new Dr(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.ws = n;
    });
  }
  ee(t2) {
  }
  containsKey(t2, e) {
    const n = new Dr(e, 0), s = this.ws.firstAfterOrEqual(n);
    return zs.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.An.length, zs.resolve();
  }
  ps(t2, e) {
    return this.gs(t2);
  }
  gs(t2) {
    if (this.An.length === 0)
      return 0;
    return t2 - this.An[0].batchId;
  }
  _s(t2) {
    const e = this.gs(t2);
    if (e < 0 || e >= this.An.length)
      return null;
    return this.An[e];
  }
};
var Nr = class {
  constructor(t2, e) {
    this.Jt = t2, this.Ts = e, this.docs = new yn(Dt.comparator), this.size = 0;
  }
  addEntry(t2, e, n) {
    const s = e.key, i = this.docs.get(s), r = i ? i.size : 0, o = this.Ts(e);
    return this.docs = this.docs.insert(s, {
      document: e.mutableCopy(),
      size: o,
      readTime: n
    }), this.size += o - r, this.Jt.addToCollectionParentIndex(t2, s.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return zs.resolve(n ? n.document.mutableCopy() : Gt.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = Rn();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.mutableCopy() : Gt.newInvalidDocument(t3));
    }), zs.resolve(n);
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = Rn();
    const i = new Dt(e.path.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2, readTime: o } } = r.getNext();
      if (!e.path.isPrefixOf(t3.path))
        break;
      o.compareTo(n) <= 0 || De(e, i2) && (s = s.insert(i2.key, i2.mutableCopy()));
    }
    return zs.resolve(s);
  }
  Es(t2, e) {
    return zs.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new kr(this);
  }
  getSize(t2) {
    return zs.resolve(this.size);
  }
};
var kr = class extends Hi {
  constructor(t2) {
    super(), this.De = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.document.isValidDocument() ? e.push(this.De.addEntry(t2, s.document, this.getReadTime(n))) : this.De.removeEntry(n);
    }), zs.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.De.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.De.getEntries(t2, e);
  }
};
var xr = class {
  constructor(t2) {
    this.persistence = t2, this.Is = new zi((t3) => Jt(t3), Xt), this.lastRemoteSnapshotVersion = ut.min(), this.highestTargetId = 0, this.As = 0, this.Rs = new Sr(), this.targetCount = 0, this.bs = Oi.ie();
  }
  forEachTarget(t2, e) {
    return this.Is.forEach((t3, n) => e(n)), zs.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return zs.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return zs.resolve(this.As);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.bs.next(), zs.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.As && (this.As = e), zs.resolve();
  }
  ae(t2) {
    this.Is.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.bs = new Oi(e), this.highestTargetId = e), t2.sequenceNumber > this.As && (this.As = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.ae(e), this.targetCount += 1, zs.resolve();
  }
  updateTargetData(t2, e) {
    return this.ae(e), zs.resolve();
  }
  removeTargetData(t2, e) {
    return this.Is.delete(e.target), this.Rs.us(e.targetId), this.targetCount -= 1, zs.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Is.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Is.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), zs.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return zs.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Is.get(e) || null;
    return zs.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.Rs.rs(e, n), zs.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.Rs.cs(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), zs.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.Rs.us(e), zs.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.Rs.ls(e);
    return zs.resolve(n);
  }
  containsKey(t2, e) {
    return zs.resolve(this.Rs.containsKey(e));
  }
};
var $r = class {
  constructor(t2, e) {
    this.Ps = {}, this.Be = new nt(0), this.Ue = false, this.Ue = true, this.referenceDelegate = t2(this), this.He = new xr(this);
    this.Jt = new Ai(), this.Je = function(t3, e2) {
      return new Nr(t3, e2);
    }(this.Jt, (t3) => this.referenceDelegate.vs(t3)), this.k = new ui(e), this.Ye = new Vr(this.k);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Ue = false, Promise.resolve();
  }
  get started() {
    return this.Ue;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager() {
    return this.Jt;
  }
  getMutationQueue(t2) {
    let e = this.Ps[t2.toKey()];
    return e || (e = new Cr(this.Jt, this.referenceDelegate), this.Ps[t2.toKey()] = e), e;
  }
  getTargetCache() {
    return this.He;
  }
  getRemoteDocumentCache() {
    return this.Je;
  }
  getBundleCache() {
    return this.Ye;
  }
  runTransaction(t2, e, n) {
    O2("MemoryPersistence", "Starting transaction:", t2);
    const s = new Or(this.Be.next());
    return this.referenceDelegate.Vs(), n(s).next((t3) => this.referenceDelegate.Ss(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Ds(t2, e) {
    return zs.or(Object.values(this.Ps).map((n) => () => n.containsKey(t2, e)));
  }
};
var Or = class extends Gs {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var Mr = class {
  constructor(t2) {
    this.persistence = t2, this.Cs = new Sr(), this.Ns = null;
  }
  static ks(t2) {
    return new Mr(t2);
  }
  get xs() {
    if (this.Ns)
      return this.Ns;
    throw B2();
  }
  addReference(t2, e, n) {
    return this.Cs.addReference(n, e), this.xs.delete(n.toString()), zs.resolve();
  }
  removeReference(t2, e, n) {
    return this.Cs.removeReference(n, e), this.xs.add(n.toString()), zs.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.xs.add(e.toString()), zs.resolve();
  }
  removeTarget(t2, e) {
    this.Cs.us(e.targetId).forEach((t3) => this.xs.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.xs.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  Vs() {
    this.Ns = new Set();
  }
  Ss(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return zs.forEach(this.xs, (n) => {
      const s = Dt.fromPath(n);
      return this.$s(t2, s).next((t3) => {
        t3 || e.removeEntry(s);
      });
    }).next(() => (this.Ns = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.$s(t2, e).next((t3) => {
      t3 ? this.xs.delete(e.toString()) : this.xs.add(e.toString());
    });
  }
  vs(t2) {
    return 0;
  }
  $s(t2, e) {
    return zs.or([() => zs.resolve(this.Cs.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ds(t2, e)]);
  }
};
function Fr(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function Lr(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function Br(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var Ur = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Os(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new Q2(s.error.code, s.error.message))), r ? new Ur(t2, e, s.state, i) : (M2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Ms() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var qr = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Os(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new Q2(n.error.code, n.error.message))), i ? new qr(t2, n.state, s) : (M2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Ms() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Kr = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Os(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = Nn();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = St(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Kr(t2, i) : (M2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var jr = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Os(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new jr(e.clientId, e.onlineState) : (M2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var Qr = class {
  constructor() {
    this.activeTargetIds = Nn();
  }
  Fs(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Ls(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Ms() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Wr = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Me = e, this.persistenceKey = n, this.Bs = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.Us = this.qs.bind(this), this.Ks = new yn(rt), this.started = false, this.js = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.Qs = Fr(this.persistenceKey, this.Bs), this.Ws = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.Ks = this.Ks.insert(this.Bs, new Qr()), this.Gs = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.zs = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.Hs = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.Js = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.Ys = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.Us);
  }
  static Pt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.Tn();
    for (const e2 of t2) {
      if (e2 === this.Bs)
        continue;
      const t3 = this.getItem(Fr(this.persistenceKey, e2));
      if (t3) {
        const n = Kr.Os(e2, t3);
        n && (this.Ks = this.Ks.insert(n.clientId, n));
      }
    }
    this.Xs();
    const e = this.storage.getItem(this.Js);
    if (e) {
      const t3 = this.Zs(e);
      t3 && this.ti(t3);
    }
    for (const t3 of this.js)
      this.qs(t3);
    this.js = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.Ws, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.ei(this.Ks);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.Ks.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.ni(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.ni(t2, e, n), this.si(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(Br(this.persistenceKey, t2));
      if (n) {
        const s = qr.Os(t2, n);
        s && (e = s.state);
      }
    }
    return this.ii.Fs(t2), this.Xs(), e;
  }
  removeLocalQueryTarget(t2) {
    this.ii.Ls(t2), this.Xs();
  }
  isLocalQueryTarget(t2) {
    return this.ii.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(Br(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.ri(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.si(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.oi(t2);
  }
  notifyBundleLoaded() {
    this.ci();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.Us), this.removeItem(this.Qs), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return O2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    O2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    O2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  qs(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (O2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.Qs)
        return void M2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Me.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.Gs.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.ai(e.key);
                return this.ui(t3, null);
              }
              {
                const t3 = this.hi(e.key, e.newValue);
                if (t3)
                  return this.ui(t3.clientId, t3);
              }
            } else if (this.zs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.li(e.key, e.newValue);
                if (t3)
                  return this.fi(t3);
              }
            } else if (this.Hs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.di(e.key, e.newValue);
                if (t3)
                  return this.wi(t3);
              }
            } else if (e.key === this.Js) {
              if (e.newValue !== null) {
                const t3 = this.Zs(e.newValue);
                if (t3)
                  return this.ti(t3);
              }
            } else if (e.key === this.Ws) {
              const t3 = function(t4) {
                let e2 = nt.I;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    U2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    M2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== nt.I && this.sequenceNumberHandler(t3);
            } else if (e.key === this.Ys)
              return this.syncEngine._i();
          }
        } else
          this.js.push(e);
      });
    }
  }
  get ii() {
    return this.Ks.get(this.Bs);
  }
  Xs() {
    this.setItem(this.Qs, this.ii.Ms());
  }
  ni(t2, e, n) {
    const s = new Ur(this.currentUser, t2, e, n), i = Lr(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Ms());
  }
  si(t2) {
    const e = Lr(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  oi(t2) {
    const e = {
      clientId: this.Bs,
      onlineState: t2
    };
    this.storage.setItem(this.Js, JSON.stringify(e));
  }
  ri(t2, e, n) {
    const s = Br(this.persistenceKey, t2), i = new qr(t2, e, n);
    this.setItem(s, i.Ms());
  }
  ci() {
    this.setItem(this.Ys, "value-not-used");
  }
  ai(t2) {
    const e = this.Gs.exec(t2);
    return e ? e[1] : null;
  }
  hi(t2, e) {
    const n = this.ai(t2);
    return Kr.Os(n, e);
  }
  li(t2, e) {
    const n = this.zs.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return Ur.Os(new C2(i), s, e);
  }
  di(t2, e) {
    const n = this.Hs.exec(t2), s = Number(n[1]);
    return qr.Os(s, e);
  }
  Zs(t2) {
    return jr.Os(t2);
  }
  async fi(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.mi(t2.batchId, t2.state, t2.error);
    O2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  wi(t2) {
    return this.syncEngine.gi(t2.targetId, t2.state, t2.error);
  }
  ui(t2, e) {
    const n = e ? this.Ks.insert(t2, e) : this.Ks.remove(t2), s = this.ei(this.Ks), i = this.ei(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.yi(r, o).then(() => {
      this.Ks = n;
    });
  }
  ti(t2) {
    this.Ks.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  ei(t2) {
    let e = Nn();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var Gr = class {
  constructor() {
    this.pi = new Qr(), this.Ti = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.pi.Fs(t2), this.Ti[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.Ti[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.pi.Ls(t2);
  }
  isLocalQueryTarget(t2) {
    return this.pi.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.Ti[t2];
  }
  getAllActiveQueryTargets() {
    return this.pi.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.pi.activeTargetIds.has(t2);
  }
  start() {
    return this.pi = new Qr(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
};
var zr = class {
  Ei(t2) {
  }
  shutdown() {
  }
};
var Hr = class {
  constructor() {
    this.Ii = () => this.Ai(), this.Ri = () => this.bi(), this.Pi = [], this.vi();
  }
  Ei(t2) {
    this.Pi.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Ii), window.removeEventListener("offline", this.Ri);
  }
  vi() {
    window.addEventListener("online", this.Ii), window.addEventListener("offline", this.Ri);
  }
  Ai() {
    O2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Pi)
      t2(0);
  }
  bi() {
    O2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Pi)
      t2(1);
  }
  static Pt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var Jr = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Yr = class {
  constructor(t2) {
    this.Vi = t2.Vi, this.Si = t2.Si;
  }
  Di(t2) {
    this.Ci = t2;
  }
  Ni(t2) {
    this.ki = t2;
  }
  onMessage(t2) {
    this.xi = t2;
  }
  close() {
    this.Si();
  }
  send(t2) {
    this.Vi(t2);
  }
  $i() {
    this.Ci();
  }
  Oi(t2) {
    this.ki(t2);
  }
  Mi(t2) {
    this.xi(t2);
  }
};
var Xr = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.Fi = e + "://" + t2.host, this.Li = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  Bi(t2, e, n, s, i) {
    const r = this.Ui(t2, e);
    O2("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.qi(o, s, i), this.Ki(t2, r, o, n).then((t3) => (O2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw F2("RestConnection", `${t2} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  ji(t2, e, n, s, i) {
    return this.Bi(t2, e, n, s, i);
  }
  qi(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + N2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  Ui(t2, e) {
    const n = Jr[t2];
    return `${this.Fi}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  Ki(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              O2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              O2("Connection", 'RPC "' + t2 + '" timed out'), r(new Q2(j.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (O2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(j).indexOf(e4) >= 0 ? e4 : j.UNKNOWN;
                  }(t3.status);
                  r(new Q2(e3, t3.message));
                } else
                  r(new Q2(j.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new Q2(j.UNAVAILABLE, "Connection failed."));
              break;
            default:
              B2();
          }
        } finally {
          O2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const c = JSON.stringify(s);
      o.send(e, "POST", c, n, 15);
    });
  }
  Qi(t2, e, n) {
    const s = [this.Fi, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.qi(o.initMessageHeaders, e, n), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o.httpHeadersOverwriteParam = "$httpHeaders");
    const c = s.join("");
    O2("Connection", "Creating WebChannel: " + c, o);
    const a = i.createWebChannel(c, o);
    let u = false, h = false;
    const l2 = new Yr({
      Vi: (t3) => {
        h ? O2("Connection", "Not sending because WebChannel is closed:", t3) : (u || (O2("Connection", "Opening WebChannel transport."), a.open(), u = true), O2("Connection", "WebChannel sending:", t3), a.send(t3));
      },
      Si: () => a.close()
    }), y2 = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return y2(a, WebChannel.EventType.OPEN, () => {
      h || O2("Connection", "WebChannel transport opened.");
    }), y2(a, WebChannel.EventType.CLOSE, () => {
      h || (h = true, O2("Connection", "WebChannel transport closed"), l2.Oi());
    }), y2(a, WebChannel.EventType.ERROR, (t3) => {
      h || (h = true, F2("Connection", "WebChannel transport errored:", t3), l2.Oi(new Q2(j.UNAVAILABLE, "The operation could not be completed")));
    }), y2(a, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!h) {
        const n2 = t3.data[0];
        U2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          O2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = wn[t5];
            if (e4 !== void 0)
              return gn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = j.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), h = true, l2.Oi(new Q2(e3, n3)), a.close();
        } else
          O2("Connection", "WebChannel received:", n2), l2.Mi(n2);
      }
    }), y2(r, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? O2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && O2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l2.$i();
    }, 0), l2;
  }
};
function Zr() {
  return typeof window != "undefined" ? window : null;
}
function to() {
  return typeof document != "undefined" ? document : null;
}
function eo(t2) {
  return new jn(t2, true);
}
var no = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Me = t2, this.timerId = e, this.Wi = n, this.Gi = s, this.zi = i, this.Hi = 0, this.Ji = null, this.Yi = Date.now(), this.reset();
  }
  reset() {
    this.Hi = 0;
  }
  Xi() {
    this.Hi = this.zi;
  }
  Zi(t2) {
    this.cancel();
    const e = Math.floor(this.Hi + this.tr()), n = Math.max(0, Date.now() - this.Yi), s = Math.max(0, e - n);
    s > 0 && O2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.Hi} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Ji = this.Me.enqueueAfterDelay(this.timerId, s, () => (this.Yi = Date.now(), t2())), this.Hi *= this.Gi, this.Hi < this.Wi && (this.Hi = this.Wi), this.Hi > this.zi && (this.Hi = this.zi);
  }
  er() {
    this.Ji !== null && (this.Ji.skipDelay(), this.Ji = null);
  }
  cancel() {
    this.Ji !== null && (this.Ji.cancel(), this.Ji = null);
  }
  tr() {
    return (Math.random() - 0.5) * this.Hi;
  }
};
var so = class {
  constructor(t2, e, n, s, i, r, o, c) {
    this.Me = t2, this.nr = n, this.sr = s, this.ir = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = c, this.state = 0, this.rr = 0, this.cr = null, this.ar = null, this.stream = null, this.ur = new no(t2, e);
  }
  hr() {
    return this.state === 1 || this.state === 5 || this.lr();
  }
  lr() {
    return this.state === 2 || this.state === 3;
  }
  start() {
    this.state !== 4 ? this.auth() : this.dr();
  }
  async stop() {
    this.hr() && await this.close(0);
  }
  wr() {
    this.state = 0, this.ur.reset();
  }
  _r() {
    this.lr() && this.cr === null && (this.cr = this.Me.enqueueAfterDelay(this.nr, 6e4, () => this.mr()));
  }
  gr(t2) {
    this.yr(), this.stream.send(t2);
  }
  async mr() {
    if (this.lr())
      return this.close(0);
  }
  yr() {
    this.cr && (this.cr.cancel(), this.cr = null);
  }
  pr() {
    this.ar && (this.ar.cancel(), this.ar = null);
  }
  async close(t2, e) {
    this.yr(), this.pr(), this.ur.cancel(), this.rr++, t2 !== 4 ? this.ur.reset() : e && e.code === j.RESOURCE_EXHAUSTED ? (M2(e.toString()), M2("Using maximum backoff delay to prevent overloading the backend."), this.ur.Xi()) : e && e.code === j.UNAUTHENTICATED && this.state !== 3 && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), this.stream !== null && (this.Tr(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Ni(e);
  }
  Tr() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Er(this.rr), e = this.rr;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.rr === e && this.Ir(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new Q2(j.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.Ar(t3);
      });
    });
  }
  Ir(t2, e) {
    const n = this.Er(this.rr);
    this.stream = this.Rr(t2, e), this.stream.Di(() => {
      n(() => (this.state = 2, this.ar = this.Me.enqueueAfterDelay(this.sr, 1e4, () => (this.lr() && (this.state = 3), Promise.resolve())), this.listener.Di()));
    }), this.stream.Ni((t3) => {
      n(() => this.Ar(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  dr() {
    this.state = 5, this.ur.Zi(async () => {
      this.state = 0, this.start();
    });
  }
  Ar(t2) {
    return O2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Er(t2) {
    return (e) => {
      this.Me.enqueueAndForget(() => this.rr === t2 ? e() : (O2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var io = class extends so {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.k = i;
  }
  Rr(t2, e) {
    return this.ir.Qi("Listen", t2, e);
  }
  onMessage(t2) {
    this.ur.reset();
    const e = os(this.k, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return ut.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? ut.min() : e2.readTime ? zn(e2.readTime) : ut.min();
    }(t2);
    return this.listener.br(e, n);
  }
  Pr(t2) {
    const e = {};
    e.database = es(this.k), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = Zt(s) ? {
        documents: hs(t3, s)
      } : {
        query: ls(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Wn(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(ut.min()) > 0 && (n2.readTime = Qn(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.k, t2);
    const n = ds(this.k, t2);
    n && (e.labels = n), this.gr(e);
  }
  vr(t2) {
    const e = {};
    e.database = es(this.k), e.removeTarget = t2, this.gr(e);
  }
};
var ro = class extends so {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.k = i, this.Vr = false;
  }
  get Sr() {
    return this.Vr;
  }
  start() {
    this.Vr = false, this.lastStreamToken = void 0, super.start();
  }
  Tr() {
    this.Vr && this.Dr([]);
  }
  Rr(t2, e) {
    return this.ir.Qi("Write", t2, e);
  }
  onMessage(t2) {
    if (U2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Vr) {
      this.ur.reset();
      const e = us(t2.writeResults, t2.commitTime), n = zn(t2.commitTime);
      return this.listener.Cr(n, e);
    }
    return U2(!t2.writeResults || t2.writeResults.length === 0), this.Vr = true, this.listener.Nr();
  }
  kr() {
    const t2 = {};
    t2.database = es(this.k), this.gr(t2);
  }
  Dr(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => cs(this.k, t3))
    };
    this.gr(e);
  }
};
var oo = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.ir = n, this.k = s, this.$r = false;
  }
  Or() {
    if (this.$r)
      throw new Q2(j.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  Bi(t2, e, n) {
    return this.Or(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.ir.Bi(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === j.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(j.UNKNOWN, t3.toString());
    });
  }
  ji(t2, e, n) {
    return this.Or(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.ir.ji(t2, e, n, s, i)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === j.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q2(j.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.$r = true;
  }
};
var co = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.Mr = 0, this.Fr = null, this.Lr = true;
  }
  Br() {
    this.Mr === 0 && (this.Ur("Unknown"), this.Fr = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.Fr = null, this.qr("Backend didn't respond within 10 seconds."), this.Ur("Offline"), Promise.resolve())));
  }
  Kr(t2) {
    this.state === "Online" ? this.Ur("Unknown") : (this.Mr++, this.Mr >= 1 && (this.jr(), this.qr(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.Ur("Offline")));
  }
  set(t2) {
    this.jr(), this.Mr = 0, t2 === "Online" && (this.Lr = false), this.Ur(t2);
  }
  Ur(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  qr(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.Lr ? (M2(e), this.Lr = false) : O2("OnlineStateTracker", e);
  }
  jr() {
    this.Fr !== null && (this.Fr.cancel(), this.Fr = null);
  }
};
var ao = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.Qr = [], this.Wr = new Map(), this.Gr = new Set(), this.zr = [], this.Hr = i, this.Hr.Ei((t3) => {
      n.enqueueAndForget(async () => {
        yo(this) && (O2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = K2(t4);
          e2.Gr.add(4), await ho(e2), e2.Jr.set("Unknown"), e2.Gr.delete(4), await uo(e2);
        }(this));
      });
    }), this.Jr = new co(n, s);
  }
};
async function uo(t2) {
  if (yo(t2))
    for (const e of t2.zr)
      await e(true);
}
async function ho(t2) {
  for (const e of t2.zr)
    await e(false);
}
function lo(t2, e) {
  const n = K2(t2);
  n.Wr.has(e.targetId) || (n.Wr.set(e.targetId, e), go(n) ? mo(n) : Oo(n).lr() && wo(n, e));
}
function fo(t2, e) {
  const n = K2(t2), s = Oo(n);
  n.Wr.delete(e), s.lr() && _o(n, e), n.Wr.size === 0 && (s.lr() ? s._r() : yo(n) && n.Jr.set("Unknown"));
}
function wo(t2, e) {
  t2.Yr.X(e.targetId), Oo(t2).Pr(e);
}
function _o(t2, e) {
  t2.Yr.X(e), Oo(t2).vr(e);
}
function mo(t2) {
  t2.Yr = new Ln({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Et: (e) => t2.Wr.get(e) || null
  }), Oo(t2).start(), t2.Jr.Br();
}
function go(t2) {
  return yo(t2) && !Oo(t2).hr() && t2.Wr.size > 0;
}
function yo(t2) {
  return K2(t2).Gr.size === 0;
}
function po(t2) {
  t2.Yr = void 0;
}
async function To(t2) {
  t2.Wr.forEach((e, n) => {
    wo(t2, e);
  });
}
async function Eo(t2, e) {
  po(t2), go(t2) ? (t2.Jr.Kr(e), mo(t2)) : t2.Jr.set("Unknown");
}
async function Io(t2, e, n) {
  if (t2.Jr.set("Online"), e instanceof Mn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.Wr.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.Wr.delete(s), t3.Yr.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      O2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await Ao(t2, n2);
    }
  else if (e instanceof $n ? t2.Yr.ot(e) : e instanceof On ? t2.Yr.dt(e) : t2.Yr.ut(e), !n.isEqual(ut.min()))
    try {
      const e2 = await mr(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.Yr.gt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.Wr.get(s);
            i && t3.Wr.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.Wr.get(e4);
          if (!n3)
            return;
          t3.Wr.set(e4, n3.withResumeToken(pt.EMPTY_BYTE_STRING, n3.snapshotVersion)), _o(t3, e4);
          const s = new ai(n3.target, e4, 1, n3.sequenceNumber);
          wo(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      O2("RemoteStore", "Failed to raise snapshot:", e2), await Ao(t2, e2);
    }
}
async function Ao(t2, e, n) {
  if (!Zs(e))
    throw e;
  t2.Gr.add(1), await ho(t2), t2.Jr.set("Offline"), n || (n = () => mr(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    O2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.Gr.delete(1), await uo(t2);
  });
}
function Ro(t2, e) {
  return e().catch((n) => Ao(t2, n, e));
}
async function bo(t2) {
  const e = K2(t2), n = Mo(e);
  let s = e.Qr.length > 0 ? e.Qr[e.Qr.length - 1].batchId : -1;
  for (; Po(e); )
    try {
      const t3 = await pr(e.localStore, s);
      if (t3 === null) {
        e.Qr.length === 0 && n._r();
        break;
      }
      s = t3.batchId, vo(e, t3);
    } catch (t3) {
      await Ao(e, t3);
    }
  Vo(e) && So(e);
}
function Po(t2) {
  return yo(t2) && t2.Qr.length < 10;
}
function vo(t2, e) {
  t2.Qr.push(e);
  const n = Mo(t2);
  n.lr() && n.Sr && n.Dr(e.mutations);
}
function Vo(t2) {
  return yo(t2) && !Mo(t2).hr() && t2.Qr.length > 0;
}
function So(t2) {
  Mo(t2).start();
}
async function Do(t2) {
  Mo(t2).kr();
}
async function Co(t2) {
  const e = Mo(t2);
  for (const n of t2.Qr)
    e.Dr(n.mutations);
}
async function No(t2, e, n) {
  const s = t2.Qr.shift(), i = ci.from(s, e, n);
  await Ro(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await bo(t2);
}
async function ko(t2, e) {
  e && Mo(t2).Sr && await async function(t3, e2) {
    if (n = e2.code, mn(n) && n !== j.ABORTED) {
      const n2 = t3.Qr.shift();
      Mo(t3).wr(), await Ro(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await bo(t3);
    }
    var n;
  }(t2, e), Vo(t2) && So(t2);
}
async function xo(t2, e) {
  const n = K2(t2);
  n.asyncQueue.verifyOperationInProgress(), O2("RemoteStore", "RemoteStore received new credentials");
  const s = yo(n);
  n.Gr.add(3), await ho(n), s && n.Jr.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.Gr.delete(3), await uo(n);
}
async function $o(t2, e) {
  const n = K2(t2);
  e ? (n.Gr.delete(2), await uo(n)) : e || (n.Gr.add(2), await ho(n), n.Jr.set("Unknown"));
}
function Oo(t2) {
  return t2.Xr || (t2.Xr = function(t3, e, n) {
    const s = K2(t3);
    return s.Or(), new io(e, s.ir, s.authCredentials, s.appCheckCredentials, s.k, n);
  }(t2.datastore, t2.asyncQueue, {
    Di: To.bind(null, t2),
    Ni: Eo.bind(null, t2),
    br: Io.bind(null, t2)
  }), t2.zr.push(async (e) => {
    e ? (t2.Xr.wr(), go(t2) ? mo(t2) : t2.Jr.set("Unknown")) : (await t2.Xr.stop(), po(t2));
  })), t2.Xr;
}
function Mo(t2) {
  return t2.Zr || (t2.Zr = function(t3, e, n) {
    const s = K2(t3);
    return s.Or(), new ro(e, s.ir, s.authCredentials, s.appCheckCredentials, s.k, n);
  }(t2.datastore, t2.asyncQueue, {
    Di: Do.bind(null, t2),
    Ni: ko.bind(null, t2),
    Nr: Co.bind(null, t2),
    Cr: No.bind(null, t2)
  }), t2.zr.push(async (e) => {
    e ? (t2.Zr.wr(), await bo(t2)) : (await t2.Zr.stop(), t2.Qr.length > 0 && (O2("RemoteStore", `Stopping write stream with ${t2.Qr.length} pending writes`), t2.Qr = []));
  })), t2.Zr;
}
var Fo = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new W2(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new Fo(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new Q2(j.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function Lo(t2, e) {
  if (M2("AsyncQueue", `${e}: ${t2}`), Zs(t2))
    return new Q2(j.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var Bo = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || Dt.comparator(e.key, n.key) : (t3, e) => Dt.comparator(t3.key, e.key), this.keyedMap = Pn(), this.sortedSet = new yn(this.comparator);
  }
  static emptySet(t2) {
    return new Bo(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Bo))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new Bo();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var Uo = class {
  constructor() {
    this.eo = new yn(Dt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.eo.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.eo = this.eo.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.eo = this.eo.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.eo = this.eo.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.eo = this.eo.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.eo = this.eo.remove(e) : t2.type === 1 && n.type === 2 ? this.eo = this.eo.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.eo = this.eo.insert(e, {
      type: 2,
      doc: t2.doc
    }) : B2() : this.eo = this.eo.insert(e, t2);
  }
  no() {
    const t2 = [];
    return this.eo.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var qo = class {
  constructor(t2, e, n, s, i, r, o, c) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = c;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new qo(t2, e, Bo.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && ve(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Ko = class {
  constructor() {
    this.so = void 0, this.listeners = [];
  }
};
var jo = class {
  constructor() {
    this.queries = new zi((t2) => Ve(t2), ve), this.onlineState = "Unknown", this.io = new Set();
  }
};
async function Qo(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Ko()), i)
    try {
      r.so = await n.onListen(s);
    } catch (t3) {
      const n2 = Lo(t3, `Initialization of query '${Se(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.ro(n.onlineState), r.so) {
    e.oo(r.so) && Ho(n);
  }
}
async function Wo(t2, e) {
  const n = K2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Go(t2, e) {
  const n = K2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.oo(t3) && (s = true);
      i.so = t3;
    }
  }
  s && Ho(n);
}
function zo(t2, e, n) {
  const s = K2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Ho(t2) {
  t2.io.forEach((t3) => {
    t3.next();
  });
}
var Jo = class {
  constructor(t2, e, n) {
    this.query = t2, this.co = e, this.ao = false, this.uo = null, this.onlineState = "Unknown", this.options = n || {};
  }
  oo(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new qo(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.ao ? this.ho(t2) && (this.co.next(t2), e = true) : this.lo(t2, this.onlineState) && (this.fo(t2), e = true), this.uo = t2, e;
  }
  onError(t2) {
    this.co.error(t2);
  }
  ro(t2) {
    this.onlineState = t2;
    let e = false;
    return this.uo && !this.ao && this.lo(this.uo, t2) && (this.fo(this.uo), e = true), e;
  }
  lo(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.wo || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  ho(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.uo && this.uo.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  fo(t2) {
    t2 = qo.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.ao = true, this.co.next(t2);
  }
};
var Yo = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  _o() {
    return "metadata" in this.payload;
  }
};
var Xo = class {
  constructor(t2) {
    this.k = t2;
  }
  Hn(t2) {
    return Xn(this.k, t2);
  }
  Jn(t2) {
    return t2.metadata.exists ? is(this.k, t2.document, false) : Gt.newNoDocument(this.Hn(t2.metadata.name), this.Yn(t2.metadata.readTime));
  }
  Yn(t2) {
    return zn(t2);
  }
};
var Zo = class {
  constructor(t2, e, n) {
    this.mo = t2, this.localStore = e, this.k = n, this.queries = [], this.documents = [], this.progress = tc2(t2);
  }
  yo(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  po(t2) {
    const e = new Map(), n = new Xo(this.k);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.Hn(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || Dn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await Pr(this.localStore, new Xo(this.k), this.documents, this.mo.id), e = this.po(this.documents);
    for (const t3 of this.queries)
      await vr(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new ar(Object.assign({}, this.progress), t2);
  }
};
function tc2(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var ec2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var nc2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var sc2 = class {
  constructor(t2, e) {
    this.query = t2, this.To = e, this.Eo = null, this.current = false, this.Io = Dn(), this.mutatedKeys = Dn(), this.Ao = Ce(t2), this.Ro = new Bo(this.Ao);
  }
  get bo() {
    return this.To;
  }
  Po(t2, e) {
    const n = e ? e.vo : new Uo(), s = e ? e.Ro : this.Ro;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const c = pe(this.query) && s.size === this.query.limit ? s.last() : null, a = Te(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const u = s.get(t3), h = De(this.query, e2) ? e2 : null, l2 = !!u && this.mutatedKeys.has(u.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (u && h) {
        u.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Vo(u, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (c && this.Ao(h, c) > 0 || a && this.Ao(h, a) < 0) && (o = true));
      } else
        !u && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : u && !h && (n.track({
          type: 1,
          doc: u
        }), d = true, (c || a) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), pe(this.query) || Te(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = pe(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Ro: r,
      vo: n,
      Bn: o,
      mutatedKeys: i
    };
  }
  Vo(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Ro;
    this.Ro = t2.Ro, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.vo.no();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return B2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.Ao(t3.doc, e2.doc)), this.So(n);
    const r = e ? this.Do() : [], o = this.Io.size === 0 && this.current ? 1 : 0, c = o !== this.Eo;
    if (this.Eo = o, i.length !== 0 || c) {
      return {
        snapshot: new qo(this.query, t2.Ro, s, i, t2.mutatedKeys, o === 0, c, false),
        Co: r
      };
    }
    return {
      Co: r
    };
  }
  ro(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      Ro: this.Ro,
      vo: new Uo(),
      mutatedKeys: this.mutatedKeys,
      Bn: false
    }, false)) : {
      Co: []
    };
  }
  No(t2) {
    return !this.To.has(t2) && (!!this.Ro.has(t2) && !this.Ro.get(t2).hasLocalMutations);
  }
  So(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.To = this.To.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.To = this.To.delete(t3)), this.current = t2.current);
  }
  Do() {
    if (!this.current)
      return [];
    const t2 = this.Io;
    this.Io = Dn(), this.Ro.forEach((t3) => {
      this.No(t3.key) && (this.Io = this.Io.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.Io.has(t3) || e.push(new nc2(t3));
    }), this.Io.forEach((n) => {
      t2.has(n) || e.push(new ec2(n));
    }), e;
  }
  ko(t2) {
    this.To = t2.zn, this.Io = Dn();
    const e = this.Po(t2.documents);
    return this.applyChanges(e, true);
  }
  xo() {
    return qo.fromInitialDocuments(this.query, this.Ro, this.mutatedKeys, this.Eo === 0);
  }
};
var ic2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var rc2 = class {
  constructor(t2) {
    this.key = t2, this.$o = false;
  }
};
var oc2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.Oo = {}, this.Mo = new zi((t3) => Ve(t3), ve), this.Fo = new Map(), this.Lo = new Set(), this.Bo = new yn(Dt.comparator), this.Uo = new Map(), this.qo = new Sr(), this.Ko = {}, this.jo = new Map(), this.Qo = Oi.re(), this.onlineState = "Unknown", this.Wo = void 0;
  }
  get isPrimaryClient() {
    return this.Wo === true;
  }
};
async function cc2(t2, e) {
  const n = Oc2(t2);
  let s, i;
  const r = n.Mo.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.xo();
  else {
    const t3 = await Tr(n.localStore, be(e)), r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await ac2(n, e, s, r2 === "current"), n.isPrimaryClient && lo(n.remoteStore, t3);
  }
  return i;
}
async function ac2(t2, e, n, s) {
  t2.Go = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.Po(n3);
    i2.Bn && (i2 = await Ir(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.Po(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return Ec2(t3, e3.targetId, o2.Co), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await Ir(t2.localStore, e, true), r = new sc2(e, i.zn), o = r.Po(i.documents), c = xn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), a = r.applyChanges(o, t2.isPrimaryClient, c);
  Ec2(t2, n, a.Co);
  const u = new ic2(e, n, r);
  return t2.Mo.set(e, u), t2.Fo.has(n) ? t2.Fo.get(n).push(e) : t2.Fo.set(n, [e]), a.snapshot;
}
async function uc2(t2, e) {
  const n = K2(t2), s = n.Mo.get(e), i = n.Fo.get(s.targetId);
  if (i.length > 1)
    return n.Fo.set(s.targetId, i.filter((t3) => !ve(t3, e))), void n.Mo.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await Er(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), fo(n.remoteStore, s.targetId), pc2(n, s.targetId);
    }).catch(Ui);
  } else
    pc2(n, s.targetId), await Er(n.localStore, s.targetId, true);
}
async function hc2(t2, e, n) {
  const s = Mc2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4), s2 = at.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), Dn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.Wn.vn(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = nn(t6, r.get(t6.key));
          e3 != null && o.push(new cn(t6.key, e3, Wt(e3.value.mapValue), Ye.exists(true)));
        }
        return n2.An.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.Ko[t4.currentUser.toKey()];
      s2 || (s2 = new yn(rt));
      s2 = s2.insert(e2, n2), t4.Ko[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await Rc2(s, t3.changes), await bo(s.remoteStore);
  } catch (t3) {
    const e2 = Lo(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function lc2(t2, e) {
  const n = K2(t2);
  try {
    const t3 = await gr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.Uo.get(e2);
      s && (U2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.$o = true : t4.modifiedDocuments.size > 0 ? U2(s.$o) : t4.removedDocuments.size > 0 && (U2(s.$o), s.$o = false));
    }), await Rc2(n, t3, e);
  } catch (t3) {
    await Ui(t3);
  }
}
function fc2(t2, e, n) {
  const s = K2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.Mo.forEach((n2, s2) => {
      const i = s2.view.ro(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = K2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.ro(e2) && (s2 = true);
      }), s2 && Ho(n2);
    }(s.eventManager, e), t3.length && s.Oo.br(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function dc2(t2, e, n) {
  const s = K2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.Uo.get(e), r = i && i.key;
  if (r) {
    let t3 = new yn(Dt.comparator);
    t3 = t3.insert(r, Gt.newNoDocument(r, ut.min()));
    const n2 = Dn().add(r), i2 = new kn(ut.min(), new Map(), new En(rt), t3, n2);
    await lc2(s, i2), s.Bo = s.Bo.remove(r), s.Uo.delete(e), Ac2(s);
  } else
    await Er(s.localStore, e, false).then(() => pc2(s, e, n)).catch(Ui);
}
async function wc2(t2, e) {
  const n = K2(t2), s = e.batch.batchId;
  try {
    const t3 = await _r(n.localStore, e);
    yc2(n, s, null), gc2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await Rc2(n, t3);
  } catch (t3) {
    await Ui(t3);
  }
}
async function _c(t2, e, n) {
  const s = K2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = K2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.An.lookupMutationBatch(t5, e2).next((e3) => (U2(e3 !== null), s2 = e3.keys(), n2.An.removeMutationBatch(t5, e3))).next(() => n2.An.performConsistencyCheck(t5)).next(() => n2.Wn.vn(t5, s2));
      });
    }(s.localStore, e);
    yc2(s, e, n), gc2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await Rc2(s, t3);
  } catch (n2) {
    await Ui(n2);
  }
}
async function mc2(t2, e) {
  const n = K2(t2);
  yo(n.remoteStore) || O2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = K2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.An.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.jo.get(t3) || [];
    s.push(e), n.jo.set(t3, s);
  } catch (t3) {
    const n2 = Lo(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function gc2(t2, e) {
  (t2.jo.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.jo.delete(e);
}
function yc2(t2, e, n) {
  const s = K2(t2);
  let i = s.Ko[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.Ko[s.currentUser.toKey()] = i;
  }
}
function pc2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.Fo.get(e))
    t2.Mo.delete(s), n && t2.Oo.zo(s, n);
  if (t2.Fo.delete(e), t2.isPrimaryClient) {
    t2.qo.us(e).forEach((e2) => {
      t2.qo.containsKey(e2) || Tc2(t2, e2);
    });
  }
}
function Tc2(t2, e) {
  t2.Lo.delete(e.path.canonicalString());
  const n = t2.Bo.get(e);
  n !== null && (fo(t2.remoteStore, n), t2.Bo = t2.Bo.remove(e), t2.Uo.delete(n), Ac2(t2));
}
function Ec2(t2, e, n) {
  for (const s of n)
    if (s instanceof ec2)
      t2.qo.addReference(s.key, e), Ic2(t2, s);
    else if (s instanceof nc2) {
      O2("SyncEngine", "Document no longer in limbo: " + s.key), t2.qo.removeReference(s.key, e);
      t2.qo.containsKey(s.key) || Tc2(t2, s.key);
    } else
      B2();
}
function Ic2(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.Bo.get(n) || t2.Lo.has(s) || (O2("SyncEngine", "New document in limbo: " + n), t2.Lo.add(s), Ac2(t2));
}
function Ac2(t2) {
  for (; t2.Lo.size > 0 && t2.Bo.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.Lo.values().next().value;
    t2.Lo.delete(e);
    const n = new Dt(wt.fromString(e)), s = t2.Qo.next();
    t2.Uo.set(s, new rc2(n)), t2.Bo = t2.Bo.insert(n, s), lo(t2.remoteStore, new ai(be(ye(n.path)), s, 2, nt.I));
  }
}
async function Rc2(t2, e, n) {
  const s = K2(t2), i = [], r = [], o = [];
  s.Mo.isEmpty() || (s.Mo.forEach((t3, c) => {
    o.push(s.Go(c, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(c.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = hr.$n(c.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.Oo.br(i), await async function(t3, e2) {
    const n2 = K2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => zs.forEach(e2, (e3) => zs.forEach(e3.kn, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => zs.forEach(e3.xn, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Zs(t4))
        throw t4;
      O2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.qn.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.qn = n2.qn.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function bc2(t2, e) {
  const n = K2(t2);
  if (!n.currentUser.isEqual(e)) {
    O2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await wr(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.jo.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new Q2(j.CANCELLED, e2));
        });
      }), t4.jo.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await Rc2(n, t3.Gn);
  }
}
function Pc2(t2, e) {
  const n = K2(t2), s = n.Uo.get(e);
  if (s && s.$o)
    return Dn().add(s.key);
  {
    let t3 = Dn();
    const s2 = n.Fo.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.Mo.get(e2);
      t3 = t3.unionWith(s3.view.bo);
    }
    return t3;
  }
}
async function vc2(t2, e) {
  const n = K2(t2), s = await Ir(n.localStore, e.query, true), i = e.view.ko(s);
  return n.isPrimaryClient && Ec2(n, e.targetId, i.Co), i;
}
async function Vc2(t2) {
  const e = K2(t2);
  return Rr(e.localStore).then((t3) => Rc2(e, t3));
}
async function Sc2(t2, e, n, s) {
  const i = K2(t2), r = await function(t3, e2) {
    const n2 = K2(t3), s2 = K2(n2.An);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.Zt(t4, e2).next((e3) => e3 ? n2.Wn.vn(t4, e3) : zs.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await bo(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (yc2(i, e, s || null), gc2(i, e), function(t3, e2) {
    K2(K2(t3).An).ee(e2);
  }(i.localStore, e)) : B2(), await Rc2(i, r)) : O2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function Dc2(t2, e) {
  const n = K2(t2);
  if (Oc2(n), Mc2(n), e === true && n.Wo !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await Cc2(n, t3.toArray());
    n.Wo = true, await $o(n.remoteStore, true);
    for (const t4 of e2)
      lo(n.remoteStore, t4);
  } else if (e === false && n.Wo !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.Fo.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (pc2(n, i), Er(n.localStore, i, true))), fo(n.remoteStore, i);
    }), await e2, await Cc2(n, t3), function(t4) {
      const e3 = K2(t4);
      e3.Uo.forEach((t5, n2) => {
        fo(e3.remoteStore, n2);
      }), e3.qo.hs(), e3.Uo = new Map(), e3.Bo = new yn(Dt.comparator);
    }(n), n.Wo = false, await $o(n.remoteStore, false);
  }
}
async function Cc2(t2, e, n) {
  const s = K2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.Fo.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await Tr(s.localStore, be(n2[0]));
      for (const t4 of n2) {
        const e3 = s.Mo.get(t4), n3 = await vc2(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await Ar(s.localStore, t3);
      e2 = await Tr(s.localStore, n3), await ac2(s, Nc2(n3), t3, false);
    }
    i.push(e2);
  }
  return s.Oo.br(r), i;
}
function Nc2(t2) {
  return ge(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function kc2(t2) {
  const e = K2(t2);
  return K2(K2(e.localStore).persistence).Tn();
}
async function xc2(t2, e, n, s) {
  const i = K2(t2);
  if (i.Wo)
    O2("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.Fo.has(e))
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await Rr(i.localStore), s2 = kn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await Rc2(i, t3, s2);
        break;
      }
      case "rejected":
        await Er(i.localStore, e, true), pc2(i, e, s);
        break;
      default:
        B2();
    }
}
async function $c2(t2, e, n) {
  const s = Oc2(t2);
  if (s.Wo) {
    for (const t3 of e) {
      if (s.Fo.has(t3)) {
        O2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await Ar(s.localStore, t3), n2 = await Tr(s.localStore, e2);
      await ac2(s, Nc2(e2), n2.targetId, false), lo(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.Fo.has(t3) && await Er(s.localStore, t3, false).then(() => {
        fo(s.remoteStore, t3), pc2(s, t3);
      }).catch(Ui);
  }
}
function Oc2(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = lc2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Pc2.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = dc2.bind(null, e), e.Oo.br = Go.bind(null, e.eventManager), e.Oo.zo = zo.bind(null, e.eventManager), e;
}
function Mc2(t2) {
  const e = K2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = wc2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = _c.bind(null, e), e;
}
function Fc2(t2, e, n) {
  const s = K2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = K2(t4), s3 = zn(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Ye.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n2._updateProgress(tc2(s2));
      const i = new Zo(s2, t3.localStore, e2.k);
      let r = await e2.Ho();
      for (; r; ) {
        const t4 = await i.yo(r);
        t4 && n2._updateProgress(t4), r = await e2.Ho();
      }
      const o = await i.complete();
      await Rc2(t3, o.In, void 0), await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Ye.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress);
    } catch (t4) {
      F2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4);
    }
  })(s, e, n).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
var Lc2 = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.k = eo(t2.databaseInfo.databaseId), this.sharedClientState = this.Jo(t2), this.persistence = this.Yo(t2), await this.persistence.start(), this.gcScheduler = this.Xo(t2), this.localStore = this.Zo(t2);
  }
  Xo(t2) {
    return null;
  }
  Zo(t2) {
    return dr(this.persistence, new lr(), t2.initialUser, this.k);
  }
  Yo(t2) {
    return new $r(Mr.ks, this.k);
  }
  Jo(t2) {
    return new Gr();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Bc2 = class extends Lc2 {
  constructor(t2, e, n) {
    super(), this.tc = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await br(this.localStore), await this.tc.initialize(this, t2), await Mc2(this.tc.syncEngine), await bo(this.tc.remoteStore), await this.persistence.sn(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  Zo(t2) {
    return dr(this.persistence, new lr(), t2.initialUser, this.k);
  }
  Xo(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new ji(e, t2.asyncQueue);
  }
  Yo(t2) {
    const e = cr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? Vi.withCacheSize(this.cacheSizeBytes) : Vi.DEFAULT;
    return new ir(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Zr(), to(), this.k, this.sharedClientState, !!this.forceOwnership);
  }
  Jo(t2) {
    return new Gr();
  }
};
var Uc2 = class extends Bc2 {
  constructor(t2, e) {
    super(t2, e, false), this.tc = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.tc.syncEngine;
    this.sharedClientState instanceof Wr && (this.sharedClientState.syncEngine = {
      mi: Sc2.bind(null, e),
      gi: xc2.bind(null, e),
      yi: $c2.bind(null, e),
      Tn: kc2.bind(null, e),
      _i: Vc2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.sn(async (t3) => {
      await Dc2(this.tc.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  Jo(t2) {
    const e = Zr();
    if (!Wr.Pt(e))
      throw new Q2(j.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = cr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Wr(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var qc2 = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => fc2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = bc2.bind(null, this.syncEngine), await $o(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new jo();
  }
  createDatastore(t2) {
    const e = eo(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Xr(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new oo(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => fc2(this.syncEngine, t3, 0), r = Hr.Pt() ? new Hr() : new zr(), new ao(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const c = new oc2(t3, e2, n, s, i, r);
      return o && (c.Wo = true), c;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = K2(t2);
      O2("RemoteStore", "RemoteStore shutting down."), e.Gr.add(5), await ho(e), e.Hr.shutdown(), e.Jr.set("Unknown");
    }(this.remoteStore);
  }
};
function Kc2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var jc2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.ec(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.ec(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  nc() {
    this.muted = true;
  }
  ec(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var Qc2 = class {
  constructor(t2, e) {
    this.sc = t2, this.k = e, this.metadata = new W2(), this.buffer = new Uint8Array(), this.ic = new TextDecoder("utf-8"), this.rc().then((t3) => {
      t3 && t3._o() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.sc.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async Ho() {
    return await this.getMetadata(), this.rc();
  }
  async rc() {
    const t2 = await this.oc();
    if (t2 === null)
      return null;
    const e = this.ic.decode(t2), n = Number(e);
    isNaN(n) && this.cc(`length string (${e}) is not valid number`);
    const s = await this.ac(n);
    return new Yo(JSON.parse(s), t2.length + n);
  }
  uc() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async oc() {
    for (; this.uc() < 0; ) {
      if (await this.hc())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.uc();
    t2 < 0 && this.cc("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async ac(t2) {
    for (; this.buffer.length < t2; ) {
      await this.hc() && this.cc("Reached the end of bundle when more is expected.");
    }
    const e = this.ic.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  cc(t2) {
    throw this.sc.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async hc() {
    const t2 = await this.sc.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var Wc2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new Q2(j.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = K2(t3), s = es(n.k) + "/documents", i = {
        documents: e2.map((t4) => Yn(n.k, t4))
      }, r = await n.ji("BatchGetDocuments", s, i), o = new Map();
      r.forEach((t4) => {
        const e3 = rs(n.k, t4);
        o.set(e3.key.toString(), e3);
      });
      const c = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        U2(!!e3), c.push(e3);
      }), c;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new ln(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = Dt.fromPath(e);
      this.mutations.push(new fn(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = K2(t3), s = es(n.k) + "/documents", i = {
        writes: e.map((t4) => cs(n.k, t4))
      };
      await n.Bi("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw B2();
      e = ut.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new Q2(j.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? Ye.updateTime(e) : Ye.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(ut.min()))
        throw new Q2(j.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return Ye.updateTime(e);
    }
    return Ye.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Gc2 = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.lc = 5, this.ur = new no(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.lc -= 1, this.fc();
  }
  fc() {
    this.ur.Zi(async () => {
      const t2 = new Wc2(this.datastore), e = this.dc(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.wc(t3);
        }));
      }).catch((t3) => {
        this.wc(t3);
      });
    });
  }
  dc(t2) {
    try {
      const e = this.updateFunction(t2);
      return !vt(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  wc(t2) {
    this.lc > 0 && this._c(t2) ? (this.lc -= 1, this.asyncQueue.enqueueAndForget(() => (this.fc(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  _c(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !mn(e);
    }
    return false;
  }
};
var zc2 = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = C2.UNAUTHENTICATED, this.clientId = it.A(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      O2("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, (t3) => (O2("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new Q2(j.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new W2();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = Lo(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Hc2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), O2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await wr(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Jc2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Yc2(t2);
  O2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => xo(e.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n2) => xo(e.remoteStore, n2)), t2.onlineComponents = e;
}
async function Yc2(t2) {
  return t2.offlineComponents || (O2("FirestoreClient", "Using default OfflineComponentProvider"), await Hc2(t2, new Lc2())), t2.offlineComponents;
}
async function Xc2(t2) {
  return t2.onlineComponents || (O2("FirestoreClient", "Using default OnlineComponentProvider"), await Jc2(t2, new qc2())), t2.onlineComponents;
}
function Zc2(t2) {
  return Yc2(t2).then((t3) => t3.persistence);
}
function ta2(t2) {
  return Yc2(t2).then((t3) => t3.localStore);
}
function ea2(t2) {
  return Xc2(t2).then((t3) => t3.remoteStore);
}
function na2(t2) {
  return Xc2(t2).then((t3) => t3.syncEngine);
}
async function sa2(t2) {
  const e = await Xc2(t2), n = e.eventManager;
  return n.onListen = cc2.bind(null, e.syncEngine), n.onUnlisten = uc2.bind(null, e.syncEngine), n;
}
function ia2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Zc2(t2), n = await ea2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = K2(t3);
      return e2.Gr.delete(0), uo(e2);
    }(n);
  });
}
function ra2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Zc2(t2), n = await ea2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = K2(t3);
      e2.Gr.add(0), await ho(e2), e2.Jr.set("Offline");
    }(n);
  });
}
function oa2(t2, e) {
  const n = new W2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = K2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.Wn.Rn(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new Q2(j.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = Lo(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await ta2(t2), e, n)), n.promise;
}
function ca(t2, e, n = {}) {
  const s = new W2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new jc2({
      next: (r2) => {
        e2.enqueueAndForget(() => Wo(t3, o));
        const c = r2.docs.has(n2);
        !c && r2.fromCache ? i.reject(new Q2(j.UNAVAILABLE, "Failed to get document because the client is offline.")) : c && r2.fromCache && s2 && s2.source === "server" ? i.reject(new Q2(j.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Jo(ye(n2.path), r, {
      includeMetadataChanges: true,
      wo: true
    });
    return Qo(t3, o);
  }(await sa2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function aa2(t2, e) {
  const n = new W2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await Ir(t3, e2, true), i = new sc2(e2, s.zn), r = i.Po(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = Lo(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await ta2(t2), e, n)), n.promise;
}
function ua2(t2, e, n = {}) {
  const s = new W2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new jc2({
      next: (n3) => {
        e2.enqueueAndForget(() => Wo(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new Q2(j.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Jo(n2, r, {
      includeMetadataChanges: true,
      wo: true
    });
    return Qo(t3, o);
  }(await sa2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function ha2(t2, e) {
  const n = new jc2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    K2(t3).io.add(e2), e2.next();
  }(await sa2(t2), n)), () => {
    n.nc(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      K2(t3).io.delete(e2);
    }(await sa2(t2), n));
  };
}
function la2(t2, e) {
  const n = new W2();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Xc2(t3).then((t4) => t4.datastore);
    }(t2);
    new Gc2(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function fa2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Qc2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Kc2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Kc2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, eo(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    Fc2(await na2(t2), i, s);
  });
}
function da2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = K2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Ye.getNamedQuery(t4, e2));
  }(await ta2(t2), e));
}
var wa = class {
  constructor(t2, e, n, s, i, r, o, c) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = c;
  }
};
var _a = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof _a && t2.projectId === this.projectId && t2.database === this.database;
  }
};
var ma2 = new Map();
function ga(t2, e, n) {
  if (!n)
    throw new Q2(j.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function ya2(t2, e, n, s) {
  if (e === true && s === true)
    throw new Q2(j.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function pa2(t2) {
  if (!Dt.isDocumentKey(t2))
    throw new Q2(j.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function Ta(t2) {
  if (Dt.isDocumentKey(t2))
    throw new Q2(j.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function Ea(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : B2();
}
function Ia2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new Q2(j.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = Ea(t2);
      throw new Q2(j.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function Aa2(t2, e) {
  if (e <= 0)
    throw new Q2(j.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var Ra2 = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new Q2(j.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new Q2(j.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, ya2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var ba2 = class {
  constructor(t2, e, n) {
    this._authCredentials = e, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Ra2({}), this._settingsFrozen = false, t2 instanceof _a ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new Q2(j.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new _a(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new Q2(j.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new Q2(j.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new Ra2(t2), t2.credentials !== void 0 && (this._authCredentials = function(t3) {
      if (!t3)
        return new z2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return U2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new X2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new Q2(j.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = ma2.get(t2);
      e && (O2("ComponentProvider", "Removing Datastore"), ma2.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function Pa(t2, e, n, s = {}) {
  var i;
  const r = (t2 = Ia2(t2, ba2))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && F2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = C2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new Q2(j.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new C2(r2);
    }
    t2._authCredentials = new H2(new G(e2, n2));
  }
}
var va = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new Sa2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new va(this.firestore, t2, this._key);
  }
};
var Va2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new Va2(this.firestore, t2, this._query);
  }
};
var Sa2 = class extends Va2 {
  constructor(t2, e, n) {
    super(t2, e, ye(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new va(this.firestore, null, new Dt(t2));
  }
  withConverter(t2) {
    return new Sa2(this.firestore, t2, this._path);
  }
};
function Da(t2, e, ...n) {
  if (t2 = getModularInstance(t2), ga("collection", "path", e), t2 instanceof ba2) {
    const s = wt.fromString(e, ...n);
    return Ta(s), new Sa2(t2, null, s);
  }
  {
    if (!(t2 instanceof va || t2 instanceof Sa2))
      throw new Q2(j.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(wt.fromString(e, ...n));
    return Ta(s), new Sa2(t2.firestore, null, s);
  }
}
function Ca2(t2, e) {
  if (t2 = Ia2(t2, ba2), ga("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new Q2(j.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new Va2(t2, null, function(t3) {
    return new me(wt.emptyPath(), t3);
  }(e));
}
function Na2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = it.A()), ga("doc", "path", e), t2 instanceof ba2) {
    const s = wt.fromString(e, ...n);
    return pa2(s), new va(t2, null, new Dt(s));
  }
  {
    if (!(t2 instanceof va || t2 instanceof Sa2))
      throw new Q2(j.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(wt.fromString(e, ...n));
    return pa2(s), new va(t2.firestore, t2 instanceof Sa2 ? t2.converter : null, new Dt(s));
  }
}
function ka2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof va || t2 instanceof Sa2) && (e instanceof va || e instanceof Sa2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function xa2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof Va2 && e instanceof Va2 && (t2.firestore === e.firestore && ve(t2._query, e._query) && t2.converter === e.converter);
}
var $a2 = class {
  constructor() {
    this.mc = Promise.resolve(), this.gc = [], this.yc = false, this.Tc = [], this.Ec = null, this.Ic = false, this.Ac = false, this.Rc = [], this.ur = new no(this, "async_queue_retry"), this.bc = () => {
      const t3 = to();
      t3 && O2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.ur.er();
    };
    const t2 = to();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.bc);
  }
  get isShuttingDown() {
    return this.yc;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Pc(), this.vc(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.yc) {
      this.yc = true, this.Ac = t2 || false;
      const e = to();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.bc);
    }
  }
  enqueue(t2) {
    if (this.Pc(), this.yc)
      return new Promise(() => {
      });
    const e = new W2();
    return this.vc(() => this.yc && this.Ac ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.gc.push(t2), this.Vc()));
  }
  async Vc() {
    if (this.gc.length !== 0) {
      try {
        await this.gc[0](), this.gc.shift(), this.ur.reset();
      } catch (t2) {
        if (!Zs(t2))
          throw t2;
        O2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.gc.length > 0 && this.ur.Zi(() => this.Vc());
    }
  }
  vc(t2) {
    const e = this.mc.then(() => (this.Ic = true, t2().catch((t3) => {
      this.Ec = t3, this.Ic = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw M2("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.Ic = false, t3))));
    return this.mc = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Pc(), this.Rc.indexOf(t2) > -1 && (e = 0);
    const s = Fo.createAndSchedule(this, t2, e, n, (t3) => this.Sc(t3));
    return this.Tc.push(s), s;
  }
  Pc() {
    this.Ec && B2();
  }
  verifyOperationInProgress() {
  }
  async Dc() {
    let t2;
    do {
      t2 = this.mc, await t2;
    } while (t2 !== this.mc);
  }
  Cc(t2) {
    for (const e of this.Tc)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Nc(t2) {
    return this.Dc().then(() => {
      this.Tc.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.Tc)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.Dc();
    });
  }
  kc(t2) {
    this.Rc.push(t2);
  }
  Sc(t2) {
    const e = this.Tc.indexOf(t2);
    this.Tc.splice(e, 1);
  }
};
function Oa(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var Ma2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new W2(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var Fa2 = -1;
var La2 = class extends ba2 {
  constructor(t2, e, n) {
    super(t2, e, n), this.type = "firestore", this._queue = new $a2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Ka2(this), this._firestoreClient.terminate();
  }
};
function Ba(t2, e) {
  const n = _getProvider(t2, "firestore");
  if (n.isInitialized()) {
    const t3 = n.getImmediate(), s = n.getOptions();
    if (deepEqual(s, e))
      return t3;
    throw new Q2(j.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (e.cacheSizeBytes !== void 0 && e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
    throw new Q2(j.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n.initialize({
    options: e
  });
}
function Ua2(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function qa2(t2) {
  return t2._firestoreClient || Ka2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Ka2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new wa(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new zc2(t2._authCredentials, t2._appCheckCredentials, t2._queue, s);
}
function ja2(t2, e) {
  tu(t2 = Ia2(t2, La2));
  const n = qa2(t2), s = t2._freezeSettings(), i = new qc2();
  return Wa2(n, i, new Bc2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Qa(t2) {
  tu(t2 = Ia2(t2, La2));
  const e = qa2(t2), n = t2._freezeSettings(), s = new qc2();
  return Wa2(e, s, new Uc2(s, n.cacheSizeBytes));
}
function Wa2(t2, e, n) {
  const s = new W2();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Hc2(t2, n), await Jc2(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === j.FAILED_PRECONDITION || t4.code === j.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function Ga2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new Q2(j.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new W2();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!Js.Pt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await Js.delete(e2);
      }(cr(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function za2(t2) {
  return function(t3) {
    const e = new W2();
    return t3.asyncQueue.enqueueAndForget(async () => mc2(await na2(t3), e)), e.promise;
  }(qa2(t2 = Ia2(t2, La2)));
}
function Ha2(t2) {
  return ia2(qa2(t2 = Ia2(t2, La2)));
}
function Ja2(t2) {
  return ra2(qa2(t2 = Ia2(t2, La2)));
}
function Ya2(t2) {
  return _removeServiceInstance(t2.app, "firestore"), t2._delete();
}
function Xa2(t2, e) {
  const n = qa2(t2 = Ia2(t2, La2)), s = new Ma2();
  return fa2(n, t2._databaseId, e, s), s;
}
function Za2(t2, e) {
  return da2(qa2(t2 = Ia2(t2, La2)), e).then((e2) => e2 ? new Va2(t2, null, e2.query) : null);
}
function tu(t2) {
  if (t2._initialized || t2._terminated)
    throw new Q2(j.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var eu = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new Q2(j.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new mt(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function nu() {
  return new eu("__name__");
}
var su = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new su(pt.fromBase64String(t2));
    } catch (t3) {
      throw new Q2(j.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new su(pt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var iu = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var ru = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new Q2(j.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new Q2(j.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return rt(this._lat, t2._lat) || rt(this._long, t2._long);
  }
};
var ou = /^__.*__$/;
var cu = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new cn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new on(t2, this.data, e, this.fieldTransforms);
  }
};
var au = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new cn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function uu(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw B2();
  }
}
var hu = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.k = n, this.ignoreUndefinedProperties = s, i === void 0 && this.xc(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get $c() {
    return this.settings.$c;
  }
  Oc(t2) {
    return new hu(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.k, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Mc(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Oc({
      path: n,
      Fc: false
    });
    return s.Lc(t2), s;
  }
  Bc(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Oc({
      path: n,
      Fc: false
    });
    return s.xc(), s;
  }
  Uc(t2) {
    return this.Oc({
      path: void 0,
      Fc: true
    });
  }
  qc(t2) {
    return Du(t2, this.settings.methodName, this.settings.Kc || false, this.path, this.settings.jc);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  xc() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.Lc(this.path.get(t2));
  }
  Lc(t2) {
    if (t2.length === 0)
      throw this.qc("Document fields must not be empty");
    if (uu(this.$c) && ou.test(t2))
      throw this.qc('Document fields cannot begin and end with "__"');
  }
};
var lu = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.k = n || eo(t2);
  }
  Qc(t2, e, n, s = false) {
    return new hu({
      $c: t2,
      methodName: e,
      jc: n,
      path: mt.emptyPath(),
      Fc: false,
      Kc: s
    }, this.databaseId, this.k, this.ignoreUndefinedProperties);
  }
};
function fu(t2) {
  const e = t2._freezeSettings(), n = eo(t2._databaseId);
  return new lu(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function du(t2, e, n, s, i, r = {}) {
  const o = t2.Qc(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Pu("Data must be an object, but it was:", o, s);
  const c = Ru(s, o);
  let a, u;
  if (r.merge)
    a = new gt(o.fieldMask), u = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = vu(e, s2, n);
      if (!o.contains(i2))
        throw new Q2(j.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Cu(t3, i2) || t3.push(i2);
    }
    a = new gt(t3), u = o.fieldTransforms.filter((t4) => a.covers(t4.field));
  } else
    a = null, u = o.fieldTransforms;
  return new cu(new Qt(c), a, u);
}
var wu = class extends iu {
  _toFieldTransform(t2) {
    if (t2.$c !== 2)
      throw t2.$c === 1 ? t2.qc(`${this._methodName}() can only appear at the top level of your update data`) : t2.qc(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof wu;
  }
};
function _u(t2, e, n) {
  return new hu({
    $c: 3,
    jc: e.settings.jc,
    methodName: t2._methodName,
    Fc: n
  }, e.databaseId, e.k, e.ignoreUndefinedProperties);
}
var mu = class extends iu {
  _toFieldTransform(t2) {
    return new ze(t2.path, new Be());
  }
  isEqual(t2) {
    return t2 instanceof mu;
  }
};
var gu = class extends iu {
  constructor(t2, e) {
    super(t2), this.Wc = e;
  }
  _toFieldTransform(t2) {
    const e = _u(this, t2, true), n = this.Wc.map((t3) => Au(t3, e)), s = new Ue(n);
    return new ze(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var yu = class extends iu {
  constructor(t2, e) {
    super(t2), this.Wc = e;
  }
  _toFieldTransform(t2) {
    const e = _u(this, t2, true), n = this.Wc.map((t3) => Au(t3, e)), s = new Ke(n);
    return new ze(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var pu = class extends iu {
  constructor(t2, e) {
    super(t2), this.Gc = e;
  }
  _toFieldTransform(t2) {
    const e = new Qe(t2.k, $e(t2.k, this.Gc));
    return new ze(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function Tu(t2, e, n, s) {
  const i = t2.Qc(1, e, n);
  Pu("Data must be an object, but it was:", i, s);
  const r = [], o = Qt.empty();
  lt(s, (t3, s2) => {
    const c2 = Su(e, t3, n);
    s2 = getModularInstance(s2);
    const a = i.Bc(c2);
    if (s2 instanceof wu)
      r.push(c2);
    else {
      const t4 = Au(s2, a);
      t4 != null && (r.push(c2), o.set(c2, t4));
    }
  });
  const c = new gt(r);
  return new au(o, c, i.fieldTransforms);
}
function Eu(t2, e, n, s, i, r) {
  const o = t2.Qc(1, e, n), c = [vu(e, s, n)], a = [i];
  if (r.length % 2 != 0)
    throw new Q2(j.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    c.push(vu(e, r[t3])), a.push(r[t3 + 1]);
  const u = [], h = Qt.empty();
  for (let t3 = c.length - 1; t3 >= 0; --t3)
    if (!Cu(u, c[t3])) {
      const e2 = c[t3];
      let n2 = a[t3];
      n2 = getModularInstance(n2);
      const s2 = o.Bc(e2);
      if (n2 instanceof wu)
        u.push(e2);
      else {
        const t4 = Au(n2, s2);
        t4 != null && (u.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new gt(u);
  return new au(h, l2, o.fieldTransforms);
}
function Iu(t2, e, n, s = false) {
  return Au(n, t2.Qc(s ? 4 : 3, e));
}
function Au(t2, e) {
  if (bu(t2 = getModularInstance(t2)))
    return Pu("Unsupported field value:", e, t2), Ru(t2, e);
  if (t2 instanceof iu)
    return function(t3, e2) {
      if (!uu(e2.$c))
        throw e2.qc(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.qc(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.Fc && e.$c !== 4)
      throw e.qc("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = Au(i, e2.Uc(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return $e(e2.k, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = at.fromDate(t3);
      return {
        timestampValue: Qn(e2.k, n)
      };
    }
    if (t3 instanceof at) {
      const n = new at(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Qn(e2.k, n)
      };
    }
    if (t3 instanceof ru)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof su)
      return {
        bytesValue: Wn(e2.k, t3._byteString)
      };
    if (t3 instanceof va) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.qc(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: Hn(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.qc(`Unsupported field value: ${Ea(t3)}`);
  }(t2, e);
}
function Ru(t2, e) {
  const n = {};
  return ft(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : lt(t2, (t3, s) => {
    const i = Au(s, e.Mc(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function bu(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof at || t2 instanceof ru || t2 instanceof su || t2 instanceof va || t2 instanceof iu);
}
function Pu(t2, e, n) {
  if (!bu(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = Ea(n);
    throw s === "an object" ? e.qc(t2 + " a custom object") : e.qc(t2 + " " + s);
  }
}
function vu(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof eu)
    return e._internalPath;
  if (typeof e == "string")
    return Su(t2, e);
  throw Du("Field path arguments must be of type string or ", t2, false, void 0, n);
}
var Vu = new RegExp("[~\\*/\\[\\]]");
function Su(t2, e, n) {
  if (e.search(Vu) >= 0)
    throw Du(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new eu(...e.split("."))._internalPath;
  } catch (s) {
    throw Du(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function Du(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let c = `Function ${e}() called with invalid data`;
  n && (c += " (via `toFirestore()`)"), c += ". ";
  let a = "";
  return (r || o) && (a += " (found", r && (a += ` in field ${s}`), o && (a += ` in document ${i}`), a += ")"), new Q2(j.INVALID_ARGUMENT, c + t2 + a);
}
function Cu(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var Nu = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new va(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new ku(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(xu("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var ku = class extends Nu {
  data() {
    return super.data();
  }
};
function xu(t2, e) {
  return typeof e == "string" ? Su(t2, e) : e instanceof eu ? e._internalPath : e._delegate._internalPath;
}
var $u = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var Ou = class extends Nu {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Mu(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(xu("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var Mu = class extends Ou {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var Fu = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new $u(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new Mu(this._firestore, this._userDataWriter, n.key, n, new $u(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new Q2(j.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new Mu(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new $u(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new Mu(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new $u(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Lu(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Lu(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return B2();
  }
}
function Bu(t2, e) {
  return t2 instanceof Ou && e instanceof Ou ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Fu && e instanceof Fu && (t2._firestore === e._firestore && xa2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Uu(t2) {
  if (Te(t2) && t2.explicitOrderBy.length === 0)
    throw new Q2(j.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var qu = class {
};
function Ku(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var ju = class extends qu {
  constructor(t2, e, n) {
    super(), this.zc = t2, this.Hc = e, this.Jc = n, this.type = "where";
  }
  _apply(t2) {
    const e = fu(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let c;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new Q2(j.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if (r === "in" || r === "not-in") {
          rh(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(ih(s, t3, n3));
          c = {
            arrayValue: {
              values: e3
            }
          };
        } else
          c = ih(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || rh(o, r), c = Iu(n2, e2, o, r === "in" || r === "not-in");
      const a = te.create(i, r, c);
      return function(t4, e3) {
        if (e3.V()) {
          const n4 = Ie(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new Q2(j.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = Ee(t4);
          s2 !== null && oh(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new Q2(j.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new Q2(j.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, a), a;
    }(t2._query, "where", e, t2.firestore._databaseId, this.zc, this.Hc, this.Jc);
    return new Va2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new me(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Qu(t2, e, n) {
  const s = e, i = xu("where", t2);
  return new ju(i, s, n);
}
var Wu = class extends qu {
  constructor(t2, e) {
    super(), this.zc = t2, this.Yc = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new Q2(j.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new Q2(j.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new fe(e2, n);
      return function(t4, e3) {
        if (Ee(t4) === null) {
          const n2 = Ie(t4);
          n2 !== null && oh(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.zc, this.Yc);
    return new Va2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new me(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Gu(t2, e = "asc") {
  const n = e, s = xu("orderBy", t2);
  return new Wu(s, n);
}
var zu = class extends qu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Xc = e, this.Zc = n;
  }
  _apply(t2) {
    return new Va2(t2.firestore, t2.converter, Pe(t2._query, this.Xc, this.Zc));
  }
};
function Hu(t2) {
  return Aa2("limit", t2), new zu("limit", t2, "F");
}
function Ju(t2) {
  return Aa2("limitToLast", t2), new zu("limitToLast", t2, "L");
}
var Yu = class extends qu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.ta = e, this.ea = n;
  }
  _apply(t2) {
    const e = sh(t2, this.type, this.ta, this.ea);
    return new Va2(t2.firestore, t2.converter, function(t3, e2) {
      return new me(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Xu(...t2) {
  return new Yu("startAt", t2, true);
}
function Zu(...t2) {
  return new Yu("startAfter", t2, false);
}
var th = class extends qu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.ta = e, this.ea = n;
  }
  _apply(t2) {
    const e = sh(t2, this.type, this.ta, this.ea);
    return new Va2(t2.firestore, t2.converter, function(t3, e2) {
      return new me(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function eh(...t2) {
  return new th("endBefore", t2, true);
}
function nh(...t2) {
  return new th("endAt", t2, false);
}
function sh(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof Nu)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new Q2(j.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of Re(t3))
        if (n3.field.isKeyField())
          r.push(Ft(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (Rt(t4))
            throw new Q2(j.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new Q2(j.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new he(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = fu(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new Q2(j.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const c = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const a = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof a != "string")
            throw new Q2(j.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof a}`);
          if (!Ae(t3) && a.indexOf("/") !== -1)
            throw new Q2(j.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${a}' contains a slash.`);
          const n3 = t3.path.child(wt.fromString(a));
          if (!Dt.isDocumentKey(n3))
            throw new Q2(j.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new Dt(n3);
          c.push(Ft(e2, i3));
        } else {
          const t4 = Iu(n2, s2, a);
          c.push(t4);
        }
      }
      return new he(c, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function ih(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new Q2(j.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!Ae(e) && n.indexOf("/") !== -1)
      throw new Q2(j.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(wt.fromString(n));
    if (!Dt.isDocumentKey(s))
      throw new Q2(j.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return Ft(t2, new Dt(s));
  }
  if (n instanceof va)
    return Ft(t2, n._key);
  throw new Q2(j.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Ea(n)}.`);
}
function rh(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new Q2(j.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new Q2(j.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function oh(t2, e, n) {
  if (!n.isEqual(e))
    throw new Q2(j.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var ch = class {
  convertValue(t2, e = "none") {
    switch (Ct(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return It(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(At(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw B2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return lt(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new ru(It(t2.latitude), It(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = bt(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(Pt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = Et(t2);
    return new at(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = wt.fromString(t2);
    U2(Rs(n));
    const s = new _a(n.get(1), n.get(3)), i = new Dt(n.popFirst(5));
    return s.isEqual(e) || M2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function ah(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var uh = class extends ch {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new su(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new va(this.firestore, null, e);
  }
};
var hh = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = fu(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = lh(t2, this._firestore), i = ah(s.converter, e, n), r = du(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, Ye.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = lh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof eu ? Eu(this._dataReader, "WriteBatch.update", i._key, e, n, s) : Tu(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, Ye.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = lh(t2, this._firestore);
    return this._mutations = this._mutations.concat(new ln(e._key, Ye.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new Q2(j.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function lh(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new Q2(j.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function fh(t2) {
  t2 = Ia2(t2, va);
  const e = Ia2(t2.firestore, La2);
  return ca(qa2(e), t2._key).then((n) => Ph(e, t2, n));
}
var dh = class extends ch {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new su(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new va(this.firestore, null, e);
  }
};
function wh(t2) {
  t2 = Ia2(t2, va);
  const e = Ia2(t2.firestore, La2), n = qa2(e), s = new dh(e);
  return oa2(n, t2._key).then((n2) => new Ou(e, s, t2._key, n2, new $u(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function _h(t2) {
  t2 = Ia2(t2, va);
  const e = Ia2(t2.firestore, La2);
  return ca(qa2(e), t2._key, {
    source: "server"
  }).then((n) => Ph(e, t2, n));
}
function mh(t2) {
  t2 = Ia2(t2, Va2);
  const e = Ia2(t2.firestore, La2), n = qa2(e), s = new dh(e);
  return Uu(t2._query), ua2(n, t2._query).then((n2) => new Fu(e, s, t2, n2));
}
function gh(t2) {
  t2 = Ia2(t2, Va2);
  const e = Ia2(t2.firestore, La2), n = qa2(e), s = new dh(e);
  return aa2(n, t2._query).then((n2) => new Fu(e, s, t2, n2));
}
function yh(t2) {
  t2 = Ia2(t2, Va2);
  const e = Ia2(t2.firestore, La2), n = qa2(e), s = new dh(e);
  return ua2(n, t2._query, {
    source: "server"
  }).then((n2) => new Fu(e, s, t2, n2));
}
function ph(t2, e, n) {
  t2 = Ia2(t2, va);
  const s = Ia2(t2.firestore, La2), i = ah(t2.converter, e, n);
  return bh(s, [du(fu(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, Ye.none())]);
}
function Th(t2, e, n, ...s) {
  t2 = Ia2(t2, va);
  const i = Ia2(t2.firestore, La2), r = fu(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof eu ? Eu(r, "updateDoc", t2._key, e, n, s) : Tu(r, "updateDoc", t2._key, e);
  return bh(i, [o.toMutation(t2._key, Ye.exists(true))]);
}
function Eh(t2) {
  return bh(Ia2(t2.firestore, La2), [new ln(t2._key, Ye.none())]);
}
function Ih(t2, e) {
  const n = Ia2(t2.firestore, La2), s = Na2(t2), i = ah(t2.converter, e);
  return bh(n, [du(fu(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, Ye.exists(false))]).then(() => s);
}
function Ah(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || Oa(e[o]) || (r = e[o], o++);
  const c = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (Oa(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let a, u, h;
  if (t2 instanceof va)
    u = Ia2(t2.firestore, La2), h = ye(t2._key.path), a = {
      next: (n2) => {
        e[o] && e[o](Ph(u, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = Ia2(t2, Va2);
    u = Ia2(n2.firestore, La2), h = n2._query;
    const s2 = new dh(u);
    a = {
      next: (t3) => {
        e[o] && e[o](new Fu(u, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Uu(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new jc2(s2), r2 = new Jo(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Qo(await sa2(t3), r2)), () => {
      i2.nc(), t3.asyncQueue.enqueueAndForget(async () => Wo(await sa2(t3), r2));
    };
  }(qa2(u), h, c, a);
}
function Rh(t2, e) {
  return ha2(qa2(t2 = Ia2(t2, La2)), Oa(e) ? e : {
    next: e
  });
}
function bh(t2, e) {
  return function(t3, e2) {
    const n = new W2();
    return t3.asyncQueue.enqueueAndForget(async () => hc2(await na2(t3), e2, n)), n.promise;
  }(qa2(t2), e);
}
function Ph(t2, e, n) {
  const s = n.docs.get(e._key), i = new dh(t2);
  return new Ou(t2, i, e._key, s, new $u(n.hasPendingWrites, n.fromCache), e.converter);
}
var vh = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = fu(t2);
  }
  get(t2) {
    const e = lh(t2, this._firestore), n = new uh(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return B2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new Nu(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new Nu(this._firestore, n, e._key, null, e.converter);
      throw B2();
    });
  }
  set(t2, e, n) {
    const s = lh(t2, this._firestore), i = ah(s.converter, e, n), r = du(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = lh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof eu ? Eu(this._dataReader, "Transaction.update", i._key, e, n, s) : Tu(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = lh(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = lh(t2, this._firestore), n = new dh(this._firestore);
    return super.get(t2).then((t3) => new Ou(this._firestore, n, e._key, t3._document, new $u(false, false), e.converter));
  }
};
function Vh(t2, e) {
  return la2(qa2(t2 = Ia2(t2, La2)), (n) => e(new vh(t2, n)));
}
function Sh() {
  return new wu("deleteField");
}
function Dh() {
  return new mu("serverTimestamp");
}
function Ch(...t2) {
  return new gu("arrayUnion", t2);
}
function Nh(...t2) {
  return new yu("arrayRemove", t2);
}
function kh(t2) {
  return new pu("increment", t2);
}
function xh(t2) {
  return qa2(t2 = Ia2(t2, La2)), new hh(t2, (e) => bh(t2, e));
}
var Oh = class {
  constructor(t2, e) {
    this.fieldPath = t2, this.kind = e;
  }
};
function Mh(t2, e) {
  qa2(t2 = Ia2(t2, La2));
  const n = typeof e == "string" ? function(t3) {
    try {
      return JSON.parse(t3);
    } catch (t4) {
      throw new Q2(j.INVALID_ARGUMENT, "Failed to parse JSON:" + t4.message);
    }
  }(e) : e;
  if (Array.isArray(n.indexes))
    for (const t3 of n.indexes) {
      Fh(t3, "collectionGroup");
      const n2 = [];
      if (Array.isArray(t3.fields))
        for (const e2 of t3.fields) {
          const t4 = Su("setIndexConfiguration", Fh(e2, "fieldPath"));
          e2.arrayConfig === "CONTAINS" ? n2.push(new Oh(t4, 2)) : e2.order === "ASCENDING" ? n2.push(new Oh(t4, 0)) : e2.order === "DESCENDING" && n2.push(new Oh(t4, 1));
        }
    }
  return Promise.resolve();
}
function Fh(t2, e) {
  if (typeof t2[e] != "string")
    throw new Q2(j.INVALID_ARGUMENT, "Missing string value for: " + e);
  return t2[e];
}
!function(t2, e = true) {
  !function(t3) {
    N2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n }) => {
    const s = t3.getProvider("app").getImmediate(), i = new La2(s, new J2(t3.getProvider("auth-internal")), new tt(t3.getProvider("app-check-internal")));
    return n = Object.assign({
      useFetchStreams: e
    }, n), i._setSettings(n), i;
  }, "PUBLIC")), registerVersion(D2, "3.4.4", t2), registerVersion(D2, "3.4.4", "esm2017");
}();
export {
  ch as AbstractUserDataWriter,
  su as Bytes,
  Fa2 as CACHE_SIZE_UNLIMITED,
  Sa2 as CollectionReference,
  va as DocumentReference,
  Ou as DocumentSnapshot,
  eu as FieldPath,
  iu as FieldValue,
  La2 as Firestore,
  Q2 as FirestoreError,
  ru as GeoPoint,
  Ma2 as LoadBundleTask,
  Va2 as Query,
  qu as QueryConstraint,
  Mu as QueryDocumentSnapshot,
  Fu as QuerySnapshot,
  $u as SnapshotMetadata,
  at as Timestamp,
  vh as Transaction,
  hh as WriteBatch,
  _a as _DatabaseId,
  Dt as _DocumentKey,
  et as _EmptyAppCheckTokenProvider,
  z2 as _EmptyAuthCredentialsProvider,
  mt as _FieldPath,
  Ia2 as _cast,
  q2 as _debugAssert,
  yt as _isBase64Available,
  F2 as _logWarn,
  Mh as _setIndexConfiguration,
  ya2 as _validateIsNotUsedTogether,
  Ih as addDoc,
  Nh as arrayRemove,
  Ch as arrayUnion,
  Ga2 as clearIndexedDbPersistence,
  Da as collection,
  Ca2 as collectionGroup,
  Pa as connectFirestoreEmulator,
  Eh as deleteDoc,
  Sh as deleteField,
  Ja2 as disableNetwork,
  Na2 as doc,
  nu as documentId,
  ja2 as enableIndexedDbPersistence,
  Qa as enableMultiTabIndexedDbPersistence,
  Ha2 as enableNetwork,
  nh as endAt,
  eh as endBefore,
  qa2 as ensureFirestoreConfigured,
  bh as executeWrite,
  fh as getDoc,
  wh as getDocFromCache,
  _h as getDocFromServer,
  mh as getDocs,
  gh as getDocsFromCache,
  yh as getDocsFromServer,
  Ua2 as getFirestore,
  kh as increment,
  Ba as initializeFirestore,
  Hu as limit,
  Ju as limitToLast,
  Xa2 as loadBundle,
  Za2 as namedQuery,
  Ah as onSnapshot,
  Rh as onSnapshotsInSync,
  Gu as orderBy,
  Ku as query,
  xa2 as queryEqual,
  ka2 as refEqual,
  Vh as runTransaction,
  Dh as serverTimestamp,
  ph as setDoc,
  $ as setLogLevel,
  Bu as snapshotEqual,
  Zu as startAfter,
  Xu as startAt,
  Ya2 as terminate,
  Th as updateDoc,
  za2 as waitForPendingWrites,
  Qu as where,
  xh as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_firestore.js.map
