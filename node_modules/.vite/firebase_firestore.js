import {
  Component,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-KDWAVVL7.js";
import "./chunk-JHINRUCF.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  const d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (let f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    const c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (let e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  const b = a.length;
  if (0 < b) {
    const c = Array(b);
    for (let d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (const d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  const b = {};
  for (const c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    let a = 0;
    const b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (let h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  let b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b) {
    const c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var vb = new class {
  constructor(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new wb(), (a) => a.reset());
var wb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function yb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(() => {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  const b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = class extends v {
  constructor(a, b) {
    super();
    this.m = a;
    this.j = b;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  const b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  const b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  const b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          let m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              const r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              const G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              const Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const ca2 = a.g;
              if (ca2) {
                const Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = class {
  constructor(a, b) {
    this.h = a;
    this.g = b;
  }
};
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function jd(a) {
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    let b = a.i;
    for (const c of a.g.values())
      b = b.concat(c.D);
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  const d = c || "";
  try {
    Kc(a, function(e, f) {
      let h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  const c = new Mb();
  if (l.Image) {
    const d = new Image();
    d.onload = ja(od, c, d, "TestLoadImage: loaded", true, b);
    d.onerror = ja(od, c, d, "TestLoadImage: error", false, b);
    d.onabort = ja(od, c, d, "TestLoadImage: abort", false, b);
    d.ontimeout = ja(od, c, d, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  const e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        const n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  let b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        const e = new M(this, this.h, a, void 0);
        let f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  const d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  let c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  let d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    const e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e, f) {
    R(d, f, e);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (const c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = esm.ErrorCode = Wb;
var EventType = esm.EventType = Xb;
var Event = esm.Event = H;
var Stat = esm.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = pd;
var WebChannel = esm.WebChannel = $b;
var XhrIo = esm.XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var S2 = "@firebase/firestore";
var D2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
D2.UNAUTHENTICATED = new D2(null), D2.GOOGLE_CREDENTIALS = new D2("google-credentials-uid"), D2.FIRST_PARTY = new D2("first-party-uid"), D2.MOCK_USER = new D2("mock-user");
var C2 = "9.1.3";
var N2 = new Logger("@firebase/firestore");
function x2() {
  return N2.logLevel;
}
function k2(t2) {
  N2.setLogLevel(t2);
}
function $(t2, ...e) {
  if (N2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(M2);
    N2.debug(`Firestore (${C2}): ${t2}`, ...n);
  }
}
function O2(t2, ...e) {
  if (N2.logLevel <= LogLevel.ERROR) {
    const n = e.map(M2);
    N2.error(`Firestore (${C2}): ${t2}`, ...n);
  }
}
function F2(t2, ...e) {
  if (N2.logLevel <= LogLevel.WARN) {
    const n = e.map(M2);
    N2.warn(`Firestore (${C2}): ${t2}`, ...n);
  }
}
function M2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function L2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${C2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw O2(e), new Error(e);
}
function B2(t2, e) {
  t2 || L2();
}
function U2(t2, e) {
  t2 || L2();
}
function q2(t2, e) {
  return t2;
}
var K2 = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var j = class extends Error {
  constructor(t2, e) {
    super(e), this.code = t2, this.message = e, this.name = "FirebaseError", this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var Q2 = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var W2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.authHeaders = {}, this.authHeaders.Authorization = `Bearer ${t2}`;
  }
};
var G = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(D2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var z2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var H2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = D2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new Q2();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new Q2(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      $("FirebaseCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : ($("FirebaseCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new Q2());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? ($("FirebaseCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (B2(typeof e2.accessToken == "string"), new W2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return B2(t2 === null || typeof t2 == "string"), new D2(t2);
  }
};
var J2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n, this.type = "FirstParty", this.user = D2.FIRST_PARTY;
  }
  get authHeaders() {
    const t2 = {
      "X-Goog-AuthUser": this.l
    }, e = this.h.auth.getAuthHeaderValueForFirstParty([]);
    return e && (t2.Authorization = e), this.m && (t2["X-Goog-Iam-Authorization-Token"] = this.m), t2;
  }
};
var Y2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new J2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(D2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var X2 = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.g(t3), this.p = (t3) => e.writeSequenceNumber(t3));
  }
  g(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.p && this.p(t2), t2;
  }
};
function Z2(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
X2.T = -1;
var tt = class {
  static I() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = Z2(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function et(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function nt(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function st(t2) {
  return t2 + "\0";
}
var it = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new j(K2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new j(K2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new j(K2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new j(K2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return it.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return it.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new it(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? et(this.nanoseconds, t2.nanoseconds) : et(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var rt = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new rt(t2);
  }
  static min() {
    return new rt(new it(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function ot(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function at(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function ct(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var ut = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && L2(), n === void 0 ? n = t2.length - e : n > t2.length - e && L2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return ut.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof ut ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var ht = class extends ut {
  construct(t2, e, n) {
    return new ht(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new j(K2.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new ht(e);
  }
  static emptyPath() {
    return new ht([]);
  }
};
var lt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var ft = class extends ut {
  construct(t2, e, n) {
    return new ft(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return lt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ft.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new ft(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new j(K2.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new j(K2.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new j(K2.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new j(K2.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new ft(e);
  }
  static emptyPath() {
    return new ft([]);
  }
};
var dt = class {
  constructor(t2) {
    this.fields = t2, t2.sort(ft.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return nt(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function wt() {
  return typeof atob != "undefined";
}
var _t = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new _t(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new _t(e);
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return et(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
_t.EMPTY_BYTE_STRING = new _t("");
var mt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function gt(t2) {
  if (B2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = mt.exec(t2);
    if (B2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: yt(t2.seconds),
    nanos: yt(t2.nanos)
  };
}
function yt(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function pt(t2) {
  return typeof t2 == "string" ? _t.fromBase64String(t2) : _t.fromUint8Array(t2);
}
function Tt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function Et(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Tt(e) ? Et(e) : e;
}
function It(t2) {
  const e = gt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new it(e.seconds, e.nanos);
}
function At(t2) {
  return t2 == null;
}
function Rt(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function bt(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !Rt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var Pt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new Pt(ht.fromString(t2));
  }
  static fromName(t2) {
    return new Pt(ht.fromString(t2).popFirst(5));
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  isEqual(t2) {
    return t2 !== null && ht.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return ht.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new Pt(new ht(t2.slice()));
  }
};
function vt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Tt(t2) ? 4 : 10 : L2();
}
function Vt(t2, e) {
  const n = vt(t2);
  if (n !== vt(e))
    return false;
  switch (n) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return It(t2).isEqual(It(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = gt(t3.timestampValue), s = gt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return pt(t3.bytesValue).isEqual(pt(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return yt(t3.geoPointValue.latitude) === yt(e2.geoPointValue.latitude) && yt(t3.geoPointValue.longitude) === yt(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return yt(t3.integerValue) === yt(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = yt(t3.doubleValue), s = yt(e2.doubleValue);
          return n2 === s ? Rt(n2) === Rt(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return nt(t2.arrayValue.values || [], e.arrayValue.values || [], Vt);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (ot(n2) !== ot(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !Vt(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return L2();
  }
}
function St(t2, e) {
  return (t2.values || []).find((t3) => Vt(t3, e)) !== void 0;
}
function Dt(t2, e) {
  const n = vt(t2), s = vt(e);
  if (n !== s)
    return et(n, s);
  switch (n) {
    case 0:
      return 0;
    case 1:
      return et(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = yt(t3.integerValue || t3.doubleValue), s2 = yt(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return Ct(t2.timestampValue, e.timestampValue);
    case 4:
      return Ct(It(t2), It(e));
    case 5:
      return et(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = pt(t3), s2 = pt(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = et(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return et(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = et(yt(t3.latitude), yt(e2.latitude));
        if (n2 !== 0)
          return n2;
        return et(yt(t3.longitude), yt(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = Dt(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return et(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = et(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = Dt(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return et(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw L2();
  }
}
function Ct(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return et(t2, e);
  const n = gt(t2), s = gt(e), i = et(n.seconds, s.seconds);
  return i !== 0 ? i : et(n.nanos, s.nanos);
}
function Nt(t2) {
  return xt(t2);
}
function xt(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = gt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? pt(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, Pt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += xt(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${xt(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : L2();
  var e, n;
}
function kt(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function $t(t2) {
  return !!t2 && "integerValue" in t2;
}
function Ot(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Ft(t2) {
  return !!t2 && "nullValue" in t2;
}
function Mt(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Lt(t2) {
  return !!t2 && "mapValue" in t2;
}
function Bt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return at(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Bt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Bt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
var Ut = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new Ut({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Lt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Bt(e);
  }
  setAll(t2) {
    let e = ft.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Bt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Lt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Vt(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Lt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    at(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new Ut(Bt(this.value));
  }
};
function qt(t2) {
  const e = [];
  return at(t2.fields, (t3, n) => {
    const s = new ft([t3]);
    if (Lt(n)) {
      const t4 = qt(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new dt(e);
}
var Kt = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.documentType = e, this.version = n, this.data = s, this.documentState = i;
  }
  static newInvalidDocument(t2) {
    return new Kt(t2, 0, rt.min(), Ut.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new Kt(t2, 1, e, n, 0);
  }
  static newNoDocument(t2, e) {
    return new Kt(t2, 2, e, Ut.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new Kt(t2, 3, e, Ut.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = Ut.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = Ut.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof Kt && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  clone() {
    return new Kt(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var jt = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.A = null;
  }
};
function Qt(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new jt(t2, e, n, s, i, r, o);
}
function Wt(t2) {
  const e = q2(t2);
  if (e.A === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => Yt(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), At(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += ae(e.startAt)), e.endAt && (t3 += "|ub:", t3 += ae(e.endAt)), e.A = t3;
  }
  return e.A;
}
function Gt(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Nt(e2.value)}`;
    var e2;
  }).join(", ")}]`), At(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: " + ae(t2.startAt)), t2.endAt && (e += ", endAt: " + ae(t2.endAt)), `Target(${e})`;
}
function zt(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!ue(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !Vt(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!le(t2.startAt, e.startAt) && le(t2.endAt, e.endAt)));
}
function Ht(t2) {
  return Pt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
var Jt = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.R(t2, e, n) : new Xt(t2, e, n) : e === "array-contains" ? new ne(t2, n) : e === "in" ? new se(t2, n) : e === "not-in" ? new ie(t2, n) : e === "array-contains-any" ? new re(t2, n) : new Jt(t2, e, n);
  }
  static R(t2, e, n) {
    return e === "in" ? new Zt(t2, n) : new te(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.P(Dt(e, this.value)) : e !== null && vt(this.value) === vt(e) && this.P(Dt(e, this.value));
  }
  P(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L2();
    }
  }
  v() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
function Yt(t2) {
  return t2.field.canonicalString() + t2.op.toString() + Nt(t2.value);
}
var Xt = class extends Jt {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = Pt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = Pt.comparator(t2.key, this.key);
    return this.P(e);
  }
};
var Zt = class extends Jt {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = ee("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var te = class extends Jt {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = ee("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function ee(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => Pt.fromName(t3.referenceValue));
}
var ne = class extends Jt {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return Ot(e) && St(e.arrayValue, this.value);
  }
};
var se = class extends Jt {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && St(this.value.arrayValue, e);
  }
};
var ie = class extends Jt {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (St(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !St(this.value.arrayValue, e);
  }
};
var re = class extends Jt {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!Ot(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => St(this.value.arrayValue, t3));
  }
};
var oe = class {
  constructor(t2, e) {
    this.position = t2, this.before = e;
  }
};
function ae(t2) {
  return `${t2.before ? "b" : "a"}:${t2.position.map((t3) => Nt(t3)).join(",")}`;
}
var ce = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function ue(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function he(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = Pt.comparator(Pt.fromName(o.referenceValue), n.key);
    else {
      s = Dt(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return t2.before ? s <= 0 : s < 0;
}
function le(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.before !== e.before || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Vt(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var fe = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, a = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = a, this.V = null, this.S = null, this.startAt, this.endAt;
  }
};
function de(t2, e, n, s, i, r, o, a) {
  return new fe(t2, e, n, s, i, r, o, a);
}
function we(t2) {
  return new fe(t2);
}
function _e(t2) {
  return !At(t2.limit) && t2.limitType === "F";
}
function me(t2) {
  return !At(t2.limit) && t2.limitType === "L";
}
function ge(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function ye(t2) {
  for (const e of t2.filters)
    if (e.v())
      return e.field;
  return null;
}
function pe(t2) {
  return t2.collectionGroup !== null;
}
function Te(t2) {
  const e = q2(t2);
  if (e.V === null) {
    e.V = [];
    const t3 = ye(e), n = ge(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.V.push(new ce(t3)), e.V.push(new ce(ft.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.V.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.V.push(new ce(ft.keyField(), t5));
      }
    }
  }
  return e.V;
}
function Ee(t2) {
  const e = q2(t2);
  if (!e.S)
    if (e.limitType === "F")
      e.S = Qt(e.path, e.collectionGroup, Te(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of Te(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new ce(n2.field, e2));
      }
      const n = e.endAt ? new oe(e.endAt.position, !e.endAt.before) : null, s = e.startAt ? new oe(e.startAt.position, !e.startAt.before) : null;
      e.S = Qt(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.S;
}
function Ie(t2, e, n) {
  return new fe(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function Ae(t2, e) {
  return zt(Ee(t2), Ee(e)) && t2.limitType === e.limitType;
}
function Re(t2) {
  return `${Wt(Ee(t2))}|lt:${t2.limitType}`;
}
function be(t2) {
  return `Query(target=${Gt(Ee(t2))}; limitType=${t2.limitType})`;
}
function Pe(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : Pt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !he(t3.startAt, Te(t3), e2))
      return false;
    if (t3.endAt && he(t3.endAt, Te(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function ve(t2) {
  return (e, n) => {
    let s = false;
    for (const i of Te(t2)) {
      const t3 = Ve(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function Ve(t2, e, n) {
  const s = t2.field.isKeyField() ? Pt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? Dt(s2, i) : L2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L2();
  }
}
function Se(t2, e) {
  if (t2.D) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: Rt(e) ? "-0" : e
  };
}
function De(t2) {
  return {
    integerValue: "" + t2
  };
}
function Ce(t2, e) {
  return bt(e) ? De(e) : Se(t2, e);
}
var Ne = class {
  constructor() {
    this._ = void 0;
  }
};
function xe(t2, e, n) {
  return t2 instanceof Oe ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Fe ? Me(t2, e) : t2 instanceof Le ? Be(t2, e) : function(t3, e2) {
    const n2 = $e(t3, e2), s = qe(n2) + qe(t3.C);
    return $t(n2) && $t(t3.C) ? De(s) : Se(t3.N, s);
  }(t2, e);
}
function ke(t2, e, n) {
  return t2 instanceof Fe ? Me(t2, e) : t2 instanceof Le ? Be(t2, e) : n;
}
function $e(t2, e) {
  return t2 instanceof Ue ? $t(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var Oe = class extends Ne {
};
var Fe = class extends Ne {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Me(t2, e) {
  const n = Ke(e);
  for (const e2 of t2.elements)
    n.some((t3) => Vt(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var Le = class extends Ne {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Be(t2, e) {
  let n = Ke(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Vt(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var Ue = class extends Ne {
  constructor(t2, e) {
    super(), this.N = t2, this.C = e;
  }
};
function qe(t2) {
  return yt(t2.integerValue || t2.doubleValue);
}
function Ke(t2) {
  return Ot(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var je = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function Qe(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Fe && e2 instanceof Fe || t3 instanceof Le && e2 instanceof Le ? nt(t3.elements, e2.elements, Vt) : t3 instanceof Ue && e2 instanceof Ue ? Vt(t3.C, e2.C) : t3 instanceof Oe && e2 instanceof Oe;
  }(t2.transform, e.transform);
}
var We = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var Ge = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new Ge();
  }
  static exists(t2) {
    return new Ge(void 0, t2);
  }
  static updateTime(t2) {
    return new Ge(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function ze(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var He = class {
};
function Je(t2, e, n) {
  t2 instanceof en ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = rn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof nn ? function(t3, e2, n2) {
    if (!ze(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = rn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(sn(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function Ye(t2, e, n) {
  t2 instanceof en ? function(t3, e2, n2) {
    if (!ze(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = on(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(tn(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof nn ? function(t3, e2, n2) {
    if (!ze(t3.precondition, e2))
      return;
    const s = on(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(sn(t3)), i.setAll(s), e2.convertToFoundDocument(tn(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    ze(t3.precondition, e2) && e2.convertToNoDocument(rt.min());
  }(t2, e);
}
function Xe(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = $e(s.transform, t3 || null);
    i != null && (n == null && (n = Ut.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Ze(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && nt(t3, e2, (t4, e3) => Qe(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function tn(t2) {
  return t2.isFoundDocument() ? t2.version : rt.min();
}
var en = class extends He {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var nn = class extends He {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function sn(t2) {
  const e = new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function rn(t2, e, n) {
  const s = new Map();
  B2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, a = e.data.field(r.field);
    s.set(r.field, ke(o, a, n[i]));
  }
  return s;
}
function on(t2, e, n) {
  const s = new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, xe(t3, r, e));
  }
  return s;
}
var an = class extends He {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var cn = class extends He {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var un = class {
  constructor(t2) {
    this.count = t2;
  }
};
var hn;
var ln;
function fn(t2) {
  switch (t2) {
    default:
      return L2();
    case K2.CANCELLED:
    case K2.UNKNOWN:
    case K2.DEADLINE_EXCEEDED:
    case K2.RESOURCE_EXHAUSTED:
    case K2.INTERNAL:
    case K2.UNAVAILABLE:
    case K2.UNAUTHENTICATED:
      return false;
    case K2.INVALID_ARGUMENT:
    case K2.NOT_FOUND:
    case K2.ALREADY_EXISTS:
    case K2.PERMISSION_DENIED:
    case K2.FAILED_PRECONDITION:
    case K2.ABORTED:
    case K2.OUT_OF_RANGE:
    case K2.UNIMPLEMENTED:
    case K2.DATA_LOSS:
      return true;
  }
}
function dn(t2) {
  if (t2 === void 0)
    return O2("GRPC error has no .code"), K2.UNKNOWN;
  switch (t2) {
    case hn.OK:
      return K2.OK;
    case hn.CANCELLED:
      return K2.CANCELLED;
    case hn.UNKNOWN:
      return K2.UNKNOWN;
    case hn.DEADLINE_EXCEEDED:
      return K2.DEADLINE_EXCEEDED;
    case hn.RESOURCE_EXHAUSTED:
      return K2.RESOURCE_EXHAUSTED;
    case hn.INTERNAL:
      return K2.INTERNAL;
    case hn.UNAVAILABLE:
      return K2.UNAVAILABLE;
    case hn.UNAUTHENTICATED:
      return K2.UNAUTHENTICATED;
    case hn.INVALID_ARGUMENT:
      return K2.INVALID_ARGUMENT;
    case hn.NOT_FOUND:
      return K2.NOT_FOUND;
    case hn.ALREADY_EXISTS:
      return K2.ALREADY_EXISTS;
    case hn.PERMISSION_DENIED:
      return K2.PERMISSION_DENIED;
    case hn.FAILED_PRECONDITION:
      return K2.FAILED_PRECONDITION;
    case hn.ABORTED:
      return K2.ABORTED;
    case hn.OUT_OF_RANGE:
      return K2.OUT_OF_RANGE;
    case hn.UNIMPLEMENTED:
      return K2.UNIMPLEMENTED;
    case hn.DATA_LOSS:
      return K2.DATA_LOSS;
    default:
      return L2();
  }
}
(ln = hn || (hn = {}))[ln.OK = 0] = "OK", ln[ln.CANCELLED = 1] = "CANCELLED", ln[ln.UNKNOWN = 2] = "UNKNOWN", ln[ln.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", ln[ln.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", ln[ln.NOT_FOUND = 5] = "NOT_FOUND", ln[ln.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", ln[ln.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", ln[ln.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", ln[ln.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", ln[ln.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", ln[ln.ABORTED = 10] = "ABORTED", ln[ln.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", ln[ln.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", ln[ln.INTERNAL = 13] = "INTERNAL", ln[ln.UNAVAILABLE = 14] = "UNAVAILABLE", ln[ln.DATA_LOSS = 15] = "DATA_LOSS";
var wn = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || mn.EMPTY;
  }
  insert(t2, e) {
    return new wn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, mn.BLACK, null, null));
  }
  remove(t2) {
    return new wn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, mn.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new _n(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new _n(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new _n(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new _n(this.root, t2, this.comparator, true);
  }
};
var _n = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var mn = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : mn.RED, this.left = s != null ? s : mn.EMPTY, this.right = i != null ? i : mn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new mn(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return mn.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return mn.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, mn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, mn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L2();
    if (this.right.isRed())
      throw L2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
mn.EMPTY = null, mn.RED = true, mn.BLACK = false;
mn.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L2();
  }
  get value() {
    throw L2();
  }
  get color() {
    throw L2();
  }
  get left() {
    throw L2();
  }
  get right() {
    throw L2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new mn(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var gn = class {
  constructor(t2) {
    this.comparator = t2, this.data = new wn(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new yn(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new yn(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof gn))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new gn(this.comparator);
    return e.data = t2, e;
  }
};
var yn = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
var pn = new wn(Pt.comparator);
function Tn() {
  return pn;
}
var En = new wn(Pt.comparator);
function In() {
  return En;
}
var An = new wn(Pt.comparator);
function Rn() {
  return An;
}
var bn = new gn(Pt.comparator);
function Pn(...t2) {
  let e = bn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var vn = new gn(et);
function Vn() {
  return vn;
}
var Sn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = new Map();
    return n.set(t2, Dn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new Sn(rt.min(), n, Vn(), Tn(), Pn());
  }
};
var Dn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new Dn(_t.EMPTY_BYTE_STRING, e, Pn(), Pn(), Pn());
  }
};
var Cn = class {
  constructor(t2, e, n, s) {
    this.k = t2, this.removedTargetIds = e, this.key = n, this.$ = s;
  }
};
var Nn = class {
  constructor(t2, e) {
    this.targetId = t2, this.O = e;
  }
};
var xn = class {
  constructor(t2, e, n = _t.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var kn = class {
  constructor() {
    this.F = 0, this.M = Fn(), this.L = _t.EMPTY_BYTE_STRING, this.B = false, this.U = true;
  }
  get current() {
    return this.B;
  }
  get resumeToken() {
    return this.L;
  }
  get q() {
    return this.F !== 0;
  }
  get K() {
    return this.U;
  }
  j(t2) {
    t2.approximateByteSize() > 0 && (this.U = true, this.L = t2);
  }
  W() {
    let t2 = Pn(), e = Pn(), n = Pn();
    return this.M.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L2();
      }
    }), new Dn(this.L, this.B, t2, e, n);
  }
  G() {
    this.U = false, this.M = Fn();
  }
  H(t2, e) {
    this.U = true, this.M = this.M.insert(t2, e);
  }
  J(t2) {
    this.U = true, this.M = this.M.remove(t2);
  }
  Y() {
    this.F += 1;
  }
  X() {
    this.F -= 1;
  }
  Z() {
    this.U = true, this.B = true;
  }
};
var $n = class {
  constructor(t2) {
    this.tt = t2, this.et = new Map(), this.nt = Tn(), this.st = On(), this.it = new gn(et);
  }
  rt(t2) {
    for (const e of t2.k)
      t2.$ && t2.$.isFoundDocument() ? this.ot(e, t2.$) : this.at(e, t2.key, t2.$);
    for (const e of t2.removedTargetIds)
      this.at(e, t2.key, t2.$);
  }
  ct(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.ut(e);
      switch (t2.state) {
        case 0:
          this.ht(e) && n.j(t2.resumeToken);
          break;
        case 1:
          n.X(), n.q || n.G(), n.j(t2.resumeToken);
          break;
        case 2:
          n.X(), n.q || this.removeTarget(e);
          break;
        case 3:
          this.ht(e) && (n.Z(), n.j(t2.resumeToken));
          break;
        case 4:
          this.ht(e) && (this.lt(e), n.j(t2.resumeToken));
          break;
        default:
          L2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.et.forEach((t3, n) => {
      this.ht(n) && e(n);
    });
  }
  ft(t2) {
    const e = t2.targetId, n = t2.O.count, s = this.dt(e);
    if (s) {
      const t3 = s.target;
      if (Ht(t3))
        if (n === 0) {
          const n2 = new Pt(t3.path);
          this.at(e, n2, Kt.newNoDocument(n2, rt.min()));
        } else
          B2(n === 1);
      else {
        this.wt(e) !== n && (this.lt(e), this.it = this.it.add(e));
      }
    }
  }
  _t(t2) {
    const e = new Map();
    this.et.forEach((n2, s2) => {
      const i = this.dt(s2);
      if (i) {
        if (n2.current && Ht(i.target)) {
          const e2 = new Pt(i.target.path);
          this.nt.get(e2) !== null || this.gt(s2, e2) || this.at(s2, e2, Kt.newNoDocument(e2, t2));
        }
        n2.K && (e.set(s2, n2.W()), n2.G());
      }
    });
    let n = Pn();
    this.st.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.dt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    });
    const s = new Sn(t2, e, this.it, this.nt, n);
    return this.nt = Tn(), this.st = On(), this.it = new gn(et), s;
  }
  ot(t2, e) {
    if (!this.ht(t2))
      return;
    const n = this.gt(t2, e.key) ? 2 : 0;
    this.ut(t2).H(e.key, n), this.nt = this.nt.insert(e.key, e), this.st = this.st.insert(e.key, this.yt(e.key).add(t2));
  }
  at(t2, e, n) {
    if (!this.ht(t2))
      return;
    const s = this.ut(t2);
    this.gt(t2, e) ? s.H(e, 1) : s.J(e), this.st = this.st.insert(e, this.yt(e).delete(t2)), n && (this.nt = this.nt.insert(e, n));
  }
  removeTarget(t2) {
    this.et.delete(t2);
  }
  wt(t2) {
    const e = this.ut(t2).W();
    return this.tt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Y(t2) {
    this.ut(t2).Y();
  }
  ut(t2) {
    let e = this.et.get(t2);
    return e || (e = new kn(), this.et.set(t2, e)), e;
  }
  yt(t2) {
    let e = this.st.get(t2);
    return e || (e = new gn(et), this.st = this.st.insert(t2, e)), e;
  }
  ht(t2) {
    const e = this.dt(t2) !== null;
    return e || $("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  dt(t2) {
    const e = this.et.get(t2);
    return e && e.q ? null : this.tt.Tt(t2);
  }
  lt(t2) {
    this.et.set(t2, new kn());
    this.tt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.at(t2, e, null);
    });
  }
  gt(t2, e) {
    return this.tt.getRemoteKeysForTarget(t2).has(e);
  }
};
function On() {
  return new wn(Pt.comparator);
}
function Fn() {
  return new wn(Pt.comparator);
}
var Mn = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var Ln = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var Bn = class {
  constructor(t2, e) {
    this.databaseId = t2, this.D = e;
  }
};
function Un(t2, e) {
  if (t2.D) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function qn(t2, e) {
  return t2.D ? e.toBase64() : e.toUint8Array();
}
function Kn(t2, e) {
  return Un(t2, e.toTimestamp());
}
function jn(t2) {
  return B2(!!t2), rt.fromTimestamp(function(t3) {
    const e = gt(t3);
    return new it(e.seconds, e.nanos);
  }(t2));
}
function Qn(t2, e) {
  return function(t3) {
    return new ht(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Wn(t2) {
  const e = ht.fromString(t2);
  return B2(Ts(e)), e;
}
function Gn(t2, e) {
  return Qn(t2.databaseId, e.path);
}
function zn(t2, e) {
  const n = Wn(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new j(K2.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new j(K2.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new Pt(Xn(n));
}
function Hn(t2, e) {
  return Qn(t2.databaseId, e);
}
function Jn(t2) {
  const e = Wn(t2);
  return e.length === 4 ? ht.emptyPath() : Xn(e);
}
function Yn(t2) {
  return new ht(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Xn(t2) {
  return B2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function Zn(t2, e, n) {
  return {
    name: Gn(t2, e),
    fields: n.value.mapValue.fields
  };
}
function ts(t2, e, n) {
  const s = zn(t2, e.name), i = jn(e.updateTime), r = new Ut({
    mapValue: {
      fields: e.fields
    }
  }), o = Kt.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function es(t2, e) {
  return "found" in e ? function(t3, e2) {
    B2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = zn(t3, e2.found.name), s = jn(e2.found.updateTime), i = new Ut({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return Kt.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    B2(!!e2.missing), B2(!!e2.readTime);
    const n = zn(t3, e2.missing), s = jn(e2.readTime);
    return Kt.newNoDocument(n, s);
  }(t2, e) : L2();
}
function ns(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : L2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.D ? (B2(e2 === void 0 || typeof e2 == "string"), _t.fromBase64String(e2 || "")) : (B2(e2 === void 0 || e2 instanceof Uint8Array), _t.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, a = o && function(t3) {
      const e2 = t3.code === void 0 ? K2.UNKNOWN : dn(t3.code);
      return new j(e2, t3.message || "");
    }(o);
    n = new xn(s, i, r, a || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = zn(t2, s.document.name), r = jn(s.document.updateTime), o = new Ut({
      mapValue: {
        fields: s.document.fields
      }
    }), a = Kt.newFoundDocument(i, r, o), c = s.targetIds || [], u = s.removedTargetIds || [];
    n = new Cn(c, u, a.key, a);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = zn(t2, s.document), r = s.readTime ? jn(s.readTime) : rt.min(), o = Kt.newNoDocument(i, r), a = s.removedTargetIds || [];
    n = new Cn([], a, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = zn(t2, s.document), r = s.removedTargetIds || [];
    n = new Cn([], r, i, null);
  } else {
    if (!("filter" in e))
      return L2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new un(s), r = t3.targetId;
      n = new Nn(r, i);
    }
  }
  return n;
}
function ss(t2, e) {
  let n;
  if (e instanceof en)
    n = {
      update: Zn(t2, e.key, e.value)
    };
  else if (e instanceof an)
    n = {
      delete: Gn(t2, e.key)
    };
  else if (e instanceof nn)
    n = {
      update: Zn(t2, e.key, e.data),
      updateMask: ps(e.fieldMask)
    };
  else {
    if (!(e instanceof cn))
      return L2();
    n = {
      verify: Gn(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof Oe)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Fe)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Le)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Ue)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.C
      };
    throw L2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: Kn(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : L2();
  }(t2, e.precondition)), n;
}
function is(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? Ge.updateTime(jn(t3.updateTime)) : t3.exists !== void 0 ? Ge.exists(t3.exists) : Ge.none();
  }(e.currentDocument) : Ge.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      B2(e3.setToServerValue === "REQUEST_TIME"), n2 = new Oe();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Fe(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new Le(t4);
    } else
      "increment" in e3 ? n2 = new Ue(t3, e3.increment) : L2();
    const s2 = ft.fromServerFormat(e3.fieldPath);
    return new je(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = zn(t2, e.update.name), r = new Ut({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new dt(e2.map((t5) => ft.fromServerFormat(t5)));
      }(e.updateMask);
      return new nn(i, r, t3, n, s);
    }
    return new en(i, r, n, s);
  }
  if (e.delete) {
    const s2 = zn(t2, e.delete);
    return new an(s2, n);
  }
  if (e.verify) {
    const s2 = zn(t2, e.verify);
    return new cn(s2, n);
  }
  return L2();
}
function rs(t2, e) {
  return t2 && t2.length > 0 ? (B2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? jn(t4.updateTime) : jn(e2);
    return n.isEqual(rt.min()) && (n = jn(e2)), new We(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function os(t2, e) {
  return {
    documents: [Hn(t2, e.path)]
  };
}
function as(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = Hn(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = Hn(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (Mt(t5.value))
          return {
            unaryFilter: {
              field: _s(t5.field),
              op: "IS_NAN"
            }
          };
        if (Ft(t5.value))
          return {
            unaryFilter: {
              field: _s(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (Mt(t5.value))
          return {
            unaryFilter: {
              field: _s(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Ft(t5.value))
          return {
            unaryFilter: {
              field: _s(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: _s(t5.field),
          op: ws(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: _s(t5.field),
        direction: ds(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.D || At(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = ls(e.startAt)), e.endAt && (n.structuredQuery.endAt = ls(e.endAt)), n;
}
function cs(t2) {
  let e = Jn(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    B2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = hs(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new ce(ms(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let a = null;
  n.limit && (a = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, At(e2) ? null : e2;
  }(n.limit));
  let c = null;
  n.startAt && (c = fs(n.startAt));
  let u = null;
  return n.endAt && (u = fs(n.endAt)), de(e, i, o, r, a, "F", c, u);
}
function us(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function hs(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [ys(t2)] : t2.fieldFilter !== void 0 ? [gs(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => hs(t3)).reduce((t3, e) => t3.concat(e)) : L2() : [];
}
function ls(t2) {
  return {
    before: t2.before,
    values: t2.position
  };
}
function fs(t2) {
  const e = !!t2.before, n = t2.values || [];
  return new oe(n, e);
}
function ds(t2) {
  return Mn[t2];
}
function ws(t2) {
  return Ln[t2];
}
function _s(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function ms(t2) {
  return ft.fromServerFormat(t2.fieldPath);
}
function gs(t2) {
  return Jt.create(ms(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function ys(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = ms(t2.unaryFilter.field);
      return Jt.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = ms(t2.unaryFilter.field);
      return Jt.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = ms(t2.unaryFilter.field);
      return Jt.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = ms(t2.unaryFilter.field);
      return Jt.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L2();
  }
}
function ps(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function Ts(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function Es(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = As(e)), e = Is(t2.get(n), e);
  return As(e);
}
function Is(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function As(t2) {
  return t2 + "";
}
function Rs(t2) {
  const e = t2.length;
  if (B2(e >= 2), e === 2)
    return B2(t2.charAt(0) === "" && t2.charAt(1) === ""), ht.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && L2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        L2();
    }
    r = e2 + 2;
  }
  return new ht(s);
}
var bs = class {
  constructor(t2, e) {
    this.seconds = t2, this.nanoseconds = e;
  }
};
var Ps = class {
  constructor(t2, e, n) {
    this.ownerId = t2, this.allowTabSynchronization = e, this.leaseTimestampMs = n;
  }
};
Ps.store = "owner", Ps.key = "owner";
var vs = class {
  constructor(t2, e, n) {
    this.userId = t2, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;
  }
};
vs.store = "mutationQueues", vs.keyPath = "userId";
var Vs = class {
  constructor(t2, e, n, s, i) {
    this.userId = t2, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = s, this.mutations = i;
  }
};
Vs.store = "mutations", Vs.keyPath = "batchId", Vs.userMutationsIndex = "userMutationsIndex", Vs.userMutationsKeyPath = ["userId", "batchId"];
var Ss = class {
  constructor() {
  }
  static prefixForUser(t2) {
    return [t2];
  }
  static prefixForPath(t2, e) {
    return [t2, Es(e)];
  }
  static key(t2, e, n) {
    return [t2, Es(e), n];
  }
};
Ss.store = "documentMutations", Ss.PLACEHOLDER = new Ss();
var Ds = class {
  constructor(t2, e) {
    this.path = t2, this.readTime = e;
  }
};
var Cs = class {
  constructor(t2, e) {
    this.path = t2, this.version = e;
  }
};
var Ns = class {
  constructor(t2, e, n, s, i, r) {
    this.unknownDocument = t2, this.noDocument = e, this.document = n, this.hasCommittedMutations = s, this.readTime = i, this.parentPath = r;
  }
};
Ns.store = "remoteDocuments", Ns.readTimeIndex = "readTimeIndex", Ns.readTimeIndexPath = "readTime", Ns.collectionReadTimeIndex = "collectionReadTimeIndex", Ns.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var xs = class {
  constructor(t2) {
    this.byteSize = t2;
  }
};
xs.store = "remoteDocumentGlobal", xs.key = "remoteDocumentGlobalKey";
var ks = class {
  constructor(t2, e, n, s, i, r, o) {
    this.targetId = t2, this.canonicalId = e, this.readTime = n, this.resumeToken = s, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = r, this.query = o;
  }
};
ks.store = "targets", ks.keyPath = "targetId", ks.queryTargetsIndexName = "queryTargetsIndex", ks.queryTargetsKeyPath = ["canonicalId", "targetId"];
var $s = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.path = e, this.sequenceNumber = n;
  }
};
$s.store = "targetDocuments", $s.keyPath = ["targetId", "path"], $s.documentTargetsIndex = "documentTargetsIndex", $s.documentTargetsKeyPath = ["path", "targetId"];
var Os = class {
  constructor(t2, e, n, s) {
    this.highestTargetId = t2, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = s;
  }
};
Os.key = "targetGlobalKey", Os.store = "targetGlobal";
var Fs = class {
  constructor(t2, e) {
    this.collectionId = t2, this.parent = e;
  }
};
Fs.store = "collectionParents", Fs.keyPath = ["collectionId", "parent"];
var Ms = class {
  constructor(t2, e, n, s) {
    this.clientId = t2, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = s;
  }
};
Ms.store = "clientMetadata", Ms.keyPath = "clientId";
var Ls = class {
  constructor(t2, e, n) {
    this.bundleId = t2, this.createTime = e, this.version = n;
  }
};
Ls.store = "bundles", Ls.keyPath = "bundleId";
var Bs = class {
  constructor(t2, e, n) {
    this.name = t2, this.readTime = e, this.bundledQuery = n;
  }
};
Bs.store = "namedQueries", Bs.keyPath = "name";
var Us = [...[...[...[...[vs.store, Vs.store, Ss.store, Ns.store, ks.store, Ps.store, Os.store, $s.store], Ms.store], xs.store], Fs.store], Ls.store, Bs.store];
var qs = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var Ks = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var js = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && L2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new js((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof js ? e : js.resolve(e);
    } catch (t3) {
      return js.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : js.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : js.reject(e);
  }
  static resolve(t2) {
    return new js((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new js((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new js((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = js.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? js.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var Qs = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.Et = new Q2(), this.transaction.oncomplete = () => {
      this.Et.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.Et.reject(new zs(t2, e.error)) : this.Et.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = Zs(e2.target.error);
      this.Et.reject(new zs(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new Qs(e, t2.transaction(s, n));
    } catch (t3) {
      throw new zs(e, t3);
    }
  }
  get It() {
    return this.Et.promise;
  }
  abort(t2) {
    t2 && this.Et.reject(t2), this.aborted || ($("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new Js(e);
  }
};
var Ws = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.At = n;
    Ws.Rt(getUA()) === 12.2 && O2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return $("SimpleDb", "Removing database:", t2), Ys(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static bt() {
    if (!isIndexedDBAvailable())
      return false;
    if (Ws.Pt())
      return true;
    const t2 = getUA(), e = Ws.Rt(t2), n = 0 < e && e < 10, s = Ws.vt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static Pt() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Vt) === "YES";
  }
  static St(t2, e) {
    return t2.store(e);
  }
  static Rt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static vt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async Dt(t2) {
    return this.db || ($("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new zs(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new j(K2.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : s2.name === "InvalidStateError" ? n(new j(K2.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new zs(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        $("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.At.Ct(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          $("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Nt && (this.db.onversionchange = (t3) => this.Nt(t3)), this.db;
  }
  xt(t2) {
    this.Nt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.Dt(t2);
        const e2 = Qs.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).catch((t3) => (e2.abort(t3), js.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.It, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if ($("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var Gs = class {
  constructor(t2) {
    this.kt = t2, this.$t = false, this.Ot = null;
  }
  get isDone() {
    return this.$t;
  }
  get Ft() {
    return this.Ot;
  }
  set cursor(t2) {
    this.kt = t2;
  }
  done() {
    this.$t = true;
  }
  Mt(t2) {
    this.Ot = t2;
  }
  delete() {
    return Ys(this.kt.delete());
  }
};
var zs = class extends j {
  constructor(t2, e) {
    super(K2.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Hs(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var Js = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? ($("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : ($("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), Ys(n);
  }
  add(t2) {
    $("SimpleDb", "ADD", this.store.name, t2, t2);
    return Ys(this.store.add(t2));
  }
  get(t2) {
    return Ys(this.store.get(t2)).next((e) => (e === void 0 && (e = null), $("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    $("SimpleDb", "DELETE", this.store.name, t2);
    return Ys(this.store.delete(t2));
  }
  count() {
    $("SimpleDb", "COUNT", this.store.name);
    return Ys(this.store.count());
  }
  Lt(t2, e) {
    const n = this.cursor(this.options(t2, e)), s = [];
    return this.Bt(n, (t3, e2) => {
      s.push(e2);
    }).next(() => s);
  }
  Ut(t2, e) {
    $("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.qt = false;
    const s = this.cursor(n);
    return this.Bt(s, (t3, e2, n2) => n2.delete());
  }
  Kt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Bt(s, e);
  }
  jt(t2) {
    const e = this.cursor({});
    return new js((n, s) => {
      e.onerror = (t3) => {
        const e2 = Zs(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Bt(t2, e) {
    const n = [];
    return new js((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new Gs(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof js) {
          const t4 = o.catch((t5) => (r.done(), js.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Ft === null ? i2.continue() : i2.continue(r.Ft);
      };
    }).next(() => js.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.qt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function Ys(t2) {
  return new js((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = Zs(t3.target.error);
      n(e2);
    };
  });
}
var Xs = false;
function Zs(t2) {
  const e = Ws.Rt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new j("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Xs || (Xs = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var ti = class extends Ks {
  constructor(t2, e) {
    super(), this.Qt = t2, this.currentSequenceNumber = e;
  }
};
function ei(t2, e) {
  const n = q2(t2);
  return Ws.St(n.Qt, e);
}
var ni = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        Je(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && Ye(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && Ye(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(rt.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), Pn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && nt(this.mutations, t2.mutations, (t3, e) => Ze(t3, e)) && nt(this.baseMutations, t2.baseMutations, (t3, e) => Ze(t3, e));
  }
};
var si = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    B2(t2.mutations.length === n.length);
    let s = Rn();
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new si(t2, e, n, s);
  }
};
var ii = class {
  constructor(t2, e, n, s, i = rt.min(), r = rt.min(), o = _t.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new ii(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new ii(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new ii(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var ri = class {
  constructor(t2) {
    this.Wt = t2;
  }
};
function oi(t2, e) {
  if (e.document)
    return ts(t2.Wt, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    const t3 = Pt.fromSegments(e.noDocument.path), n = li(e.noDocument.readTime), s = Kt.newNoDocument(t3, n);
    return e.hasCommittedMutations ? s.setHasCommittedMutations() : s;
  }
  if (e.unknownDocument) {
    const t3 = Pt.fromSegments(e.unknownDocument.path), n = li(e.unknownDocument.version);
    return Kt.newUnknownDocument(t3, n);
  }
  return L2();
}
function ai(t2, e, n) {
  const s = ci(n), i = e.key.path.popLast().toArray();
  if (e.isFoundDocument()) {
    const n2 = function(t3, e2) {
      return {
        name: Gn(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Un(t3, e2.version.toTimestamp())
      };
    }(t2.Wt, e), r = e.hasCommittedMutations;
    return new Ns(null, null, n2, r, s, i);
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), n2 = hi(e.version), r = e.hasCommittedMutations;
    return new Ns(null, new Ds(t3, n2), null, r, s, i);
  }
  if (e.isUnknownDocument()) {
    const t3 = e.key.path.toArray(), n2 = hi(e.version);
    return new Ns(new Cs(t3, n2), null, null, true, s, i);
  }
  return L2();
}
function ci(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function ui(t2) {
  const e = new it(t2[0], t2[1]);
  return rt.fromTimestamp(e);
}
function hi(t2) {
  const e = t2.toTimestamp();
  return new bs(e.seconds, e.nanoseconds);
}
function li(t2) {
  const e = new it(t2.seconds, t2.nanoseconds);
  return rt.fromTimestamp(e);
}
function fi(t2, e) {
  const n = (e.baseMutations || []).map((e2) => is(t2.Wt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => is(t2.Wt, e2)), i = it.fromMillis(e.localWriteTimeMs);
  return new ni(e.batchId, i, n, s);
}
function di(t2) {
  const e = li(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? li(t2.lastLimboFreeSnapshotVersion) : rt.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (B2((i = t2.query).documents.length === 1), s = Ee(we(Jn(i.documents[0])))) : s = function(t3) {
    return Ee(cs(t3));
  }(t2.query), new ii(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, _t.fromBase64String(t2.resumeToken));
}
function wi(t2, e) {
  const n = hi(e.snapshotVersion), s = hi(e.lastLimboFreeSnapshotVersion);
  let i;
  i = Ht(e.target) ? os(t2.Wt, e.target) : as(t2.Wt, e.target);
  const r = e.resumeToken.toBase64();
  return new ks(e.targetId, Wt(e.target), n, r, e.sequenceNumber, s, i);
}
function _i(t2) {
  const e = cs({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Ie(e, e.limit, "L") : e;
}
var mi = class {
  getBundleMetadata(t2, e) {
    return gi(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: li(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return gi(t2).put({
      bundleId: (n = e).id,
      createTime: hi(jn(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return yi(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: _i(e2.bundledQuery),
          readTime: li(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return yi(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: hi(jn(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function gi(t2) {
  return ei(t2, Ls.store);
}
function yi(t2) {
  return ei(t2, Bs.store);
}
var pi = class {
  constructor() {
    this.Gt = new Ti();
  }
  addToCollectionParentIndex(t2, e) {
    return this.Gt.add(e), js.resolve();
  }
  getCollectionParents(t2, e) {
    return js.resolve(this.Gt.getEntries(e));
  }
};
var Ti = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new gn(ht.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new gn(ht.comparator)).toArray();
  }
};
var Ei = class {
  constructor() {
    this.zt = new Ti();
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.zt.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.zt.add(e);
      });
      const i = {
        collectionId: n,
        parent: Es(s)
      };
      return Ii(t2).put(i);
    }
    return js.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [st(e), ""], false, true);
    return Ii(t2).Lt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(Rs(s2.parent));
      }
      return n;
    });
  }
};
function Ii(t2) {
  return ei(t2, Fs.store);
}
var Ai = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var Ri = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new Ri(t2, Ri.DEFAULT_COLLECTION_PERCENTILE, Ri.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function bi(t2, e, n) {
  const s = t2.store(Vs.store), i = t2.store(Ss.store), r = [], o = IDBKeyRange.only(n.batchId);
  let a = 0;
  const c = s.Kt({
    range: o
  }, (t3, e2, n2) => (a++, n2.delete()));
  r.push(c.next(() => {
    B2(a === 1);
  }));
  const u = [];
  for (const t3 of n.mutations) {
    const s2 = Ss.key(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), u.push(t3.key);
  }
  return js.waitFor(r).next(() => u);
}
function Pi(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw L2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
Ri.DEFAULT_COLLECTION_PERCENTILE = 10, Ri.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Ri.DEFAULT = new Ri(41943040, Ri.DEFAULT_COLLECTION_PERCENTILE, Ri.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Ri.DISABLED = new Ri(-1, 0, 0);
var vi = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.N = e, this.Ht = n, this.referenceDelegate = s, this.Jt = {};
  }
  static Yt(t2, e, n, s) {
    B2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new vi(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return Si(t2).Kt({
      index: Vs.userMutationsIndex,
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = Di(t2), r = Si(t2);
    return r.add({}).next((o) => {
      B2(typeof o == "number");
      const a = new ni(o, e, n, s), c = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => ss(t3.Wt, e3)), i2 = n2.mutations.map((e3) => ss(t3.Wt, e3));
        return new Vs(e2, n2.batchId, n2.localWriteTime.toMillis(), s2, i2);
      }(this.N, this.userId, a), u = [];
      let h = new gn((t3, e2) => et(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = Ss.key(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), u.push(r.put(c)), u.push(i.put(e2, Ss.PLACEHOLDER));
      }
      return h.forEach((e2) => {
        u.push(this.Ht.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.Jt[o] = a.keys();
      }), js.waitFor(u).next(() => a);
    });
  }
  lookupMutationBatch(t2, e) {
    return Si(t2).get(e).next((t3) => t3 ? (B2(t3.userId === this.userId), fi(this.N, t3)) : null);
  }
  Xt(t2, e) {
    return this.Jt[e] ? js.resolve(this.Jt[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.Jt[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return Si(t2).Kt({
      index: Vs.userMutationsIndex,
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (B2(e2.batchId >= n), i = fi(this.N, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return Si(t2).Kt({
      index: Vs.userMutationsIndex,
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return Si(t2).Lt(Vs.userMutationsIndex, e).next((t3) => t3.map((t4) => fi(this.N, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = Ss.prefixForPath(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return Di(t2).Kt({
      range: s
    }, (n2, s2, r) => {
      const [o, a, c] = n2, u = Rs(a);
      if (o === this.userId && e.path.isEqual(u))
        return Si(t2).get(c).next((t3) => {
          if (!t3)
            throw L2();
          B2(t3.userId === this.userId), i.push(fi(this.N, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new gn(et);
    const s = [];
    return e.forEach((e2) => {
      const i = Ss.prefixForPath(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = Di(t2).Kt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, a] = t3, c = Rs(o2);
        r2 === this.userId && e2.path.isEqual(c) ? n = n.add(a) : i2.done();
      });
      s.push(o);
    }), js.waitFor(s).next(() => this.Zt(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = Ss.prefixForPath(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new gn(et);
    return Di(t2).Kt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, a, c] = t3, u = Rs(a);
      r2 === this.userId && n.isPrefixOf(u) ? u.length === s && (o = o.add(c)) : i2.done();
    }).next(() => this.Zt(t2, o));
  }
  Zt(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(Si(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw L2();
        B2(t3.userId === this.userId), n.push(fi(this.N, t3));
      }));
    }), js.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return bi(t2.Qt, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.te(e.batchId);
    }), js.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  te(t2) {
    delete this.Jt[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return js.resolve();
      const n = IDBKeyRange.lowerBound(Ss.prefixForUser(this.userId)), s = [];
      return Di(t2).Kt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = Rs(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        B2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return Vi(t2, this.userId, e);
  }
  ee(t2) {
    return Ci(t2).get(this.userId).next((t3) => t3 || new vs(this.userId, -1, ""));
  }
};
function Vi(t2, e, n) {
  const s = Ss.prefixForPath(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return Di(t2).Kt({
    range: r,
    qt: true
  }, (t3, n2, s2) => {
    const [r2, a, c] = t3;
    r2 === e && a === i && (o = true), s2.done();
  }).next(() => o);
}
function Si(t2) {
  return ei(t2, Vs.store);
}
function Di(t2) {
  return ei(t2, Ss.store);
}
function Ci(t2) {
  return ei(t2, vs.store);
}
var Ni = class {
  constructor(t2) {
    this.ne = t2;
  }
  next() {
    return this.ne += 2, this.ne;
  }
  static se() {
    return new Ni(0);
  }
  static ie() {
    return new Ni(-1);
  }
};
var xi = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.N = e;
  }
  allocateTargetId(t2) {
    return this.re(t2).next((e) => {
      const n = new Ni(e.highestTargetId);
      return e.highestTargetId = n.next(), this.oe(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.re(t2).next((t3) => rt.fromTimestamp(new it(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.re(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.re(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.oe(t2, s)));
  }
  addTargetData(t2, e) {
    return this.ae(t2, e).next(() => this.re(t2).next((n) => (n.targetCount += 1, this.ce(e, n), this.oe(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.ae(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => ki(t2).delete(e.targetId)).next(() => this.re(t2)).next((e2) => (B2(e2.targetCount > 0), e2.targetCount -= 1, this.oe(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return ki(t2).Kt((r, o) => {
      const a = di(o);
      a.sequenceNumber <= e && n.get(a.targetId) === null && (s++, i.push(this.removeTargetData(t2, a)));
    }).next(() => js.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return ki(t2).Kt((t3, n) => {
      const s = di(n);
      e(s);
    });
  }
  re(t2) {
    return $i(t2).get(Os.key).next((t3) => (B2(t3 !== null), t3));
  }
  oe(t2, e) {
    return $i(t2).put(Os.key, e);
  }
  ae(t2, e) {
    return ki(t2).put(wi(this.N, e));
  }
  ce(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.re(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = Wt(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return ki(t2).Kt({
      range: s,
      index: ks.queryTargetsIndexName
    }, (t3, n2, s2) => {
      const r = di(n2);
      zt(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = Oi(t2);
    return e.forEach((e2) => {
      const r = Es(e2.path);
      s.push(i.put(new $s(n, r))), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), js.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = Oi(t2);
    return js.forEach(e, (e2) => {
      const i = Es(e2.path);
      return js.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = Oi(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = Oi(t2);
    let i = Pn();
    return s.Kt({
      range: n,
      qt: true
    }, (t3, e2, n2) => {
      const s2 = Rs(t3[1]), r = new Pt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = Es(e.path), s = IDBKeyRange.bound([n], [st(n)], false, true);
    let i = 0;
    return Oi(t2).Kt({
      index: $s.documentTargetsIndex,
      qt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Tt(t2, e) {
    return ki(t2).get(e).next((t3) => t3 ? di(t3) : null);
  }
};
function ki(t2) {
  return ei(t2, ks.store);
}
function $i(t2) {
  return ei(t2, Os.store);
}
function Oi(t2) {
  return ei(t2, $s.store);
}
async function Fi(t2) {
  if (t2.code !== K2.FAILED_PRECONDITION || t2.message !== qs)
    throw t2;
  $("LocalStore", "Unexpectedly lost primary lease");
}
function Mi([t2, e], [n, s]) {
  const i = et(t2, n);
  return i === 0 ? et(e, s) : i;
}
var Li = class {
  constructor(t2) {
    this.ue = t2, this.buffer = new gn(Mi), this.he = 0;
  }
  le() {
    return ++this.he;
  }
  fe(t2) {
    const e = [t2, this.le()];
    if (this.buffer.size < this.ue)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      Mi(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Bi = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.de = false, this.we = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this._e(t2);
  }
  stop() {
    this.we && (this.we.cancel(), this.we = null);
  }
  get started() {
    return this.we !== null;
  }
  _e(t2) {
    const e = this.de ? 3e5 : 6e4;
    $("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.we = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.we = null, this.de = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Hs(t3) ? $("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Fi(t3);
      }
      await this._e(t2);
    });
  }
};
var Ui = class {
  constructor(t2, e) {
    this.me = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.me.ge(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return js.resolve(X2.T);
    const n = new Li(e);
    return this.me.forEachTarget(t2, (t3) => n.fe(t3.sequenceNumber)).next(() => this.me.ye(t2, (t3) => n.fe(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.me.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.me.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? ($("LruGarbageCollector", "Garbage collection skipped; disabled"), js.resolve(Ai)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? ($("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), Ai) : this.pe(t2, e));
  }
  getCacheSize(t2) {
    return this.me.getCacheSize(t2);
  }
  pe(t2, e) {
    let n, s, i, r, o, c, u;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? ($("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, c = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (u = Date.now(), x2() <= LogLevel.DEBUG) {
        $("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (c - o) + `ms
	Removed ${t3} documents in ` + (u - c) + `ms
Total Duration: ${u - h}ms`);
      }
      return js.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var qi = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new Ui(t3, e2);
    }(this, e);
  }
  ge(t2) {
    const e = this.Te(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  Te(t2) {
    let e = 0;
    return this.ye(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  ye(t2, e) {
    return this.Ee(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return Ki(t2, n);
  }
  removeReference(t2, e, n) {
    return Ki(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return Ki(t2, e);
  }
  Ie(t2, e) {
    return function(t3, e2) {
      let n = false;
      return Ci(t3).jt((s) => Vi(t3, s, e2).next((t4) => (t4 && (n = true), js.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Ee(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Ie(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r), Oi(t2).delete([0, Es(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => js.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return Ki(t2, e);
  }
  Ee(t2, e) {
    const n = Oi(t2);
    let s, i = X2.T;
    return n.Kt({
      index: $s.documentTargetsIndex
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== X2.T && e(new Pt(Rs(s)), i), i = o, s = r) : i = X2.T;
    }).next(() => {
      i !== X2.T && e(new Pt(Rs(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function Ki(t2, e) {
  return Oi(t2).put(function(t3, e2) {
    return new $s(0, Es(t3.path), e2);
  }(e, t2.currentSequenceNumber));
}
var ji = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s !== void 0) {
      for (let n2 = 0; n2 < s.length; n2++)
        if (this.equalsFn(s[n2][0], t2))
          return void (s[n2] = [t2, e]);
      s.push([t2, e]);
    } else
      this.inner[n] = [[t2, e]];
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), true;
    return false;
  }
  forEach(t2) {
    at(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return ct(this.inner);
  }
};
var Qi = class {
  constructor() {
    this.changes = new ji((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  getReadTime(t2) {
    const e = this.changes.get(t2);
    return e ? e.readTime : rt.min();
  }
  addEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2.key, {
      document: t2,
      readTime: e
    });
  }
  removeEntry(t2, e = null) {
    this.assertNotApplied(), this.changes.set(t2, {
      document: Kt.newInvalidDocument(t2),
      readTime: e
    });
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? js.resolve(n.document) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var Wi = class {
  constructor(t2, e) {
    this.N = t2, this.Ht = e;
  }
  addEntry(t2, e, n) {
    return Hi(t2).put(Ji(e), n);
  }
  removeEntry(t2, e) {
    const n = Hi(t2), s = Ji(e);
    return n.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.Ae(t2, n)));
  }
  getEntry(t2, e) {
    return Hi(t2).get(Ji(e)).next((t3) => this.Re(e, t3));
  }
  be(t2, e) {
    return Hi(t2).get(Ji(e)).next((t3) => ({
      document: this.Re(e, t3),
      size: Pi(t3)
    }));
  }
  getEntries(t2, e) {
    let n = Tn();
    return this.Pe(t2, e, (t3, e2) => {
      const s = this.Re(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  ve(t2, e) {
    let n = Tn(), s = new wn(Pt.comparator);
    return this.Pe(t2, e, (t3, e2) => {
      const i = this.Re(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Pi(e2));
    }).next(() => ({
      documents: n,
      Ve: s
    }));
  }
  Pe(t2, e, n) {
    if (e.isEmpty())
      return js.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r = i.getNext();
    return Hi(t2).Kt({
      range: s
    }, (t3, e2, s2) => {
      const o = Pt.fromSegments(t3);
      for (; r && Pt.comparator(r, o) < 0; )
        n(r, null), r = i.getNext();
      r && r.isEqual(o) && (n(r, e2), r = i.hasNext() ? i.getNext() : null), r ? s2.Mt(r.path.toArray()) : s2.done();
    }).next(() => {
      for (; r; )
        n(r, null), r = i.hasNext() ? i.getNext() : null;
    });
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = Tn();
    const i = e.path.length + 1, r = {};
    if (n.isEqual(rt.min())) {
      const t3 = e.path.toArray();
      r.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.path.toArray(), s2 = ci(n);
      r.range = IDBKeyRange.lowerBound([t3, s2], true), r.index = Ns.collectionReadTimeIndex;
    }
    return Hi(t2).Kt(r, (t3, n2, r2) => {
      if (t3.length !== i)
        return;
      const o = oi(this.N, n2);
      e.path.isPrefixOf(o.key.path) ? Pe(e, o) && (s = s.insert(o.key, o)) : r2.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Gi(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return zi(t2).get(xs.key).next((t3) => (B2(!!t3), t3));
  }
  Ae(t2, e) {
    return zi(t2).put(xs.key, e);
  }
  Re(t2, e) {
    if (e) {
      const t3 = oi(this.N, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(rt.min())))
        return t3;
    }
    return Kt.newInvalidDocument(t2);
  }
};
var Gi = class extends Qi {
  constructor(t2, e) {
    super(), this.Se = t2, this.trackRemovals = e, this.De = new ji((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new gn((t3, e2) => et(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.De.get(i);
      if (r.document.isValidDocument()) {
        const a = ai(this.Se.N, r.document, this.getReadTime(i));
        s = s.add(i.path.popLast());
        const c = Pi(a);
        n += c - o, e.push(this.Se.addEntry(t2, i, a));
      } else if (n -= o, this.trackRemovals) {
        const n2 = ai(this.Se.N, Kt.newNoDocument(i, rt.min()), this.getReadTime(i));
        e.push(this.Se.addEntry(t2, i, n2));
      } else
        e.push(this.Se.removeEntry(t2, i));
    }), s.forEach((n2) => {
      e.push(this.Se.Ht.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Se.updateMetadata(t2, n)), js.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Se.be(t2, e).next((t3) => (this.De.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Se.ve(t2, e).next(({ documents: t3, Ve: e2 }) => (e2.forEach((t4, e3) => {
      this.De.set(t4, e3);
    }), t3));
  }
};
function zi(t2) {
  return ei(t2, xs.store);
}
function Hi(t2) {
  return ei(t2, Ns.store);
}
function Ji(t2) {
  return t2.path.toArray();
}
var Yi = class {
  constructor(t2) {
    this.N = t2;
  }
  Ct(t2, e, n, s) {
    B2(n < s && n >= 0 && s <= 11);
    const i = new Qs("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore(Ps.store);
    }(t2), function(t3) {
      t3.createObjectStore(vs.store, {
        keyPath: vs.keyPath
      });
      t3.createObjectStore(Vs.store, {
        keyPath: Vs.keyPath,
        autoIncrement: true
      }).createIndex(Vs.userMutationsIndex, Vs.userMutationsKeyPath, {
        unique: true
      }), t3.createObjectStore(Ss.store);
    }(t2), Xi(t2), function(t3) {
      t3.createObjectStore(Ns.store);
    }(t2));
    let r = js.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore($s.store), t3.deleteObjectStore(ks.store), t3.deleteObjectStore(Os.store);
    }(t2), Xi(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store(Os.store), n2 = new Os(0, 0, rt.min().toTimestamp(), 0);
      return e2.put(Os.key, n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store(Vs.store).Lt().next((n2) => {
        t3.deleteObjectStore(Vs.store);
        t3.createObjectStore(Vs.store, {
          keyPath: Vs.keyPath,
          autoIncrement: true
        }).createIndex(Vs.userMutationsIndex, Vs.userMutationsKeyPath, {
          unique: true
        });
        const s2 = e2.store(Vs.store), i2 = n2.map((t4) => s2.put(t4));
        return js.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Ms.store, {
          keyPath: Ms.keyPath
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Ce(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore(xs.store);
    }(t2), this.Ne(i)))), n < 7 && s >= 7 && (r = r.next(() => this.xe(i))), n < 8 && s >= 8 && (r = r.next(() => this.ke(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore(Ns.store);
        e2.createIndex(Ns.readTimeIndex, Ns.readTimeIndexPath, {
          unique: false
        }), e2.createIndex(Ns.collectionReadTimeIndex, Ns.collectionReadTimeIndexPath, {
          unique: false
        });
      }(e);
    })), n < 10 && s >= 10 && (r = r.next(() => this.$e(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Ls.store, {
          keyPath: Ls.keyPath
        });
      }(t2), function(t3) {
        t3.createObjectStore(Bs.store, {
          keyPath: Bs.keyPath
        });
      }(t2);
    })), r;
  }
  Ne(t2) {
    let e = 0;
    return t2.store(Ns.store).Kt((t3, n) => {
      e += Pi(n);
    }).next(() => {
      const n = new xs(e);
      return t2.store(xs.store).put(xs.key, n);
    });
  }
  Ce(t2) {
    const e = t2.store(vs.store), n = t2.store(Vs.store);
    return e.Lt().next((e2) => js.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.Lt(Vs.userMutationsIndex, s).next((n2) => js.forEach(n2, (n3) => {
        B2(n3.userId === e3.userId);
        const s2 = fi(this.N, n3);
        return bi(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  xe(t2) {
    const e = t2.store($s.store), n = t2.store(Ns.store);
    return t2.store(Os.store).get(Os.key).next((t3) => {
      const s = [];
      return n.Kt((n2, i) => {
        const r = new ht(n2), o = function(t4) {
          return [0, Es(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? js.resolve() : ((n4) => e.put(new $s(0, Es(n4), t3.highestListenSequenceNumber)))(r)));
      }).next(() => js.waitFor(s));
    });
  }
  ke(t2, e) {
    t2.createObjectStore(Fs.store, {
      keyPath: Fs.keyPath
    });
    const n = e.store(Fs.store), s = new Ti(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: Es(s2)
        });
      }
    };
    return e.store(Ns.store).Kt({
      qt: true
    }, (t3, e2) => {
      const n2 = new ht(t3);
      return i(n2.popLast());
    }).next(() => e.store(Ss.store).Kt({
      qt: true
    }, ([t3, e2, n2], s2) => {
      const r = Rs(e2);
      return i(r.popLast());
    }));
  }
  $e(t2) {
    const e = t2.store(ks.store);
    return e.Kt((t3, n) => {
      const s = di(n), i = wi(this.N, s);
      return e.put(i);
    });
  }
};
function Xi(t2) {
  t2.createObjectStore($s.store, {
    keyPath: $s.keyPath
  }).createIndex($s.documentTargetsIndex, $s.documentTargetsKeyPath, {
    unique: true
  });
  t2.createObjectStore(ks.store, {
    keyPath: ks.keyPath
  }).createIndex(ks.queryTargetsIndexName, ks.queryTargetsKeyPath, {
    unique: true
  }), t2.createObjectStore(Os.store);
}
var Zi = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var tr = class {
  constructor(t2, e, n, s, i, r, o, a, c, u) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Oe = i, this.window = r, this.document = o, this.Fe = c, this.Me = u, this.Le = null, this.Be = false, this.isPrimary = false, this.networkEnabled = true, this.Ue = null, this.inForeground = false, this.qe = null, this.Ke = null, this.je = Number.NEGATIVE_INFINITY, this.Qe = (t3) => Promise.resolve(), !tr.bt())
      throw new j(K2.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new qi(this, s), this.We = e + "main", this.N = new ri(a), this.Ge = new Ws(this.We, 11, new Yi(this.N)), this.ze = new xi(this.referenceDelegate, this.N), this.Ht = new Ei(), this.He = function(t3, e2) {
      return new Wi(t3, e2);
    }(this.N, this.Ht), this.Je = new mi(), this.window && this.window.localStorage ? this.Ye = this.window.localStorage : (this.Ye = null, u === false && O2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.Xe().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new j(K2.FAILED_PRECONDITION, Zi);
      return this.Ze(), this.tn(), this.en(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.ze.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Le = new X2(t2, this.Fe);
    }).then(() => {
      this.Be = true;
    }).catch((t2) => (this.Ge && this.Ge.close(), Promise.reject(t2)));
  }
  nn(t2) {
    return this.Qe = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.Ge.xt(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Oe.enqueueAndForget(async () => {
      this.started && await this.Xe();
    }));
  }
  Xe() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => nr(t2).put(new Ms(this.clientId, Date.now(), this.networkEnabled, this.inForeground)).next(() => {
      if (this.isPrimary)
        return this.sn(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Oe.enqueueRetryable(() => this.Qe(false)));
        });
    }).next(() => this.rn(t2)).next((e) => this.isPrimary && !e ? this.on(t2).next(() => false) : !!e && this.an(t2).next(() => true))).catch((t2) => {
      if (Hs(t2))
        return $("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return $("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Oe.enqueueRetryable(() => this.Qe(t2)), this.isPrimary = t2;
    });
  }
  sn(t2) {
    return er(t2).get(Ps.key).next((t3) => js.resolve(this.cn(t3)));
  }
  un(t2) {
    return nr(t2).delete(this.clientId);
  }
  async hn() {
    if (this.isPrimary && !this.ln(this.je, 18e5)) {
      this.je = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = ei(t3, Ms.store);
        return e.Lt().next((t4) => {
          const n = this.fn(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return js.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.Ye)
        for (const e of t2)
          this.Ye.removeItem(this.dn(e.clientId));
    }
  }
  en() {
    this.Ke = this.Oe.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.Xe().then(() => this.hn()).then(() => this.en()));
  }
  cn(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  rn(t2) {
    if (this.Me)
      return js.resolve(true);
    return er(t2).get(Ps.key).next((e) => {
      if (e !== null && this.ln(e.leaseTimestampMs, 5e3) && !this.wn(e.ownerId)) {
        if (this.cn(e) && this.networkEnabled)
          return true;
        if (!this.cn(e)) {
          if (!e.allowTabSynchronization)
            throw new j(K2.FAILED_PRECONDITION, Zi);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || nr(t2).Lt().next((t3) => this.fn(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && $("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.Be = false, this._n(), this.Ke && (this.Ke.cancel(), this.Ke = null), this.mn(), this.gn(), await this.Ge.runTransaction("shutdown", "readwrite", [Ps.store, Ms.store], (t2) => {
      const e = new ti(t2, X2.T);
      return this.on(e).next(() => this.un(e));
    }), this.Ge.close(), this.yn();
  }
  fn(t2, e) {
    return t2.filter((t3) => this.ln(t3.updateTimeMs, e) && !this.wn(t3.clientId));
  }
  pn() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => nr(t2).Lt().next((t3) => this.fn(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.Be;
  }
  getMutationQueue(t2) {
    return vi.Yt(t2, this.N, this.Ht, this.referenceDelegate);
  }
  getTargetCache() {
    return this.ze;
  }
  getRemoteDocumentCache() {
    return this.He;
  }
  getIndexManager() {
    return this.Ht;
  }
  getBundleCache() {
    return this.Je;
  }
  runTransaction(t2, e, n) {
    $("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite";
    let i;
    return this.Ge.runTransaction(t2, s, Us, (s2) => (i = new ti(s2, this.Le ? this.Le.next() : X2.T), e === "readwrite-primary" ? this.sn(i).next((t3) => !!t3 || this.rn(i)).next((e2) => {
      if (!e2)
        throw O2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Oe.enqueueRetryable(() => this.Qe(false)), new j(K2.FAILED_PRECONDITION, qs);
      return n(i);
    }).next((t3) => this.an(i).next(() => t3)) : this.Tn(i).next(() => n(i)))).then((t3) => (i.raiseOnCommittedEvent(), t3));
  }
  Tn(t2) {
    return er(t2).get(Ps.key).next((t3) => {
      if (t3 !== null && this.ln(t3.leaseTimestampMs, 5e3) && !this.wn(t3.ownerId) && !this.cn(t3) && !(this.Me || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new j(K2.FAILED_PRECONDITION, Zi);
    });
  }
  an(t2) {
    const e = new Ps(this.clientId, this.allowTabSynchronization, Date.now());
    return er(t2).put(Ps.key, e);
  }
  static bt() {
    return Ws.bt();
  }
  on(t2) {
    const e = er(t2);
    return e.get(Ps.key).next((t3) => this.cn(t3) ? ($("IndexedDbPersistence", "Releasing primary lease."), e.delete(Ps.key)) : js.resolve());
  }
  ln(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (O2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  Ze() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.qe = () => {
      this.Oe.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.Xe()));
    }, this.document.addEventListener("visibilitychange", this.qe), this.inForeground = this.document.visibilityState === "visible");
  }
  mn() {
    this.qe && (this.document.removeEventListener("visibilitychange", this.qe), this.qe = null);
  }
  tn() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.Ue = () => {
      this._n(), isSafari() && navigator.appVersion.match("Version/14") && this.Oe.enterRestrictedMode(true), this.Oe.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.Ue));
  }
  gn() {
    this.Ue && (this.window.removeEventListener("pagehide", this.Ue), this.Ue = null);
  }
  wn(t2) {
    var e;
    try {
      const n = ((e = this.Ye) === null || e === void 0 ? void 0 : e.getItem(this.dn(t2))) !== null;
      return $("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return O2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  _n() {
    if (this.Ye)
      try {
        this.Ye.setItem(this.dn(this.clientId), String(Date.now()));
      } catch (t2) {
        O2("Failed to set zombie client id.", t2);
      }
  }
  yn() {
    if (this.Ye)
      try {
        this.Ye.removeItem(this.dn(this.clientId));
      } catch (t2) {
      }
  }
  dn(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function er(t2) {
  return ei(t2, Ps.store);
}
function nr(t2) {
  return ei(t2, Ms.store);
}
function sr(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var ir = class {
  constructor(t2, e) {
    this.progress = t2, this.En = e;
  }
};
var rr = class {
  constructor(t2, e, n) {
    this.He = t2, this.In = e, this.Ht = n;
  }
  An(t2, e) {
    return this.In.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.Rn(t2, e, n));
  }
  Rn(t2, e, n) {
    return this.He.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  bn(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  Pn(t2, e) {
    return this.He.getEntries(t2, e).next((e2) => this.vn(t2, e2).next(() => e2));
  }
  vn(t2, e) {
    return this.In.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.bn(e, t3));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return Pt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Vn(t2, e.path) : pe(e) ? this.Sn(t2, e, n) : this.Dn(t2, e, n);
  }
  Vn(t2, e) {
    return this.An(t2, new Pt(e)).next((t3) => {
      let e2 = In();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  Sn(t2, e, n) {
    const s = e.collectionGroup;
    let i = In();
    return this.Ht.getCollectionParents(t2, s).next((r) => js.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new fe(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.Dn(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  Dn(t2, e, n) {
    let s, i;
    return this.He.getDocumentsMatchingQuery(t2, e, n).next((n2) => (s = n2, this.In.getAllMutationBatchesAffectingQuery(t2, e))).next((e2) => (i = e2, this.Cn(t2, i, s).next((t3) => {
      s = t3;
      for (const t4 of i)
        for (const e3 of t4.mutations) {
          const n2 = e3.key;
          let i2 = s.get(n2);
          i2 == null && (i2 = Kt.newInvalidDocument(n2), s = s.insert(n2, i2)), Ye(e3, i2, t4.localWriteTime), i2.isFoundDocument() || (s = s.remove(n2));
        }
    }))).next(() => (s.forEach((t3, n2) => {
      Pe(e, n2) || (s = s.remove(t3));
    }), s));
  }
  Cn(t2, e, n) {
    let s = Pn();
    for (const t3 of e)
      for (const e2 of t3.mutations)
        e2 instanceof nn && n.get(e2.key) === null && (s = s.add(e2.key));
    let i = n;
    return this.He.getEntries(t2, s).next((t3) => (t3.forEach((t4, e2) => {
      e2.isFoundDocument() && (i = i.insert(t4, e2));
    }), i));
  }
};
var or = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.Nn = n, this.xn = s;
  }
  static kn(t2, e) {
    let n = Pn(), s = Pn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new or(t2, e.fromCache, n, s);
  }
};
var ar = class {
  $n(t2) {
    this.On = t2;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(rt.min()) ? this.Fn(t2, e) : this.On.Pn(t2, s).next((i) => {
      const r = this.Mn(e, i);
      return (_e(e) || me(e)) && this.Ln(e.limitType, r, s, n) ? this.Fn(t2, e) : (x2() <= LogLevel.DEBUG && $("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), be(e)), this.On.getDocumentsMatchingQuery(t2, e, n).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  Mn(t2, e) {
    let n = new gn(ve(t2));
    return e.forEach((e2, s) => {
      Pe(t2, s) && (n = n.add(s));
    }), n;
  }
  Ln(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Fn(t2, e) {
    return x2() <= LogLevel.DEBUG && $("QueryEngine", "Using full collection scan to execute query:", be(e)), this.On.getDocumentsMatchingQuery(t2, e, rt.min());
  }
};
var cr = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Bn = e, this.N = s, this.Un = new wn(et), this.qn = new ji((t3) => Wt(t3), zt), this.Kn = rt.min(), this.In = t2.getMutationQueue(n), this.jn = t2.getRemoteDocumentCache(), this.ze = t2.getTargetCache(), this.Qn = new rr(this.jn, this.In, this.persistence.getIndexManager()), this.Je = t2.getBundleCache(), this.Bn.$n(this.Qn);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.Un));
  }
};
function ur(t2, e, n, s) {
  return new cr(t2, e, n, s);
}
async function hr(t2, e) {
  const n = q2(t2);
  let s = n.In, i = n.Qn;
  const r = await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let r2;
    return n.In.getAllMutationBatches(t3).next((o) => (r2 = o, s = n.persistence.getMutationQueue(e), i = new rr(n.jn, s, n.persistence.getIndexManager()), s.getAllMutationBatches(t3))).next((e2) => {
      const n2 = [], s2 = [];
      let o = Pn();
      for (const t4 of r2) {
        n2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        s2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return i.Pn(t3, o).next((t4) => ({
        Wn: t4,
        removedBatchIds: n2,
        addedBatchIds: s2
      }));
    });
  });
  return n.In = s, n.Qn = i, n.Bn.$n(n.Qn), r;
}
function lr(t2, e) {
  const n = q2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.jn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = js.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          B2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && s2.addEntry(e3, n2.commitVersion));
        });
      }), o.next(() => t4.In.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.In.performConsistencyCheck(t3)).next(() => n.Qn.Pn(t3, s));
  });
}
function fr(t2) {
  const e = q2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.ze.getLastRemoteSnapshotVersion(t3));
}
function dr(t2, e) {
  const n = q2(t2), s = e.snapshotVersion;
  let i = n.Un;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.jn.newChangeBuffer({
      trackRemovals: true
    });
    i = n.Un;
    const o = [];
    e.targetChanges.forEach((e2, r2) => {
      const a2 = i.get(r2);
      if (!a2)
        return;
      o.push(n.ze.removeMatchingKeys(t3, e2.removedDocuments, r2).next(() => n.ze.addMatchingKeys(t3, e2.addedDocuments, r2)));
      const c = e2.resumeToken;
      if (c.approximateByteSize() > 0) {
        const u = a2.withResumeToken(c, s).withSequenceNumber(t3.currentSequenceNumber);
        i = i.insert(r2, u), function(t4, e3, n2) {
          if (B2(e3.resumeToken.approximateByteSize() > 0), t4.resumeToken.approximateByteSize() === 0)
            return true;
          if (e3.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
            return true;
          return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
        }(a2, u, e2) && o.push(n.ze.updateTargetData(t3, u));
      }
    });
    let a = Tn();
    if (e.documentUpdates.forEach((s2, i2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(wr(t3, r, e.documentUpdates, s, void 0).next((t4) => {
      a = t4;
    })), !s.isEqual(rt.min())) {
      const e2 = n.ze.getLastRemoteSnapshotVersion(t3).next((e3) => n.ze.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return js.waitFor(o).next(() => r.apply(t3)).next(() => n.Qn.vn(t3, a)).next(() => a);
  }).then((t3) => (n.Un = i, t3));
}
function wr(t2, e, n, s, i) {
  let r = Pn();
  return n.forEach((t3) => r = r.add(t3)), e.getEntries(t2, r).next((t3) => {
    let r2 = Tn();
    return n.forEach((n2, o) => {
      const a = t3.get(n2), c = (i == null ? void 0 : i.get(n2)) || s;
      o.isNoDocument() && o.version.isEqual(rt.min()) ? (e.removeEntry(n2, c), r2 = r2.insert(n2, o)) : !a.isValidDocument() || o.version.compareTo(a.version) > 0 || o.version.compareTo(a.version) === 0 && a.hasPendingWrites ? (e.addEntry(o, c), r2 = r2.insert(n2, o)) : $("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", a.version, " Watch version:", o.version);
    }), r2;
  });
}
function _r(t2, e) {
  const n = q2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.In.getNextMutationBatchAfterBatchId(t3, e)));
}
function mr(t2, e) {
  const n = q2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.ze.getTargetData(t3, e).next((i) => i ? (s = i, js.resolve(s)) : n.ze.allocateTargetId(t3).next((i2) => (s = new ii(e, i2, 0, t3.currentSequenceNumber), n.ze.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.Un.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.Un = n.Un.insert(t3.targetId, t3), n.qn.set(e, t3.targetId)), t3;
  });
}
async function gr(t2, e, n) {
  const s = q2(t2), i = s.Un.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Hs(t3))
      throw t3;
    $("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.Un = s.Un.remove(e), s.qn.delete(i.target);
}
function yr(t2, e, n) {
  const s = q2(t2);
  let i = rt.min(), r = Pn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = q2(t4), i2 = s2.qn.get(n2);
    return i2 !== void 0 ? js.resolve(s2.Un.get(i2)) : s2.ze.getTargetData(e2, n2);
  }(s, t3, Ee(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.ze.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Bn.getDocumentsMatchingQuery(t3, e, n ? i : rt.min(), n ? r : Pn())).next((t4) => ({
    documents: t4,
    Gn: r
  })));
}
function pr(t2, e) {
  const n = q2(t2), s = q2(n.ze), i = n.Un.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Tt(t3, e).next((t4) => t4 ? t4.target : null));
}
function Tr(t2) {
  const e = q2(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n) {
    const s = q2(t4);
    let i = Tn(), r = ci(n);
    const o = Hi(e2), a = IDBKeyRange.lowerBound(r, true);
    return o.Kt({
      index: Ns.readTimeIndex,
      range: a
    }, (t5, e3) => {
      const n2 = oi(s.N, e3);
      i = i.insert(n2.key, n2), r = e3.readTime;
    }).next(() => ({
      En: i,
      readTime: ui(r)
    }));
  }(e.jn, t3, e.Kn)).then(({ En: t3, readTime: n }) => (e.Kn = n, t3));
}
async function Er(t2) {
  const e = q2(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = Hi(t4);
    let n = rt.min();
    return e2.Kt({
      index: Ns.readTimeIndex,
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n = ui(e3.readTime)), s.done();
    }).next(() => n);
  }(t3)).then((t3) => {
    e.Kn = t3;
  });
}
async function Ir(t2, e, n, s) {
  const i = q2(t2);
  let r = Pn(), o = Tn(), a = Rn();
  for (const t3 of n) {
    const n2 = e.zn(t3.metadata.name);
    t3.document && (r = r.add(n2)), o = o.insert(n2, e.Hn(t3)), a = a.insert(n2, e.Jn(t3.metadata.readTime));
  }
  const c = i.jn.newChangeBuffer({
    trackRemovals: true
  }), u = await mr(i, function(t3) {
    return Ee(we(ht.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => wr(t3, c, o, rt.min(), a).next((e2) => (c.apply(t3), e2)).next((e2) => i.ze.removeMatchingKeysForTargetId(t3, u.targetId).next(() => i.ze.addMatchingKeys(t3, r, u.targetId)).next(() => i.Qn.vn(t3, e2)).next(() => e2)));
}
async function Ar(t2, e, n = Pn()) {
  const s = await mr(t2, Ee(_i(e.bundledQuery))), i = q2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = jn(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Je.saveNamedQuery(t3, e);
    const o = s.withResumeToken(_t.EMPTY_BYTE_STRING, r);
    return i.Un = i.Un.insert(o.targetId, o), i.ze.updateTargetData(t3, o).next(() => i.ze.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.ze.addMatchingKeys(t3, n, s.targetId)).next(() => i.Je.saveNamedQuery(t3, e));
  });
}
var Rr = class {
  constructor(t2) {
    this.N = t2, this.Yn = new Map(), this.Xn = new Map();
  }
  getBundleMetadata(t2, e) {
    return js.resolve(this.Yn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Yn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: jn(n.createTime)
    }), js.resolve();
  }
  getNamedQuery(t2, e) {
    return js.resolve(this.Xn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.Xn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: _i(t3.bundledQuery),
        readTime: jn(t3.readTime)
      };
    }(e)), js.resolve();
  }
};
var br = class {
  constructor() {
    this.Zn = new gn(Pr.ts), this.es = new gn(Pr.ns);
  }
  isEmpty() {
    return this.Zn.isEmpty();
  }
  addReference(t2, e) {
    const n = new Pr(t2, e);
    this.Zn = this.Zn.add(n), this.es = this.es.add(n);
  }
  ss(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.rs(new Pr(t2, e));
  }
  os(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  cs(t2) {
    const e = new Pt(new ht([])), n = new Pr(e, t2), s = new Pr(e, t2 + 1), i = [];
    return this.es.forEachInRange([n, s], (t3) => {
      this.rs(t3), i.push(t3.key);
    }), i;
  }
  us() {
    this.Zn.forEach((t2) => this.rs(t2));
  }
  rs(t2) {
    this.Zn = this.Zn.delete(t2), this.es = this.es.delete(t2);
  }
  hs(t2) {
    const e = new Pt(new ht([])), n = new Pr(e, t2), s = new Pr(e, t2 + 1);
    let i = Pn();
    return this.es.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new Pr(t2, 0), n = this.Zn.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var Pr = class {
  constructor(t2, e) {
    this.key = t2, this.ls = e;
  }
  static ts(t2, e) {
    return Pt.comparator(t2.key, e.key) || et(t2.ls, e.ls);
  }
  static ns(t2, e) {
    return et(t2.ls, e.ls) || Pt.comparator(t2.key, e.key);
  }
};
var vr = class {
  constructor(t2, e) {
    this.Ht = t2, this.referenceDelegate = e, this.In = [], this.fs = 1, this.ds = new gn(Pr.ts);
  }
  checkEmpty(t2) {
    return js.resolve(this.In.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.fs;
    this.fs++, this.In.length > 0 && this.In[this.In.length - 1];
    const r = new ni(i, e, n, s);
    this.In.push(r);
    for (const e2 of s)
      this.ds = this.ds.add(new Pr(e2.key, i)), this.Ht.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return js.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return js.resolve(this.ws(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this._s(n), i = s < 0 ? 0 : s;
    return js.resolve(this.In.length > i ? this.In[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return js.resolve(this.In.length === 0 ? -1 : this.fs - 1);
  }
  getAllMutationBatches(t2) {
    return js.resolve(this.In.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new Pr(e, 0), s = new Pr(e, Number.POSITIVE_INFINITY), i = [];
    return this.ds.forEachInRange([n, s], (t3) => {
      const e2 = this.ws(t3.ls);
      i.push(e2);
    }), js.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new gn(et);
    return e.forEach((t3) => {
      const e2 = new Pr(t3, 0), s = new Pr(t3, Number.POSITIVE_INFINITY);
      this.ds.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.ls);
      });
    }), js.resolve(this.gs(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    Pt.isDocumentKey(i) || (i = i.child(""));
    const r = new Pr(new Pt(i), 0);
    let o = new gn(et);
    return this.ds.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.ls)), true);
    }, r), js.resolve(this.gs(o));
  }
  gs(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.ws(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    B2(this.ys(e.batchId, "removed") === 0), this.In.shift();
    let n = this.ds;
    return js.forEach(e.mutations, (s) => {
      const i = new Pr(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.ds = n;
    });
  }
  te(t2) {
  }
  containsKey(t2, e) {
    const n = new Pr(e, 0), s = this.ds.firstAfterOrEqual(n);
    return js.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.In.length, js.resolve();
  }
  ys(t2, e) {
    return this._s(t2);
  }
  _s(t2) {
    if (this.In.length === 0)
      return 0;
    return t2 - this.In[0].batchId;
  }
  ws(t2) {
    const e = this._s(t2);
    if (e < 0 || e >= this.In.length)
      return null;
    return this.In[e];
  }
};
var Vr = class {
  constructor(t2, e) {
    this.Ht = t2, this.ps = e, this.docs = new wn(Pt.comparator), this.size = 0;
  }
  addEntry(t2, e, n) {
    const s = e.key, i = this.docs.get(s), r = i ? i.size : 0, o = this.ps(e);
    return this.docs = this.docs.insert(s, {
      document: e.clone(),
      size: o,
      readTime: n
    }), this.size += o - r, this.Ht.addToCollectionParentIndex(t2, s.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return js.resolve(n ? n.document.clone() : Kt.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = Tn();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.clone() : Kt.newInvalidDocument(t3));
    }), js.resolve(n);
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = Tn();
    const i = new Pt(e.path.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2, readTime: o } } = r.getNext();
      if (!e.path.isPrefixOf(t3.path))
        break;
      o.compareTo(n) <= 0 || Pe(e, i2) && (s = s.insert(i2.key, i2.clone()));
    }
    return js.resolve(s);
  }
  Ts(t2, e) {
    return js.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new Sr(this);
  }
  getSize(t2) {
    return js.resolve(this.size);
  }
};
var Sr = class extends Qi {
  constructor(t2) {
    super(), this.Se = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.document.isValidDocument() ? e.push(this.Se.addEntry(t2, s.document, this.getReadTime(n))) : this.Se.removeEntry(n);
    }), js.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Se.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Se.getEntries(t2, e);
  }
};
var Dr = class {
  constructor(t2) {
    this.persistence = t2, this.Es = new ji((t3) => Wt(t3), zt), this.lastRemoteSnapshotVersion = rt.min(), this.highestTargetId = 0, this.Is = 0, this.As = new br(), this.targetCount = 0, this.Rs = Ni.se();
  }
  forEachTarget(t2, e) {
    return this.Es.forEach((t3, n) => e(n)), js.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return js.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return js.resolve(this.Is);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Rs.next(), js.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.Is && (this.Is = e), js.resolve();
  }
  ae(t2) {
    this.Es.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.Rs = new Ni(e), this.highestTargetId = e), t2.sequenceNumber > this.Is && (this.Is = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.ae(e), this.targetCount += 1, js.resolve();
  }
  updateTargetData(t2, e) {
    return this.ae(e), js.resolve();
  }
  removeTargetData(t2, e) {
    return this.Es.delete(e.target), this.As.cs(e.targetId), this.targetCount -= 1, js.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Es.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Es.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), js.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return js.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Es.get(e) || null;
    return js.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.As.ss(e, n), js.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.As.os(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), js.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.As.cs(e), js.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.As.hs(e);
    return js.resolve(n);
  }
  containsKey(t2, e) {
    return js.resolve(this.As.containsKey(e));
  }
};
var Cr = class {
  constructor(t2, e) {
    this.bs = {}, this.Le = new X2(0), this.Be = false, this.Be = true, this.referenceDelegate = t2(this), this.ze = new Dr(this);
    this.Ht = new pi(), this.He = function(t3, e2) {
      return new Vr(t3, e2);
    }(this.Ht, (t3) => this.referenceDelegate.Ps(t3)), this.N = new ri(e), this.Je = new Rr(this.N);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Be = false, Promise.resolve();
  }
  get started() {
    return this.Be;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager() {
    return this.Ht;
  }
  getMutationQueue(t2) {
    let e = this.bs[t2.toKey()];
    return e || (e = new vr(this.Ht, this.referenceDelegate), this.bs[t2.toKey()] = e), e;
  }
  getTargetCache() {
    return this.ze;
  }
  getRemoteDocumentCache() {
    return this.He;
  }
  getBundleCache() {
    return this.Je;
  }
  runTransaction(t2, e, n) {
    $("MemoryPersistence", "Starting transaction:", t2);
    const s = new Nr(this.Le.next());
    return this.referenceDelegate.vs(), n(s).next((t3) => this.referenceDelegate.Vs(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Ss(t2, e) {
    return js.or(Object.values(this.bs).map((n) => () => n.containsKey(t2, e)));
  }
};
var Nr = class extends Ks {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var xr = class {
  constructor(t2) {
    this.persistence = t2, this.Ds = new br(), this.Cs = null;
  }
  static Ns(t2) {
    return new xr(t2);
  }
  get xs() {
    if (this.Cs)
      return this.Cs;
    throw L2();
  }
  addReference(t2, e, n) {
    return this.Ds.addReference(n, e), this.xs.delete(n.toString()), js.resolve();
  }
  removeReference(t2, e, n) {
    return this.Ds.removeReference(n, e), this.xs.add(n.toString()), js.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.xs.add(e.toString()), js.resolve();
  }
  removeTarget(t2, e) {
    this.Ds.cs(e.targetId).forEach((t3) => this.xs.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.xs.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  vs() {
    this.Cs = new Set();
  }
  Vs(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return js.forEach(this.xs, (n) => {
      const s = Pt.fromPath(n);
      return this.ks(t2, s).next((t3) => {
        t3 || e.removeEntry(s);
      });
    }).next(() => (this.Cs = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.ks(t2, e).next((t3) => {
      t3 ? this.xs.delete(e.toString()) : this.xs.add(e.toString());
    });
  }
  Ps(t2) {
    return 0;
  }
  ks(t2, e) {
    return js.or([() => js.resolve(this.Ds.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ss(t2, e)]);
  }
};
function kr(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function $r(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function Or(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var Fr = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static $s(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new j(s.error.code, s.error.message))), r ? new Fr(t2, e, s.state, i) : (O2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Os() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Mr = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static $s(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new j(n.error.code, n.error.message))), i ? new Mr(t2, n.state, s) : (O2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Os() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Lr = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static $s(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = Vn();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = bt(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Lr(t2, i) : (O2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var Br = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static $s(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new Br(e.clientId, e.onlineState) : (O2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var Ur = class {
  constructor() {
    this.activeTargetIds = Vn();
  }
  Fs(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Ms(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Os() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var qr = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Oe = e, this.persistenceKey = n, this.Ls = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.Bs = this.Us.bind(this), this.qs = new wn(et), this.started = false, this.Ks = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.js = kr(this.persistenceKey, this.Ls), this.Qs = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.qs = this.qs.insert(this.Ls, new Ur()), this.Ws = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.Gs = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.zs = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.Hs = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.Js = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.Bs);
  }
  static bt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.pn();
    for (const e2 of t2) {
      if (e2 === this.Ls)
        continue;
      const t3 = this.getItem(kr(this.persistenceKey, e2));
      if (t3) {
        const n = Lr.$s(e2, t3);
        n && (this.qs = this.qs.insert(n.clientId, n));
      }
    }
    this.Ys();
    const e = this.storage.getItem(this.Hs);
    if (e) {
      const t3 = this.Xs(e);
      t3 && this.Zs(t3);
    }
    for (const t3 of this.Ks)
      this.Us(t3);
    this.Ks = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.Qs, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.ti(this.qs);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.qs.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.ei(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.ei(t2, e, n), this.ni(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(Or(this.persistenceKey, t2));
      if (n) {
        const s = Mr.$s(t2, n);
        s && (e = s.state);
      }
    }
    return this.si.Fs(t2), this.Ys(), e;
  }
  removeLocalQueryTarget(t2) {
    this.si.Ms(t2), this.Ys();
  }
  isLocalQueryTarget(t2) {
    return this.si.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(Or(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.ii(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.ni(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.ri(t2);
  }
  notifyBundleLoaded() {
    this.oi();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.Bs), this.removeItem(this.js), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return $("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    $("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    $("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  Us(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if ($("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.js)
        return void O2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Oe.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.Ws.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.ai(e.key);
                return this.ci(t3, null);
              }
              {
                const t3 = this.ui(e.key, e.newValue);
                if (t3)
                  return this.ci(t3.clientId, t3);
              }
            } else if (this.Gs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.hi(e.key, e.newValue);
                if (t3)
                  return this.li(t3);
              }
            } else if (this.zs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.fi(e.key, e.newValue);
                if (t3)
                  return this.di(t3);
              }
            } else if (e.key === this.Hs) {
              if (e.newValue !== null) {
                const t3 = this.Xs(e.newValue);
                if (t3)
                  return this.Zs(t3);
              }
            } else if (e.key === this.Qs) {
              const t3 = function(t4) {
                let e2 = X2.T;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    B2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    O2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== X2.T && this.sequenceNumberHandler(t3);
            } else if (e.key === this.Js)
              return this.syncEngine.wi();
          }
        } else
          this.Ks.push(e);
      });
    }
  }
  get si() {
    return this.qs.get(this.Ls);
  }
  Ys() {
    this.setItem(this.js, this.si.Os());
  }
  ei(t2, e, n) {
    const s = new Fr(this.currentUser, t2, e, n), i = $r(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Os());
  }
  ni(t2) {
    const e = $r(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  ri(t2) {
    const e = {
      clientId: this.Ls,
      onlineState: t2
    };
    this.storage.setItem(this.Hs, JSON.stringify(e));
  }
  ii(t2, e, n) {
    const s = Or(this.persistenceKey, t2), i = new Mr(t2, e, n);
    this.setItem(s, i.Os());
  }
  oi() {
    this.setItem(this.Js, "value-not-used");
  }
  ai(t2) {
    const e = this.Ws.exec(t2);
    return e ? e[1] : null;
  }
  ui(t2, e) {
    const n = this.ai(t2);
    return Lr.$s(n, e);
  }
  hi(t2, e) {
    const n = this.Gs.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return Fr.$s(new D2(i), s, e);
  }
  fi(t2, e) {
    const n = this.zs.exec(t2), s = Number(n[1]);
    return Mr.$s(s, e);
  }
  Xs(t2) {
    return Br.$s(t2);
  }
  async li(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine._i(t2.batchId, t2.state, t2.error);
    $("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  di(t2) {
    return this.syncEngine.mi(t2.targetId, t2.state, t2.error);
  }
  ci(t2, e) {
    const n = e ? this.qs.insert(t2, e) : this.qs.remove(t2), s = this.ti(this.qs), i = this.ti(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.gi(r, o).then(() => {
      this.qs = n;
    });
  }
  Zs(t2) {
    this.qs.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  ti(t2) {
    let e = Vn();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var Kr = class {
  constructor() {
    this.yi = new Ur(), this.pi = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.yi.Fs(t2), this.pi[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.pi[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.yi.Ms(t2);
  }
  isLocalQueryTarget(t2) {
    return this.yi.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.pi[t2];
  }
  getAllActiveQueryTargets() {
    return this.yi.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.yi.activeTargetIds.has(t2);
  }
  start() {
    return this.yi = new Ur(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
};
var jr = class {
  Ti(t2) {
  }
  shutdown() {
  }
};
var Qr = class {
  constructor() {
    this.Ei = () => this.Ii(), this.Ai = () => this.Ri(), this.bi = [], this.Pi();
  }
  Ti(t2) {
    this.bi.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Ei), window.removeEventListener("offline", this.Ai);
  }
  Pi() {
    window.addEventListener("online", this.Ei), window.addEventListener("offline", this.Ai);
  }
  Ii() {
    $("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.bi)
      t2(0);
  }
  Ri() {
    $("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.bi)
      t2(1);
  }
  static bt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var Wr = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Gr = class {
  constructor(t2) {
    this.vi = t2.vi, this.Vi = t2.Vi;
  }
  Si(t2) {
    this.Di = t2;
  }
  Ci(t2) {
    this.Ni = t2;
  }
  onMessage(t2) {
    this.xi = t2;
  }
  close() {
    this.Vi();
  }
  send(t2) {
    this.vi(t2);
  }
  ki() {
    this.Di();
  }
  $i(t2) {
    this.Ni(t2);
  }
  Oi(t2) {
    this.xi(t2);
  }
};
var zr = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.Fi = e + "://" + t2.host, this.Mi = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  Li(t2, e, n, s) {
    const i = this.Bi(t2, e);
    $("RestConnection", "Sending: ", i, n);
    const r = {};
    return this.Ui(r, s), this.qi(t2, i, r, n).then((t3) => ($("RestConnection", "Received: ", t3), t3), (e2) => {
      throw F2("RestConnection", `${t2} failed with error: `, e2, "url: ", i, "request:", n), e2;
    });
  }
  Ki(t2, e, n, s) {
    return this.Li(t2, e, n, s);
  }
  Ui(t2, e) {
    if (t2["X-Goog-Api-Client"] = "gl-js/ fire/" + C2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e)
      for (const n in e.authHeaders)
        e.authHeaders.hasOwnProperty(n) && (t2[n] = e.authHeaders[n]);
  }
  Bi(t2, e) {
    const n = Wr[t2];
    return `${this.Fi}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  qi(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              $("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              $("Connection", 'RPC "' + t2 + '" timed out'), r(new j(K2.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if ($("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(K2).indexOf(e4) >= 0 ? e4 : K2.UNKNOWN;
                  }(t3.status);
                  r(new j(e3, t3.message));
                } else
                  r(new j(K2.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new j(K2.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L2();
          }
        } finally {
          $("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const a = JSON.stringify(s);
      o.send(e, "POST", a, n, 15);
    });
  }
  ji(t2, e) {
    const n = [this.Fi, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], s = createWebChannelTransport(), i = getStatEventTarget(), r = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (r.xmlHttpFactory = new FetchXmlHttpFactory({})), this.Ui(r.initMessageHeaders, e), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (r.httpHeadersOverwriteParam = "$httpHeaders");
    const o = n.join("");
    $("Connection", "Creating WebChannel: " + o, r);
    const a = s.createWebChannel(o, r);
    let c = false, u = false;
    const h = new Gr({
      vi: (t3) => {
        u ? $("Connection", "Not sending because WebChannel is closed:", t3) : (c || ($("Connection", "Opening WebChannel transport."), a.open(), c = true), $("Connection", "WebChannel sending:", t3), a.send(t3));
      },
      Vi: () => a.close()
    }), g = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return g(a, WebChannel.EventType.OPEN, () => {
      u || $("Connection", "WebChannel transport opened.");
    }), g(a, WebChannel.EventType.CLOSE, () => {
      u || (u = true, $("Connection", "WebChannel transport closed"), h.$i());
    }), g(a, WebChannel.EventType.ERROR, (t3) => {
      u || (u = true, F2("Connection", "WebChannel transport errored:", t3), h.$i(new j(K2.UNAVAILABLE, "The operation could not be completed")));
    }), g(a, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!u) {
        const n2 = t3.data[0];
        B2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          $("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = hn[t5];
            if (e4 !== void 0)
              return dn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = K2.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), u = true, h.$i(new j(e3, n3)), a.close();
        } else
          $("Connection", "WebChannel received:", n2), h.Oi(n2);
      }
    }), g(i, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? $("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && $("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      h.ki();
    }, 0), h;
  }
};
function Hr() {
  return typeof window != "undefined" ? window : null;
}
function Jr() {
  return typeof document != "undefined" ? document : null;
}
function Yr(t2) {
  return new Bn(t2, true);
}
var Xr = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Oe = t2, this.timerId = e, this.Qi = n, this.Wi = s, this.Gi = i, this.zi = 0, this.Hi = null, this.Ji = Date.now(), this.reset();
  }
  reset() {
    this.zi = 0;
  }
  Yi() {
    this.zi = this.Gi;
  }
  Xi(t2) {
    this.cancel();
    const e = Math.floor(this.zi + this.Zi()), n = Math.max(0, Date.now() - this.Ji), s = Math.max(0, e - n);
    s > 0 && $("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.zi} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Hi = this.Oe.enqueueAfterDelay(this.timerId, s, () => (this.Ji = Date.now(), t2())), this.zi *= this.Wi, this.zi < this.Qi && (this.zi = this.Qi), this.zi > this.Gi && (this.zi = this.Gi);
  }
  tr() {
    this.Hi !== null && (this.Hi.skipDelay(), this.Hi = null);
  }
  cancel() {
    this.Hi !== null && (this.Hi.cancel(), this.Hi = null);
  }
  Zi() {
    return (Math.random() - 0.5) * this.zi;
  }
};
var Zr = class {
  constructor(t2, e, n, s, i, r) {
    this.Oe = t2, this.er = n, this.nr = s, this.credentialsProvider = i, this.listener = r, this.state = 0, this.sr = 0, this.ir = null, this.stream = null, this.rr = new Xr(t2, e);
  }
  ar() {
    return this.state === 1 || this.state === 2 || this.state === 4;
  }
  cr() {
    return this.state === 2;
  }
  start() {
    this.state !== 3 ? this.auth() : this.ur();
  }
  async stop() {
    this.ar() && await this.close(0);
  }
  hr() {
    this.state = 0, this.rr.reset();
  }
  lr() {
    this.cr() && this.ir === null && (this.ir = this.Oe.enqueueAfterDelay(this.er, 6e4, () => this.dr()));
  }
  wr(t2) {
    this._r(), this.stream.send(t2);
  }
  async dr() {
    if (this.cr())
      return this.close(0);
  }
  _r() {
    this.ir && (this.ir.cancel(), this.ir = null);
  }
  async close(t2, e) {
    this._r(), this.rr.cancel(), this.sr++, t2 !== 3 ? this.rr.reset() : e && e.code === K2.RESOURCE_EXHAUSTED ? (O2(e.toString()), O2("Using maximum backoff delay to prevent overloading the backend."), this.rr.Yi()) : e && e.code === K2.UNAUTHENTICATED && this.credentialsProvider.invalidateToken(), this.stream !== null && (this.mr(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Ci(e);
  }
  mr() {
  }
  auth() {
    this.state = 1;
    const t2 = this.gr(this.sr), e = this.sr;
    this.credentialsProvider.getToken().then((t3) => {
      this.sr === e && this.yr(t3);
    }, (e2) => {
      t2(() => {
        const t3 = new j(K2.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.pr(t3);
      });
    });
  }
  yr(t2) {
    const e = this.gr(this.sr);
    this.stream = this.Tr(t2), this.stream.Si(() => {
      e(() => (this.state = 2, this.listener.Si()));
    }), this.stream.Ci((t3) => {
      e(() => this.pr(t3));
    }), this.stream.onMessage((t3) => {
      e(() => this.onMessage(t3));
    });
  }
  ur() {
    this.state = 4, this.rr.Xi(async () => {
      this.state = 0, this.start();
    });
  }
  pr(t2) {
    return $("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(3, t2);
  }
  gr(t2) {
    return (e) => {
      this.Oe.enqueueAndForget(() => this.sr === t2 ? e() : ($("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var to = class extends Zr {
  constructor(t2, e, n, s, i) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", e, n, i), this.N = s;
  }
  Tr(t2) {
    return this.nr.ji("Listen", t2);
  }
  onMessage(t2) {
    this.rr.reset();
    const e = ns(this.N, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return rt.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? rt.min() : e2.readTime ? jn(e2.readTime) : rt.min();
    }(t2);
    return this.listener.Er(e, n);
  }
  Ir(t2) {
    const e = {};
    e.database = Yn(this.N), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = Ht(s) ? {
        documents: os(t3, s)
      } : {
        query: as(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = qn(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(rt.min()) > 0 && (n2.readTime = Un(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.N, t2);
    const n = us(this.N, t2);
    n && (e.labels = n), this.wr(e);
  }
  Ar(t2) {
    const e = {};
    e.database = Yn(this.N), e.removeTarget = t2, this.wr(e);
  }
};
var eo = class extends Zr {
  constructor(t2, e, n, s, i) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", e, n, i), this.N = s, this.Rr = false;
  }
  get br() {
    return this.Rr;
  }
  start() {
    this.Rr = false, this.lastStreamToken = void 0, super.start();
  }
  mr() {
    this.Rr && this.Pr([]);
  }
  Tr(t2) {
    return this.nr.ji("Write", t2);
  }
  onMessage(t2) {
    if (B2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Rr) {
      this.rr.reset();
      const e = rs(t2.writeResults, t2.commitTime), n = jn(t2.commitTime);
      return this.listener.vr(n, e);
    }
    return B2(!t2.writeResults || t2.writeResults.length === 0), this.Rr = true, this.listener.Vr();
  }
  Sr() {
    const t2 = {};
    t2.database = Yn(this.N), this.wr(t2);
  }
  Pr(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => ss(this.N, t3))
    };
    this.wr(e);
  }
};
var no = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.credentials = t2, this.nr = e, this.N = n, this.Dr = false;
  }
  Cr() {
    if (this.Dr)
      throw new j(K2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  Li(t2, e, n) {
    return this.Cr(), this.credentials.getToken().then((s) => this.nr.Li(t2, e, n, s)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === K2.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new j(K2.UNKNOWN, t3.toString());
    });
  }
  Ki(t2, e, n) {
    return this.Cr(), this.credentials.getToken().then((s) => this.nr.Ki(t2, e, n, s)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === K2.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new j(K2.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Dr = true;
  }
};
var so = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.Nr = 0, this.kr = null, this.$r = true;
  }
  Or() {
    this.Nr === 0 && (this.Fr("Unknown"), this.kr = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.kr = null, this.Mr("Backend didn't respond within 10 seconds."), this.Fr("Offline"), Promise.resolve())));
  }
  Lr(t2) {
    this.state === "Online" ? this.Fr("Unknown") : (this.Nr++, this.Nr >= 1 && (this.Br(), this.Mr(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.Fr("Offline")));
  }
  set(t2) {
    this.Br(), this.Nr = 0, t2 === "Online" && (this.$r = false), this.Fr(t2);
  }
  Fr(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  Mr(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.$r ? (O2(e), this.$r = false) : $("OnlineStateTracker", e);
  }
  Br() {
    this.kr !== null && (this.kr.cancel(), this.kr = null);
  }
};
var io = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.Ur = [], this.qr = new Map(), this.Kr = new Set(), this.jr = [], this.Qr = i, this.Qr.Ti((t3) => {
      n.enqueueAndForget(async () => {
        wo(this) && ($("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = q2(t4);
          e2.Kr.add(4), await oo(e2), e2.Wr.set("Unknown"), e2.Kr.delete(4), await ro(e2);
        }(this));
      });
    }), this.Wr = new so(n, s);
  }
};
async function ro(t2) {
  if (wo(t2))
    for (const e of t2.jr)
      await e(true);
}
async function oo(t2) {
  for (const e of t2.jr)
    await e(false);
}
function ao(t2, e) {
  const n = q2(t2);
  n.qr.has(e.targetId) || (n.qr.set(e.targetId, e), fo(n) ? lo(n) : Co(n).cr() && uo(n, e));
}
function co(t2, e) {
  const n = q2(t2), s = Co(n);
  n.qr.delete(e), s.cr() && ho(n, e), n.qr.size === 0 && (s.cr() ? s.lr() : wo(n) && n.Wr.set("Unknown"));
}
function uo(t2, e) {
  t2.Gr.Y(e.targetId), Co(t2).Ir(e);
}
function ho(t2, e) {
  t2.Gr.Y(e), Co(t2).Ar(e);
}
function lo(t2) {
  t2.Gr = new $n({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Tt: (e) => t2.qr.get(e) || null
  }), Co(t2).start(), t2.Wr.Or();
}
function fo(t2) {
  return wo(t2) && !Co(t2).ar() && t2.qr.size > 0;
}
function wo(t2) {
  return q2(t2).Kr.size === 0;
}
function _o(t2) {
  t2.Gr = void 0;
}
async function mo(t2) {
  t2.qr.forEach((e, n) => {
    uo(t2, e);
  });
}
async function go(t2, e) {
  _o(t2), fo(t2) ? (t2.Wr.Lr(e), lo(t2)) : t2.Wr.set("Unknown");
}
async function yo(t2, e, n) {
  if (t2.Wr.set("Online"), e instanceof xn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.qr.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.qr.delete(s), t3.Gr.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      $("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await po(t2, n2);
    }
  else if (e instanceof Cn ? t2.Gr.rt(e) : e instanceof Nn ? t2.Gr.ft(e) : t2.Gr.ct(e), !n.isEqual(rt.min()))
    try {
      const e2 = await fr(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.Gr._t(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.qr.get(s);
            i && t3.qr.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.qr.get(e4);
          if (!n3)
            return;
          t3.qr.set(e4, n3.withResumeToken(_t.EMPTY_BYTE_STRING, n3.snapshotVersion)), ho(t3, e4);
          const s = new ii(n3.target, e4, 1, n3.sequenceNumber);
          uo(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      $("RemoteStore", "Failed to raise snapshot:", e2), await po(t2, e2);
    }
}
async function po(t2, e, n) {
  if (!Hs(e))
    throw e;
  t2.Kr.add(1), await oo(t2), t2.Wr.set("Offline"), n || (n = () => fr(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    $("RemoteStore", "Retrying IndexedDB access"), await n(), t2.Kr.delete(1), await ro(t2);
  });
}
function To(t2, e) {
  return e().catch((n) => po(t2, n, e));
}
async function Eo(t2) {
  const e = q2(t2), n = No(e);
  let s = e.Ur.length > 0 ? e.Ur[e.Ur.length - 1].batchId : -1;
  for (; Io(e); )
    try {
      const t3 = await _r(e.localStore, s);
      if (t3 === null) {
        e.Ur.length === 0 && n.lr();
        break;
      }
      s = t3.batchId, Ao(e, t3);
    } catch (t3) {
      await po(e, t3);
    }
  Ro(e) && bo(e);
}
function Io(t2) {
  return wo(t2) && t2.Ur.length < 10;
}
function Ao(t2, e) {
  t2.Ur.push(e);
  const n = No(t2);
  n.cr() && n.br && n.Pr(e.mutations);
}
function Ro(t2) {
  return wo(t2) && !No(t2).ar() && t2.Ur.length > 0;
}
function bo(t2) {
  No(t2).start();
}
async function Po(t2) {
  No(t2).Sr();
}
async function vo(t2) {
  const e = No(t2);
  for (const n of t2.Ur)
    e.Pr(n.mutations);
}
async function Vo(t2, e, n) {
  const s = t2.Ur.shift(), i = si.from(s, e, n);
  await To(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await Eo(t2);
}
async function So(t2, e) {
  e && No(t2).br && await async function(t3, e2) {
    if (n = e2.code, fn(n) && n !== K2.ABORTED) {
      const n2 = t3.Ur.shift();
      No(t3).hr(), await To(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await Eo(t3);
    }
    var n;
  }(t2, e), Ro(t2) && bo(t2);
}
async function Do(t2, e) {
  const n = q2(t2);
  e ? (n.Kr.delete(2), await ro(n)) : e || (n.Kr.add(2), await oo(n), n.Wr.set("Unknown"));
}
function Co(t2) {
  return t2.zr || (t2.zr = function(t3, e, n) {
    const s = q2(t3);
    return s.Cr(), new to(e, s.nr, s.credentials, s.N, n);
  }(t2.datastore, t2.asyncQueue, {
    Si: mo.bind(null, t2),
    Ci: go.bind(null, t2),
    Er: yo.bind(null, t2)
  }), t2.jr.push(async (e) => {
    e ? (t2.zr.hr(), fo(t2) ? lo(t2) : t2.Wr.set("Unknown")) : (await t2.zr.stop(), _o(t2));
  })), t2.zr;
}
function No(t2) {
  return t2.Hr || (t2.Hr = function(t3, e, n) {
    const s = q2(t3);
    return s.Cr(), new eo(e, s.nr, s.credentials, s.N, n);
  }(t2.datastore, t2.asyncQueue, {
    Si: Po.bind(null, t2),
    Ci: So.bind(null, t2),
    Vr: vo.bind(null, t2),
    vr: Vo.bind(null, t2)
  }), t2.jr.push(async (e) => {
    e ? (t2.Hr.hr(), await Eo(t2)) : (await t2.Hr.stop(), t2.Ur.length > 0 && ($("RemoteStore", `Stopping write stream with ${t2.Ur.length} pending writes`), t2.Ur = []));
  })), t2.Hr;
}
var xo = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new Q2(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new xo(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new j(K2.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function ko(t2, e) {
  if (O2("AsyncQueue", `${e}: ${t2}`), Hs(t2))
    return new j(K2.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var $o = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || Pt.comparator(e.key, n.key) : (t3, e) => Pt.comparator(t3.key, e.key), this.keyedMap = In(), this.sortedSet = new wn(this.comparator);
  }
  static emptySet(t2) {
    return new $o(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof $o))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new $o();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var Oo = class {
  constructor() {
    this.Jr = new wn(Pt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.Jr.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.Jr = this.Jr.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.Jr = this.Jr.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.Jr = this.Jr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.Jr = this.Jr.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.Jr = this.Jr.remove(e) : t2.type === 1 && n.type === 2 ? this.Jr = this.Jr.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.Jr = this.Jr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : L2() : this.Jr = this.Jr.insert(e, t2);
  }
  Yr() {
    const t2 = [];
    return this.Jr.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var Fo = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = a;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new Fo(t2, e, $o.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && Ae(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Mo = class {
  constructor() {
    this.Xr = void 0, this.listeners = [];
  }
};
var Lo = class {
  constructor() {
    this.queries = new ji((t2) => Re(t2), Ae), this.onlineState = "Unknown", this.Zr = new Set();
  }
};
async function Bo(t2, e) {
  const n = q2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Mo()), i)
    try {
      r.Xr = await n.onListen(s);
    } catch (t3) {
      const n2 = ko(t3, `Initialization of query '${be(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.eo(n.onlineState), r.Xr) {
    e.no(r.Xr) && jo(n);
  }
}
async function Uo(t2, e) {
  const n = q2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function qo(t2, e) {
  const n = q2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.no(t3) && (s = true);
      i.Xr = t3;
    }
  }
  s && jo(n);
}
function Ko(t2, e, n) {
  const s = q2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function jo(t2) {
  t2.Zr.forEach((t3) => {
    t3.next();
  });
}
var Qo = class {
  constructor(t2, e, n) {
    this.query = t2, this.so = e, this.io = false, this.ro = null, this.onlineState = "Unknown", this.options = n || {};
  }
  no(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new Fo(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.io ? this.oo(t2) && (this.so.next(t2), e = true) : this.ao(t2, this.onlineState) && (this.co(t2), e = true), this.ro = t2, e;
  }
  onError(t2) {
    this.so.error(t2);
  }
  eo(t2) {
    this.onlineState = t2;
    let e = false;
    return this.ro && !this.io && this.ao(this.ro, t2) && (this.co(this.ro), e = true), e;
  }
  ao(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.uo || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  oo(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.ro && this.ro.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  co(t2) {
    t2 = Fo.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.io = true, this.so.next(t2);
  }
};
var Wo = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  ho() {
    return "metadata" in this.payload;
  }
};
var Go = class {
  constructor(t2) {
    this.N = t2;
  }
  zn(t2) {
    return zn(this.N, t2);
  }
  Hn(t2) {
    return t2.metadata.exists ? ts(this.N, t2.document, false) : Kt.newNoDocument(this.zn(t2.metadata.name), this.Jn(t2.metadata.readTime));
  }
  Jn(t2) {
    return jn(t2);
  }
};
var zo = class {
  constructor(t2, e, n) {
    this.lo = t2, this.localStore = e, this.N = n, this.queries = [], this.documents = [], this.progress = Ho(t2);
  }
  fo(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  wo(t2) {
    const e = new Map(), n = new Go(this.N);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.zn(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || Pn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await Ir(this.localStore, new Go(this.N), this.documents, this.lo.id), e = this.wo(this.documents);
    for (const t3 of this.queries)
      await Ar(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new ir(Object.assign({}, this.progress), t2);
  }
};
function Ho(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var Jo = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Yo = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Xo = class {
  constructor(t2, e) {
    this.query = t2, this._o = e, this.mo = null, this.current = false, this.yo = Pn(), this.mutatedKeys = Pn(), this.po = ve(t2), this.To = new $o(this.po);
  }
  get Eo() {
    return this._o;
  }
  Io(t2, e) {
    const n = e ? e.Ao : new Oo(), s = e ? e.To : this.To;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const a = _e(this.query) && s.size === this.query.limit ? s.last() : null, c = me(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const u = s.get(t3), h = Pe(this.query, e2) ? e2 : null, l2 = !!u && this.mutatedKeys.has(u.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (u && h) {
        u.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Ro(u, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (a && this.po(h, a) > 0 || c && this.po(h, c) < 0) && (o = true));
      } else
        !u && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : u && !h && (n.track({
          type: 1,
          doc: u
        }), d = true, (a || c) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), _e(this.query) || me(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = _e(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      To: r,
      Ao: n,
      Ln: o,
      mutatedKeys: i
    };
  }
  Ro(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.To;
    this.To = t2.To, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.Ao.Yr();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.po(t3.doc, e2.doc)), this.bo(n);
    const r = e ? this.Po() : [], o = this.yo.size === 0 && this.current ? 1 : 0, a = o !== this.mo;
    if (this.mo = o, i.length !== 0 || a) {
      return {
        snapshot: new Fo(this.query, t2.To, s, i, t2.mutatedKeys, o === 0, a, false),
        vo: r
      };
    }
    return {
      vo: r
    };
  }
  eo(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      To: this.To,
      Ao: new Oo(),
      mutatedKeys: this.mutatedKeys,
      Ln: false
    }, false)) : {
      vo: []
    };
  }
  Vo(t2) {
    return !this._o.has(t2) && (!!this.To.has(t2) && !this.To.get(t2).hasLocalMutations);
  }
  bo(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this._o = this._o.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this._o = this._o.delete(t3)), this.current = t2.current);
  }
  Po() {
    if (!this.current)
      return [];
    const t2 = this.yo;
    this.yo = Pn(), this.To.forEach((t3) => {
      this.Vo(t3.key) && (this.yo = this.yo.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.yo.has(t3) || e.push(new Yo(t3));
    }), this.yo.forEach((n) => {
      t2.has(n) || e.push(new Jo(n));
    }), e;
  }
  So(t2) {
    this._o = t2.Gn, this.yo = Pn();
    const e = this.Io(t2.documents);
    return this.applyChanges(e, true);
  }
  Do() {
    return Fo.fromInitialDocuments(this.query, this.To, this.mutatedKeys, this.mo === 0);
  }
};
var Zo = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var ta2 = class {
  constructor(t2) {
    this.key = t2, this.Co = false;
  }
};
var ea2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.No = {}, this.xo = new ji((t3) => Re(t3), Ae), this.ko = new Map(), this.$o = new Set(), this.Oo = new wn(Pt.comparator), this.Fo = new Map(), this.Mo = new br(), this.Lo = {}, this.Bo = new Map(), this.Uo = Ni.ie(), this.onlineState = "Unknown", this.qo = void 0;
  }
  get isPrimaryClient() {
    return this.qo === true;
  }
};
async function na2(t2, e) {
  const n = Ca2(t2);
  let s, i;
  const r = n.xo.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Do();
  else {
    const t3 = await mr(n.localStore, Ee(e)), r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await sa2(n, e, s, r2 === "current"), n.isPrimaryClient && ao(n.remoteStore, t3);
  }
  return i;
}
async function sa2(t2, e, n, s) {
  t2.Ko = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.Io(n3);
    i2.Ln && (i2 = await yr(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.Io(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return ma2(t3, e3.targetId, o2.vo), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await yr(t2.localStore, e, true), r = new Xo(e, i.Gn), o = r.Io(i.documents), a = Dn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), c = r.applyChanges(o, t2.isPrimaryClient, a);
  ma2(t2, n, c.vo);
  const u = new Zo(e, n, r);
  return t2.xo.set(e, u), t2.ko.has(n) ? t2.ko.get(n).push(e) : t2.ko.set(n, [e]), c.snapshot;
}
async function ia2(t2, e) {
  const n = q2(t2), s = n.xo.get(e), i = n.ko.get(s.targetId);
  if (i.length > 1)
    return n.ko.set(s.targetId, i.filter((t3) => !Ae(t3, e))), void n.xo.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await gr(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), co(n.remoteStore, s.targetId), wa(n, s.targetId);
    }).catch(Fi);
  } else
    wa(n, s.targetId), await gr(n.localStore, s.targetId, true);
}
async function ra2(t2, e, n) {
  const s = Na2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = q2(t4), s2 = it.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), Pn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.Qn.Pn(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = Xe(t6, r.get(t6.key));
          e3 != null && o.push(new nn(t6.key, e3, qt(e3.value.mapValue), Ge.exists(true)));
        }
        return n2.In.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.Lo[t4.currentUser.toKey()];
      s2 || (s2 = new wn(et));
      s2 = s2.insert(e2, n2), t4.Lo[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await pa2(s, t3.changes), await Eo(s.remoteStore);
  } catch (t3) {
    const e2 = ko(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function oa2(t2, e) {
  const n = q2(t2);
  try {
    const t3 = await dr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.Fo.get(e2);
      s && (B2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Co = true : t4.modifiedDocuments.size > 0 ? B2(s.Co) : t4.removedDocuments.size > 0 && (B2(s.Co), s.Co = false));
    }), await pa2(n, t3, e);
  } catch (t3) {
    await Fi(t3);
  }
}
function aa2(t2, e, n) {
  const s = q2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.xo.forEach((n2, s2) => {
      const i = s2.view.eo(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = q2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.eo(e2) && (s2 = true);
      }), s2 && jo(n2);
    }(s.eventManager, e), t3.length && s.No.Er(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function ca(t2, e, n) {
  const s = q2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.Fo.get(e), r = i && i.key;
  if (r) {
    let t3 = new wn(Pt.comparator);
    t3 = t3.insert(r, Kt.newNoDocument(r, rt.min()));
    const n2 = Pn().add(r), i2 = new Sn(rt.min(), new Map(), new gn(et), t3, n2);
    await oa2(s, i2), s.Oo = s.Oo.remove(r), s.Fo.delete(e), ya2(s);
  } else
    await gr(s.localStore, e, false).then(() => wa(s, e, n)).catch(Fi);
}
async function ua2(t2, e) {
  const n = q2(t2), s = e.batch.batchId;
  try {
    const t3 = await lr(n.localStore, e);
    da2(n, s, null), fa2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await pa2(n, t3);
  } catch (t3) {
    await Fi(t3);
  }
}
async function ha2(t2, e, n) {
  const s = q2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = q2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.In.lookupMutationBatch(t5, e2).next((e3) => (B2(e3 !== null), s2 = e3.keys(), n2.In.removeMutationBatch(t5, e3))).next(() => n2.In.performConsistencyCheck(t5)).next(() => n2.Qn.Pn(t5, s2));
      });
    }(s.localStore, e);
    da2(s, e, n), fa2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await pa2(s, t3);
  } catch (n2) {
    await Fi(n2);
  }
}
async function la2(t2, e) {
  const n = q2(t2);
  wo(n.remoteStore) || $("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = q2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.In.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.Bo.get(t3) || [];
    s.push(e), n.Bo.set(t3, s);
  } catch (t3) {
    const n2 = ko(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function fa2(t2, e) {
  (t2.Bo.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.Bo.delete(e);
}
function da2(t2, e, n) {
  const s = q2(t2);
  let i = s.Lo[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.Lo[s.currentUser.toKey()] = i;
  }
}
function wa(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.ko.get(e))
    t2.xo.delete(s), n && t2.No.jo(s, n);
  if (t2.ko.delete(e), t2.isPrimaryClient) {
    t2.Mo.cs(e).forEach((e2) => {
      t2.Mo.containsKey(e2) || _a(t2, e2);
    });
  }
}
function _a(t2, e) {
  t2.$o.delete(e.path.canonicalString());
  const n = t2.Oo.get(e);
  n !== null && (co(t2.remoteStore, n), t2.Oo = t2.Oo.remove(e), t2.Fo.delete(n), ya2(t2));
}
function ma2(t2, e, n) {
  for (const s of n)
    if (s instanceof Jo)
      t2.Mo.addReference(s.key, e), ga(t2, s);
    else if (s instanceof Yo) {
      $("SyncEngine", "Document no longer in limbo: " + s.key), t2.Mo.removeReference(s.key, e);
      t2.Mo.containsKey(s.key) || _a(t2, s.key);
    } else
      L2();
}
function ga(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.Oo.get(n) || t2.$o.has(s) || ($("SyncEngine", "New document in limbo: " + n), t2.$o.add(s), ya2(t2));
}
function ya2(t2) {
  for (; t2.$o.size > 0 && t2.Oo.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.$o.values().next().value;
    t2.$o.delete(e);
    const n = new Pt(ht.fromString(e)), s = t2.Uo.next();
    t2.Fo.set(s, new ta2(n)), t2.Oo = t2.Oo.insert(n, s), ao(t2.remoteStore, new ii(Ee(we(n.path)), s, 2, X2.T));
  }
}
async function pa2(t2, e, n) {
  const s = q2(t2), i = [], r = [], o = [];
  s.xo.isEmpty() || (s.xo.forEach((t3, a) => {
    o.push(s.Ko(a, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(a.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = or.kn(a.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.No.Er(i), await async function(t3, e2) {
    const n2 = q2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => js.forEach(e2, (e3) => js.forEach(e3.Nn, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => js.forEach(e3.xn, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Hs(t4))
        throw t4;
      $("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.Un.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.Un = n2.Un.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function Ta(t2, e) {
  const n = q2(t2);
  if (!n.currentUser.isEqual(e)) {
    $("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await hr(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.Bo.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new j(K2.CANCELLED, e2));
        });
      }), t4.Bo.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await pa2(n, t3.Wn);
  }
}
function Ea(t2, e) {
  const n = q2(t2), s = n.Fo.get(e);
  if (s && s.Co)
    return Pn().add(s.key);
  {
    let t3 = Pn();
    const s2 = n.ko.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.xo.get(e2);
      t3 = t3.unionWith(s3.view.Eo);
    }
    return t3;
  }
}
async function Ia2(t2, e) {
  const n = q2(t2), s = await yr(n.localStore, e.query, true), i = e.view.So(s);
  return n.isPrimaryClient && ma2(n, e.targetId, i.vo), i;
}
async function Aa2(t2) {
  const e = q2(t2);
  return Tr(e.localStore).then((t3) => pa2(e, t3));
}
async function Ra2(t2, e, n, s) {
  const i = q2(t2), r = await function(t3, e2) {
    const n2 = q2(t3), s2 = q2(n2.In);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.Xt(t4, e2).next((e3) => e3 ? n2.Qn.Pn(t4, e3) : js.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await Eo(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (da2(i, e, s || null), fa2(i, e), function(t3, e2) {
    q2(q2(t3).In).te(e2);
  }(i.localStore, e)) : L2(), await pa2(i, r)) : $("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function ba2(t2, e) {
  const n = q2(t2);
  if (Ca2(n), Na2(n), e === true && n.qo !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await Pa(n, t3.toArray());
    n.qo = true, await Do(n.remoteStore, true);
    for (const t4 of e2)
      ao(n.remoteStore, t4);
  } else if (e === false && n.qo !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.ko.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (wa(n, i), gr(n.localStore, i, true))), co(n.remoteStore, i);
    }), await e2, await Pa(n, t3), function(t4) {
      const e3 = q2(t4);
      e3.Fo.forEach((t5, n2) => {
        co(e3.remoteStore, n2);
      }), e3.Mo.us(), e3.Fo = new Map(), e3.Oo = new wn(Pt.comparator);
    }(n), n.qo = false, await Do(n.remoteStore, false);
  }
}
async function Pa(t2, e, n) {
  const s = q2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.ko.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await mr(s.localStore, Ee(n2[0]));
      for (const t4 of n2) {
        const e3 = s.xo.get(t4), n3 = await Ia2(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await pr(s.localStore, t3);
      e2 = await mr(s.localStore, n3), await sa2(s, va(n3), t3, false);
    }
    i.push(e2);
  }
  return s.No.Er(r), i;
}
function va(t2) {
  return de(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function Va2(t2) {
  const e = q2(t2);
  return q2(q2(e.localStore).persistence).pn();
}
async function Sa2(t2, e, n, s) {
  const i = q2(t2);
  if (i.qo)
    $("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.ko.has(e))
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await Tr(i.localStore), s2 = Sn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await pa2(i, t3, s2);
        break;
      }
      case "rejected":
        await gr(i.localStore, e, true), wa(i, e, s);
        break;
      default:
        L2();
    }
}
async function Da(t2, e, n) {
  const s = Ca2(t2);
  if (s.qo) {
    for (const t3 of e) {
      if (s.ko.has(t3)) {
        $("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await pr(s.localStore, t3), n2 = await mr(s.localStore, e2);
      await sa2(s, va(e2), n2.targetId, false), ao(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.ko.has(t3) && await gr(s.localStore, t3, false).then(() => {
        co(s.remoteStore, t3), wa(s, t3);
      }).catch(Fi);
  }
}
function Ca2(t2) {
  const e = q2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = oa2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Ea.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = ca.bind(null, e), e.No.Er = qo.bind(null, e.eventManager), e.No.jo = Ko.bind(null, e.eventManager), e;
}
function Na2(t2) {
  const e = q2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = ua2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = ha2.bind(null, e), e;
}
function xa2(t2, e, n) {
  const s = q2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = q2(t4), s3 = jn(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Je.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n2._updateProgress(Ho(s2));
      const i = new zo(s2, t3.localStore, e2.N);
      let r = await e2.Qo();
      for (; r; ) {
        const t4 = await i.fo(r);
        t4 && n2._updateProgress(t4), r = await e2.Qo();
      }
      const o = await i.complete();
      await pa2(t3, o.En, void 0), await function(t4, e3) {
        const n3 = q2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Je.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress);
    } catch (t4) {
      F2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4);
    }
  })(s, e, n).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
var ka2 = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.N = Yr(t2.databaseInfo.databaseId), this.sharedClientState = this.Wo(t2), this.persistence = this.Go(t2), await this.persistence.start(), this.gcScheduler = this.zo(t2), this.localStore = this.Ho(t2);
  }
  zo(t2) {
    return null;
  }
  Ho(t2) {
    return ur(this.persistence, new ar(), t2.initialUser, this.N);
  }
  Go(t2) {
    return new Cr(xr.Ns, this.N);
  }
  Wo(t2) {
    return new Kr();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var $a2 = class extends ka2 {
  constructor(t2, e, n) {
    super(), this.Jo = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await Er(this.localStore), await this.Jo.initialize(this, t2), await Na2(this.Jo.syncEngine), await Eo(this.Jo.remoteStore), await this.persistence.nn(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  Ho(t2) {
    return ur(this.persistence, new ar(), t2.initialUser, this.N);
  }
  zo(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new Bi(e, t2.asyncQueue);
  }
  Go(t2) {
    const e = sr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? Ri.withCacheSize(this.cacheSizeBytes) : Ri.DEFAULT;
    return new tr(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, Hr(), Jr(), this.N, this.sharedClientState, !!this.forceOwnership);
  }
  Wo(t2) {
    return new Kr();
  }
};
var Oa = class extends $a2 {
  constructor(t2, e) {
    super(t2, e, false), this.Jo = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.Jo.syncEngine;
    this.sharedClientState instanceof qr && (this.sharedClientState.syncEngine = {
      _i: Ra2.bind(null, e),
      mi: Sa2.bind(null, e),
      gi: Da.bind(null, e),
      pn: Va2.bind(null, e),
      wi: Aa2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.nn(async (t3) => {
      await ba2(this.Jo.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  Wo(t2) {
    const e = Hr();
    if (!qr.bt(e))
      throw new j(K2.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = sr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new qr(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var Fa2 = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => aa2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Ta.bind(null, this.syncEngine), await Do(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Lo();
  }
  createDatastore(t2) {
    const e = Yr(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new zr(s));
    var s;
    return function(t3, e2, n2) {
      return new no(t3, e2, n2);
    }(t2.credentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => aa2(this.syncEngine, t3, 0), r = Qr.bt() ? new Qr() : new jr(), new io(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const a = new ea2(t3, e2, n, s, i, r);
      return o && (a.qo = true), a;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = q2(t2);
      $("RemoteStore", "RemoteStore shutting down."), e.Kr.add(5), await oo(e), e.Qr.shutdown(), e.Wr.set("Unknown");
    }(this.remoteStore);
  }
};
function Ma2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var La2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.Yo(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.Yo(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Xo() {
    this.muted = true;
  }
  Yo(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var Ba = class {
  constructor(t2, e) {
    this.Zo = t2, this.N = e, this.metadata = new Q2(), this.buffer = new Uint8Array(), this.ta = new TextDecoder("utf-8"), this.ea().then((t3) => {
      t3 && t3.ho() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Zo.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async Qo() {
    return await this.getMetadata(), this.ea();
  }
  async ea() {
    const t2 = await this.na();
    if (t2 === null)
      return null;
    const e = this.ta.decode(t2), n = Number(e);
    isNaN(n) && this.sa(`length string (${e}) is not valid number`);
    const s = await this.ia(n);
    return new Wo(JSON.parse(s), t2.length + n);
  }
  ra() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async na() {
    for (; this.ra() < 0; ) {
      if (await this.oa())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.ra();
    t2 < 0 && this.sa("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async ia(t2) {
    for (; this.buffer.length < t2; ) {
      await this.oa() && this.sa("Reached the end of bundle when more is expected.");
    }
    const e = this.ta.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  sa(t2) {
    throw this.Zo.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async oa() {
    const t2 = await this.Zo.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var Ua2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new j(K2.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = q2(t3), s = Yn(n.N) + "/documents", i = {
        documents: e2.map((t4) => Gn(n.N, t4))
      }, r = await n.Ki("BatchGetDocuments", s, i), o = new Map();
      r.forEach((t4) => {
        const e3 = es(n.N, t4);
        o.set(e3.key.toString(), e3);
      });
      const a = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        B2(!!e3), a.push(e3);
      }), a;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new an(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = Pt.fromPath(e);
      this.mutations.push(new cn(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = q2(t3), s = Yn(n.N) + "/documents", i = {
        writes: e.map((t4) => ss(n.N, t4))
      };
      await n.Li("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw L2();
      e = rt.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new j(K2.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? Ge.updateTime(e) : Ge.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(rt.min()))
        throw new j(K2.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return Ge.updateTime(e);
    }
    return Ge.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var qa2 = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.aa = 5, this.rr = new Xr(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.aa -= 1, this.ca();
  }
  ca() {
    this.rr.Xi(async () => {
      const t2 = new Ua2(this.datastore), e = this.ua(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.ha(t3);
        }));
      }).catch((t3) => {
        this.ha(t3);
      });
    });
  }
  ua(t2) {
    try {
      const e = this.updateFunction(t2);
      return !At(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  ha(t2) {
    this.aa > 0 && this.la(t2) ? (this.aa -= 1, this.asyncQueue.enqueueAndForget(() => (this.ca(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  la(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !fn(e);
    }
    return false;
  }
};
var Ka2 = class {
  constructor(t2, e, n) {
    this.credentials = t2, this.asyncQueue = e, this.databaseInfo = n, this.user = D2.UNAUTHENTICATED, this.clientId = tt.I(), this.credentialListener = () => Promise.resolve(), this.credentials.start(e, async (t3) => {
      $("FirestoreClient", "Received user=", t3.uid), await this.credentialListener(t3), this.user = t3;
    });
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      credentials: this.credentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.credentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new j(K2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new Q2();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.credentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = ko(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function ja2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), $("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await hr(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function Qa(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Wa2(t2);
  $("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => async function(t4, e2) {
    const n2 = q2(t4);
    n2.asyncQueue.verifyOperationInProgress(), $("RemoteStore", "RemoteStore received new credentials");
    const s2 = wo(n2);
    n2.Kr.add(3), await oo(n2), s2 && n2.Wr.set("Unknown"), await n2.remoteSyncer.handleCredentialChange(e2), n2.Kr.delete(3), await ro(n2);
  }(e.remoteStore, t3)), t2.onlineComponents = e;
}
async function Wa2(t2) {
  return t2.offlineComponents || ($("FirestoreClient", "Using default OfflineComponentProvider"), await ja2(t2, new ka2())), t2.offlineComponents;
}
async function Ga2(t2) {
  return t2.onlineComponents || ($("FirestoreClient", "Using default OnlineComponentProvider"), await Qa(t2, new Fa2())), t2.onlineComponents;
}
function za2(t2) {
  return Wa2(t2).then((t3) => t3.persistence);
}
function Ha2(t2) {
  return Wa2(t2).then((t3) => t3.localStore);
}
function Ja2(t2) {
  return Ga2(t2).then((t3) => t3.remoteStore);
}
function Ya2(t2) {
  return Ga2(t2).then((t3) => t3.syncEngine);
}
async function Xa2(t2) {
  const e = await Ga2(t2), n = e.eventManager;
  return n.onListen = na2.bind(null, e.syncEngine), n.onUnlisten = ia2.bind(null, e.syncEngine), n;
}
function Za2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await za2(t2), n = await Ja2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = q2(t3);
      return e2.Kr.delete(0), ro(e2);
    }(n);
  });
}
function tc2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await za2(t2), n = await Ja2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = q2(t3);
      e2.Kr.add(0), await oo(e2), e2.Wr.set("Offline");
    }(n);
  });
}
function ec2(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = q2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.Qn.An(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new j(K2.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = ko(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Ha2(t2), e, n)), n.promise;
}
function nc2(t2, e, n = {}) {
  const s = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new La2({
      next: (r2) => {
        e2.enqueueAndForget(() => Uo(t3, o));
        const a = r2.docs.has(n2);
        !a && r2.fromCache ? i.reject(new j(K2.UNAVAILABLE, "Failed to get document because the client is offline.")) : a && r2.fromCache && s2 && s2.source === "server" ? i.reject(new j(K2.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Qo(we(n2.path), r, {
      includeMetadataChanges: true,
      uo: true
    });
    return Bo(t3, o);
  }(await Xa2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function sc2(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await yr(t3, e2, true), i = new Xo(e2, s.Gn), r = i.Io(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = ko(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Ha2(t2), e, n)), n.promise;
}
function ic2(t2, e, n = {}) {
  const s = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new La2({
      next: (n3) => {
        e2.enqueueAndForget(() => Uo(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new j(K2.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Qo(n2, r, {
      includeMetadataChanges: true,
      uo: true
    });
    return Bo(t3, o);
  }(await Xa2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function rc2(t2, e) {
  const n = new La2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    q2(t3).Zr.add(e2), e2.next();
  }(await Xa2(t2), n)), () => {
    n.Xo(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      q2(t3).Zr.delete(e2);
    }(await Xa2(t2), n));
  };
}
function oc2(t2, e) {
  const n = new Q2();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Ga2(t3).then((t4) => t4.datastore);
    }(t2);
    new qa2(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function ac2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new Ba(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Ma2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Ma2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Yr(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    xa2(await Ya2(t2), i, s);
  });
}
function cc2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = q2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Je.getNamedQuery(t4, e2));
  }(await Ha2(t2), e));
}
var uc2 = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = a;
  }
};
var hc2 = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof hc2 && t2.projectId === this.projectId && t2.database === this.database;
  }
};
var lc2 = new Map();
function fc2(t2, e, n) {
  if (!n)
    throw new j(K2.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function dc2(t2, e, n, s) {
  if (e === true && s === true)
    throw new j(K2.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function wc2(t2) {
  if (!Pt.isDocumentKey(t2))
    throw new j(K2.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function _c(t2) {
  if (Pt.isDocumentKey(t2))
    throw new j(K2.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function mc2(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : L2();
}
function gc2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new j(K2.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = mc2(t2);
      throw new j(K2.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function yc2(t2, e) {
  if (e <= 0)
    throw new j(K2.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var pc2 = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new j(K2.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new j(K2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, dc2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var Tc2 = class {
  constructor(t2, e) {
    this._credentials = e, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new pc2({}), this._settingsFrozen = false, t2 instanceof hc2 ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new j(K2.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new hc2(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new j(K2.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new j(K2.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new pc2(t2), t2.credentials !== void 0 && (this._credentials = function(t3) {
      if (!t3)
        return new G();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return B2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new Y2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new j(K2.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = lc2.get(t2);
      e && ($("ComponentProvider", "Removing Datastore"), lc2.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function Ec2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = gc2(t2, Tc2))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && F2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = D2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new j(K2.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new D2(r2);
    }
    t2._credentials = new z2(new W2(e2, n2));
  }
}
var Ic2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new Rc2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new Ic2(this.firestore, t2, this._key);
  }
};
var Ac2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new Ac2(this.firestore, t2, this._query);
  }
};
var Rc2 = class extends Ac2 {
  constructor(t2, e, n) {
    super(t2, e, we(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new Ic2(this.firestore, null, new Pt(t2));
  }
  withConverter(t2) {
    return new Rc2(this.firestore, t2, this._path);
  }
};
function bc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), fc2("collection", "path", e), t2 instanceof Tc2) {
    const s = ht.fromString(e, ...n);
    return _c(s), new Rc2(t2, null, s);
  }
  {
    if (!(t2 instanceof Ic2 || t2 instanceof Rc2))
      throw new j(K2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(ht.fromString(e, ...n));
    return _c(s), new Rc2(t2.firestore, null, s);
  }
}
function Pc2(t2, e) {
  if (t2 = gc2(t2, Tc2), fc2("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new j(K2.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new Ac2(t2, null, function(t3) {
    return new fe(ht.emptyPath(), t3);
  }(e));
}
function vc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = tt.I()), fc2("doc", "path", e), t2 instanceof Tc2) {
    const s = ht.fromString(e, ...n);
    return wc2(s), new Ic2(t2, null, new Pt(s));
  }
  {
    if (!(t2 instanceof Ic2 || t2 instanceof Rc2))
      throw new j(K2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(ht.fromString(e, ...n));
    return wc2(s), new Ic2(t2.firestore, t2 instanceof Rc2 ? t2.converter : null, new Pt(s));
  }
}
function Vc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof Ic2 || t2 instanceof Rc2) && (e instanceof Ic2 || e instanceof Rc2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function Sc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof Ac2 && e instanceof Ac2 && (t2.firestore === e.firestore && Ae(t2._query, e._query) && t2.converter === e.converter);
}
var Dc2 = class {
  constructor() {
    this.fa = Promise.resolve(), this.da = [], this.wa = false, this._a = [], this.ma = null, this.ga = false, this.ya = false, this.pa = [], this.rr = new Xr(this, "async_queue_retry"), this.Ta = () => {
      const t3 = Jr();
      t3 && $("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.rr.tr();
    };
    const t2 = Jr();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Ta);
  }
  get isShuttingDown() {
    return this.wa;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Ea(), this.Ia(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.wa) {
      this.wa = true, this.ya = t2 || false;
      const e = Jr();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Ta);
    }
  }
  enqueue(t2) {
    if (this.Ea(), this.wa)
      return new Promise(() => {
      });
    const e = new Q2();
    return this.Ia(() => this.wa && this.ya ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.da.push(t2), this.Aa()));
  }
  async Aa() {
    if (this.da.length !== 0) {
      try {
        await this.da[0](), this.da.shift(), this.rr.reset();
      } catch (t2) {
        if (!Hs(t2))
          throw t2;
        $("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.da.length > 0 && this.rr.Xi(() => this.Aa());
    }
  }
  Ia(t2) {
    const e = this.fa.then(() => (this.ga = true, t2().catch((t3) => {
      this.ma = t3, this.ga = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw O2("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.ga = false, t3))));
    return this.fa = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Ea(), this.pa.indexOf(t2) > -1 && (e = 0);
    const s = xo.createAndSchedule(this, t2, e, n, (t3) => this.Ra(t3));
    return this._a.push(s), s;
  }
  Ea() {
    this.ma && L2();
  }
  verifyOperationInProgress() {
  }
  async ba() {
    let t2;
    do {
      t2 = this.fa, await t2;
    } while (t2 !== this.fa);
  }
  Pa(t2) {
    for (const e of this._a)
      if (e.timerId === t2)
        return true;
    return false;
  }
  va(t2) {
    return this.ba().then(() => {
      this._a.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this._a)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.ba();
    });
  }
  Va(t2) {
    this.pa.push(t2);
  }
  Ra(t2) {
    const e = this._a.indexOf(t2);
    this._a.splice(e, 1);
  }
};
function Cc2(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var Nc2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new Q2(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var xc2 = -1;
var kc2 = class extends Tc2 {
  constructor(t2, e) {
    super(t2, e), this.type = "firestore", this._queue = new Dc2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Mc2(this), this._firestoreClient.terminate();
  }
};
function $c2(t2, e) {
  const n = _getProvider(t2, "firestore");
  if (n.isInitialized()) {
    const t3 = n.getImmediate(), s = n.getOptions();
    if (deepEqual(s, e))
      return t3;
    throw new j(K2.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (e.cacheSizeBytes !== void 0 && e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
    throw new j(K2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n.initialize({
    options: e
  });
}
function Oc2(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function Fc2(t2) {
  return t2._firestoreClient || Mc2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Mc2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new uc2(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new Ka2(t2._credentials, t2._queue, s);
}
function Lc2(t2, e) {
  Hc2(t2 = gc2(t2, kc2));
  const n = Fc2(t2), s = t2._freezeSettings(), i = new Fa2();
  return Uc2(n, i, new $a2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Bc2(t2) {
  Hc2(t2 = gc2(t2, kc2));
  const e = Fc2(t2), n = t2._freezeSettings(), s = new Fa2();
  return Uc2(e, s, new Oa(s, n.cacheSizeBytes));
}
function Uc2(t2, e, n) {
  const s = new Q2();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await ja2(t2, n), await Qa(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === K2.FAILED_PRECONDITION || t4.code === K2.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function qc2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new j(K2.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new Q2();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!Ws.bt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await Ws.delete(e2);
      }(sr(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Kc2(t2) {
  return function(t3) {
    const e = new Q2();
    return t3.asyncQueue.enqueueAndForget(async () => la2(await Ya2(t3), e)), e.promise;
  }(Fc2(t2 = gc2(t2, kc2)));
}
function jc2(t2) {
  return Za2(Fc2(t2 = gc2(t2, kc2)));
}
function Qc2(t2) {
  return tc2(Fc2(t2 = gc2(t2, kc2)));
}
function Wc2(t2) {
  return _removeServiceInstance(t2.app, "firestore"), t2._delete();
}
function Gc2(t2, e) {
  const n = Fc2(t2 = gc2(t2, kc2)), s = new Nc2();
  return ac2(n, t2._databaseId, e, s), s;
}
function zc2(t2, e) {
  return cc2(Fc2(t2 = gc2(t2, kc2)), e).then((e2) => e2 ? new Ac2(t2, null, e2.query) : null);
}
function Hc2(t2) {
  if (t2._initialized || t2._terminated)
    throw new j(K2.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Jc2 = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new j(K2.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new ft(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function Yc2() {
  return new Jc2("__name__");
}
var Xc2 = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Xc2(_t.fromBase64String(t2));
    } catch (t3) {
      throw new j(K2.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Xc2(_t.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Zc2 = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var tu = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new j(K2.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new j(K2.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return et(this._lat, t2._lat) || et(this._long, t2._long);
  }
};
var eu = /^__.*__$/;
var nu = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new nn(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new en(t2, this.data, e, this.fieldTransforms);
  }
};
var su = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new nn(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function iu(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L2();
  }
}
var ru = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.N = n, this.ignoreUndefinedProperties = s, i === void 0 && this.Sa(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Da() {
    return this.settings.Da;
  }
  Ca(t2) {
    return new ru(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.N, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Na(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Ca({
      path: n,
      xa: false
    });
    return s.ka(t2), s;
  }
  $a(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Ca({
      path: n,
      xa: false
    });
    return s.Sa(), s;
  }
  Oa(t2) {
    return this.Ca({
      path: void 0,
      xa: true
    });
  }
  Fa(t2) {
    return bu(t2, this.settings.methodName, this.settings.Ma || false, this.path, this.settings.La);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Sa() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.ka(this.path.get(t2));
  }
  ka(t2) {
    if (t2.length === 0)
      throw this.Fa("Document fields must not be empty");
    if (iu(this.Da) && eu.test(t2))
      throw this.Fa('Document fields cannot begin and end with "__"');
  }
};
var ou = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.N = n || Yr(t2);
  }
  Ba(t2, e, n, s = false) {
    return new ru({
      Da: t2,
      methodName: e,
      La: n,
      path: ft.emptyPath(),
      xa: false,
      Ma: s
    }, this.databaseId, this.N, this.ignoreUndefinedProperties);
  }
};
function au(t2) {
  const e = t2._freezeSettings(), n = Yr(t2._databaseId);
  return new ou(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function cu(t2, e, n, s, i, r = {}) {
  const o = t2.Ba(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Eu("Data must be an object, but it was:", o, s);
  const a = pu(s, o);
  let c, u;
  if (r.merge)
    c = new dt(o.fieldMask), u = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = Iu(e, s2, n);
      if (!o.contains(i2))
        throw new j(K2.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Pu(t3, i2) || t3.push(i2);
    }
    c = new dt(t3), u = o.fieldTransforms.filter((t4) => c.covers(t4.field));
  } else
    c = null, u = o.fieldTransforms;
  return new nu(new Ut(a), c, u);
}
var uu = class extends Zc2 {
  _toFieldTransform(t2) {
    if (t2.Da !== 2)
      throw t2.Da === 1 ? t2.Fa(`${this._methodName}() can only appear at the top level of your update data`) : t2.Fa(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof uu;
  }
};
function hu(t2, e, n) {
  return new ru({
    Da: 3,
    La: e.settings.La,
    methodName: t2._methodName,
    xa: n
  }, e.databaseId, e.N, e.ignoreUndefinedProperties);
}
var lu = class extends Zc2 {
  _toFieldTransform(t2) {
    return new je(t2.path, new Oe());
  }
  isEqual(t2) {
    return t2 instanceof lu;
  }
};
var fu = class extends Zc2 {
  constructor(t2, e) {
    super(t2), this.Ua = e;
  }
  _toFieldTransform(t2) {
    const e = hu(this, t2, true), n = this.Ua.map((t3) => yu(t3, e)), s = new Fe(n);
    return new je(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var du = class extends Zc2 {
  constructor(t2, e) {
    super(t2), this.Ua = e;
  }
  _toFieldTransform(t2) {
    const e = hu(this, t2, true), n = this.Ua.map((t3) => yu(t3, e)), s = new Le(n);
    return new je(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var wu = class extends Zc2 {
  constructor(t2, e) {
    super(t2), this.qa = e;
  }
  _toFieldTransform(t2) {
    const e = new Ue(t2.N, Ce(t2.N, this.qa));
    return new je(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function _u(t2, e, n, s) {
  const i = t2.Ba(1, e, n);
  Eu("Data must be an object, but it was:", i, s);
  const r = [], o = Ut.empty();
  at(s, (t3, s2) => {
    const a2 = Ru(e, t3, n);
    s2 = getModularInstance(s2);
    const c = i.$a(a2);
    if (s2 instanceof uu)
      r.push(a2);
    else {
      const t4 = yu(s2, c);
      t4 != null && (r.push(a2), o.set(a2, t4));
    }
  });
  const a = new dt(r);
  return new su(o, a, i.fieldTransforms);
}
function mu(t2, e, n, s, i, r) {
  const o = t2.Ba(1, e, n), a = [Iu(e, s, n)], c = [i];
  if (r.length % 2 != 0)
    throw new j(K2.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    a.push(Iu(e, r[t3])), c.push(r[t3 + 1]);
  const u = [], h = Ut.empty();
  for (let t3 = a.length - 1; t3 >= 0; --t3)
    if (!Pu(u, a[t3])) {
      const e2 = a[t3];
      let n2 = c[t3];
      n2 = getModularInstance(n2);
      const s2 = o.$a(e2);
      if (n2 instanceof uu)
        u.push(e2);
      else {
        const t4 = yu(n2, s2);
        t4 != null && (u.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new dt(u);
  return new su(h, l2, o.fieldTransforms);
}
function gu(t2, e, n, s = false) {
  return yu(n, t2.Ba(s ? 4 : 3, e));
}
function yu(t2, e) {
  if (Tu(t2 = getModularInstance(t2)))
    return Eu("Unsupported field value:", e, t2), pu(t2, e);
  if (t2 instanceof Zc2)
    return function(t3, e2) {
      if (!iu(e2.Da))
        throw e2.Fa(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.Fa(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.xa && e.Da !== 4)
      throw e.Fa("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = yu(i, e2.Oa(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return Ce(e2.N, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = it.fromDate(t3);
      return {
        timestampValue: Un(e2.N, n)
      };
    }
    if (t3 instanceof it) {
      const n = new it(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Un(e2.N, n)
      };
    }
    if (t3 instanceof tu)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Xc2)
      return {
        bytesValue: qn(e2.N, t3._byteString)
      };
    if (t3 instanceof Ic2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.Fa(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: Qn(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.Fa(`Unsupported field value: ${mc2(t3)}`);
  }(t2, e);
}
function pu(t2, e) {
  const n = {};
  return ct(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : at(t2, (t3, s) => {
    const i = yu(s, e.Na(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function Tu(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof it || t2 instanceof tu || t2 instanceof Xc2 || t2 instanceof Ic2 || t2 instanceof Zc2);
}
function Eu(t2, e, n) {
  if (!Tu(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = mc2(n);
    throw s === "an object" ? e.Fa(t2 + " a custom object") : e.Fa(t2 + " " + s);
  }
}
function Iu(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Jc2)
    return e._internalPath;
  if (typeof e == "string")
    return Ru(t2, e);
  throw bu("Field path arguments must be of type string or FieldPath.", t2, false, void 0, n);
}
var Au = new RegExp("[~\\*/\\[\\]]");
function Ru(t2, e, n) {
  if (e.search(Au) >= 0)
    throw bu(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Jc2(...e.split("."))._internalPath;
  } catch (s) {
    throw bu(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function bu(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let a = `Function ${e}() called with invalid data`;
  n && (a += " (via `toFirestore()`)"), a += ". ";
  let c = "";
  return (r || o) && (c += " (found", r && (c += ` in field ${s}`), o && (c += ` in document ${i}`), c += ")"), new j(K2.INVALID_ARGUMENT, a + t2 + c);
}
function Pu(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var vu = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new Ic2(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new Vu(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(Su("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var Vu = class extends vu {
  data() {
    return super.data();
  }
};
function Su(t2, e) {
  return typeof e == "string" ? Ru(t2, e) : e instanceof Jc2 ? e._internalPath : e._delegate._internalPath;
}
var Du = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var Cu = class extends vu {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Nu(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(Su("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var Nu = class extends Cu {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var xu = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Du(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new Nu(this._firestore, this._userDataWriter, n.key, n, new Du(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new j(K2.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new Nu(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Du(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new Nu(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Du(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: ku(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function ku(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L2();
  }
}
function $u(t2, e) {
  return t2 instanceof Cu && e instanceof Cu ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof xu && e instanceof xu && (t2._firestore === e._firestore && Sc2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Ou(t2) {
  if (me(t2) && t2.explicitOrderBy.length === 0)
    throw new j(K2.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Fu = class {
};
function Mu(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var Lu = class extends Fu {
  constructor(t2, e, n) {
    super(), this.Ka = t2, this.ja = e, this.Qa = n, this.type = "where";
  }
  _apply(t2) {
    const e = au(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let a;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new j(K2.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on FieldPath.documentId().`);
        if (r === "in" || r === "not-in") {
          th(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Zu(s, t3, n3));
          a = {
            arrayValue: {
              values: e3
            }
          };
        } else
          a = Zu(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || th(o, r), a = gu(n2, e2, o, r === "in" || r === "not-in");
      const c = Jt.create(i, r, a);
      return function(t4, e3) {
        if (e3.v()) {
          const n4 = ye(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = ge(t4);
          s2 !== null && eh(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new j(K2.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new j(K2.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, c), c;
    }(t2._query, "where", e, t2.firestore._databaseId, this.Ka, this.ja, this.Qa);
    return new Ac2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new fe(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Bu(t2, e, n) {
  const s = e, i = Su("where", t2);
  return new Lu(i, s, n);
}
var Uu = class extends Fu {
  constructor(t2, e) {
    super(), this.Ka = t2, this.Wa = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new j(K2.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new j(K2.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new ce(e2, n);
      return function(t4, e3) {
        if (ge(t4) === null) {
          const n2 = ye(t4);
          n2 !== null && eh(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.Ka, this.Wa);
    return new Ac2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new fe(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function qu(t2, e = "asc") {
  const n = e, s = Su("orderBy", t2);
  return new Uu(s, n);
}
var Ku = class extends Fu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ga = e, this.za = n;
  }
  _apply(t2) {
    return new Ac2(t2.firestore, t2.converter, Ie(t2._query, this.Ga, this.za));
  }
};
function ju(t2) {
  return yc2("limit", t2), new Ku("limit", t2, "F");
}
function Qu(t2) {
  return yc2("limitToLast", t2), new Ku("limitToLast", t2, "L");
}
var Wu = class extends Fu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ha = e, this.Ja = n;
  }
  _apply(t2) {
    const e = Xu(t2, this.type, this.Ha, this.Ja);
    return new Ac2(t2.firestore, t2.converter, function(t3, e2) {
      return new fe(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Gu(...t2) {
  return new Wu("startAt", t2, true);
}
function zu(...t2) {
  return new Wu("startAfter", t2, false);
}
var Hu = class extends Fu {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ha = e, this.Ja = n;
  }
  _apply(t2) {
    const e = Xu(t2, this.type, this.Ha, this.Ja);
    return new Ac2(t2.firestore, t2.converter, function(t3, e2) {
      return new fe(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Ju(...t2) {
  return new Hu("endBefore", t2, true);
}
function Yu(...t2) {
  return new Hu("endAt", t2, false);
}
function Xu(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof vu)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new j(K2.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of Te(t3))
        if (n3.field.isKeyField())
          r.push(kt(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (Tt(t4))
            throw new j(K2.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new oe(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = au(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new j(K2.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const a = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const c = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof c != "string")
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof c}`);
          if (!pe(t3) && c.indexOf("/") !== -1)
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to ${s2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t3.path.child(ht.fromString(c));
          if (!Pt.isDocumentKey(n3))
            throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new Pt(n3);
          a.push(kt(e2, i3));
        } else {
          const t4 = gu(n2, s2, c);
          a.push(t4);
        }
      }
      return new oe(a, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Zu(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new j(K2.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!pe(e) && n.indexOf("/") !== -1)
      throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(ht.fromString(n));
    if (!Pt.isDocumentKey(s))
      throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return kt(t2, new Pt(s));
  }
  if (n instanceof Ic2)
    return kt(t2, n._key);
  throw new j(K2.INVALID_ARGUMENT, `Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: ${mc2(n)}.`);
}
function th(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new j(K2.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new j(K2.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function eh(t2, e, n) {
  if (!n.isEqual(e))
    throw new j(K2.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var nh = class {
  convertValue(t2, e = "none") {
    switch (vt(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return yt(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(pt(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw L2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return at(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new tu(yt(t2.latitude), yt(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = Et(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(It(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = gt(t2);
    return new it(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = ht.fromString(t2);
    B2(Ts(n));
    const s = new hc2(n.get(1), n.get(3)), i = new Pt(n.popFirst(5));
    return s.isEqual(e) || O2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function sh(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var ih = class extends nh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Xc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Ic2(this.firestore, null, e);
  }
};
var rh = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = au(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = oh(t2, this._firestore), i = sh(s.converter, e, n), r = cu(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, Ge.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = oh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Jc2 ? mu(this._dataReader, "WriteBatch.update", i._key, e, n, s) : _u(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, Ge.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = oh(t2, this._firestore);
    return this._mutations = this._mutations.concat(new an(e._key, Ge.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new j(K2.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function oh(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new j(K2.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function ah(t2) {
  t2 = gc2(t2, Ic2);
  const e = gc2(t2.firestore, kc2);
  return nc2(Fc2(e), t2._key).then((n) => Eh(e, t2, n));
}
var ch = class extends nh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Xc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Ic2(this.firestore, null, e);
  }
};
function uh(t2) {
  t2 = gc2(t2, Ic2);
  const e = gc2(t2.firestore, kc2), n = Fc2(e), s = new ch(e);
  return ec2(n, t2._key).then((n2) => new Cu(e, s, t2._key, n2, new Du(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function hh(t2) {
  t2 = gc2(t2, Ic2);
  const e = gc2(t2.firestore, kc2);
  return nc2(Fc2(e), t2._key, {
    source: "server"
  }).then((n) => Eh(e, t2, n));
}
function lh(t2) {
  t2 = gc2(t2, Ac2);
  const e = gc2(t2.firestore, kc2), n = Fc2(e), s = new ch(e);
  return Ou(t2._query), ic2(n, t2._query).then((n2) => new xu(e, s, t2, n2));
}
function fh(t2) {
  t2 = gc2(t2, Ac2);
  const e = gc2(t2.firestore, kc2), n = Fc2(e), s = new ch(e);
  return sc2(n, t2._query).then((n2) => new xu(e, s, t2, n2));
}
function dh(t2) {
  t2 = gc2(t2, Ac2);
  const e = gc2(t2.firestore, kc2), n = Fc2(e), s = new ch(e);
  return ic2(n, t2._query, {
    source: "server"
  }).then((n2) => new xu(e, s, t2, n2));
}
function wh(t2, e, n) {
  t2 = gc2(t2, Ic2);
  const s = gc2(t2.firestore, kc2), i = sh(t2.converter, e, n);
  return Th(s, [cu(au(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, Ge.none())]);
}
function _h(t2, e, n, ...s) {
  t2 = gc2(t2, Ic2);
  const i = gc2(t2.firestore, kc2), r = au(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Jc2 ? mu(r, "updateDoc", t2._key, e, n, s) : _u(r, "updateDoc", t2._key, e);
  return Th(i, [o.toMutation(t2._key, Ge.exists(true))]);
}
function mh(t2) {
  return Th(gc2(t2.firestore, kc2), [new an(t2._key, Ge.none())]);
}
function gh(t2, e) {
  const n = gc2(t2.firestore, kc2), s = vc2(t2), i = sh(t2.converter, e);
  return Th(n, [cu(au(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, Ge.exists(false))]).then(() => s);
}
function yh(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || Cc2(e[o]) || (r = e[o], o++);
  const a = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (Cc2(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let c, u, h;
  if (t2 instanceof Ic2)
    u = gc2(t2.firestore, kc2), h = we(t2._key.path), c = {
      next: (n2) => {
        e[o] && e[o](Eh(u, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = gc2(t2, Ac2);
    u = gc2(n2.firestore, kc2), h = n2._query;
    const s2 = new ch(u);
    c = {
      next: (t3) => {
        e[o] && e[o](new xu(u, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Ou(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new La2(s2), r2 = new Qo(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Bo(await Xa2(t3), r2)), () => {
      i2.Xo(), t3.asyncQueue.enqueueAndForget(async () => Uo(await Xa2(t3), r2));
    };
  }(Fc2(u), h, a, c);
}
function ph(t2, e) {
  return rc2(Fc2(t2 = gc2(t2, kc2)), Cc2(e) ? e : {
    next: e
  });
}
function Th(t2, e) {
  return function(t3, e2) {
    const n = new Q2();
    return t3.asyncQueue.enqueueAndForget(async () => ra2(await Ya2(t3), e2, n)), n.promise;
  }(Fc2(t2), e);
}
function Eh(t2, e, n) {
  const s = n.docs.get(e._key), i = new ch(t2);
  return new Cu(t2, i, e._key, s, new Du(n.hasPendingWrites, n.fromCache), e.converter);
}
var Ih = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = au(t2);
  }
  get(t2) {
    const e = oh(t2, this._firestore), n = new ih(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return L2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new vu(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new vu(this._firestore, n, e._key, null, e.converter);
      throw L2();
    });
  }
  set(t2, e, n) {
    const s = oh(t2, this._firestore), i = sh(s.converter, e, n), r = cu(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = oh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Jc2 ? mu(this._dataReader, "Transaction.update", i._key, e, n, s) : _u(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = oh(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = oh(t2, this._firestore), n = new ch(this._firestore);
    return super.get(t2).then((t3) => new Cu(this._firestore, n, e._key, t3._document, new Du(false, false), e.converter));
  }
};
function Ah(t2, e) {
  return oc2(Fc2(t2), (n) => e(new Ih(t2, n)));
}
function Rh() {
  return new uu("deleteField");
}
function bh() {
  return new lu("serverTimestamp");
}
function Ph(...t2) {
  return new fu("arrayUnion", t2);
}
function vh(...t2) {
  return new du("arrayRemove", t2);
}
function Vh(t2) {
  return new wu("increment", t2);
}
function Sh(t2) {
  return Fc2(t2 = gc2(t2, kc2)), new rh(t2, (e) => Th(t2, e));
}
var Dh;
!function(t2) {
  C2 = t2;
}(SDK_VERSION), _registerComponent(new Component("firestore", (t2, { options: e }) => {
  const n = t2.getProvider("app").getImmediate(), s = new kc2(n, new H2(t2.getProvider("auth-internal")));
  return e = Object.assign({
    useFetchStreams: true
  }, e), s._setSettings(e), s;
}, "PUBLIC")), registerVersion(S2, "3.1.1", Dh), registerVersion(S2, "3.1.1", "esm2017");
export {
  nh as AbstractUserDataWriter,
  Xc2 as Bytes,
  xc2 as CACHE_SIZE_UNLIMITED,
  Rc2 as CollectionReference,
  Ic2 as DocumentReference,
  Cu as DocumentSnapshot,
  Jc2 as FieldPath,
  Zc2 as FieldValue,
  kc2 as Firestore,
  j as FirestoreError,
  tu as GeoPoint,
  Nc2 as LoadBundleTask,
  Ac2 as Query,
  Fu as QueryConstraint,
  Nu as QueryDocumentSnapshot,
  xu as QuerySnapshot,
  Du as SnapshotMetadata,
  it as Timestamp,
  Ih as Transaction,
  rh as WriteBatch,
  hc2 as _DatabaseId,
  Pt as _DocumentKey,
  G as _EmptyCredentialsProvider,
  ft as _FieldPath,
  gc2 as _cast,
  U2 as _debugAssert,
  wt as _isBase64Available,
  F2 as _logWarn,
  dc2 as _validateIsNotUsedTogether,
  gh as addDoc,
  vh as arrayRemove,
  Ph as arrayUnion,
  qc2 as clearIndexedDbPersistence,
  bc2 as collection,
  Pc2 as collectionGroup,
  Ec2 as connectFirestoreEmulator,
  mh as deleteDoc,
  Rh as deleteField,
  Qc2 as disableNetwork,
  vc2 as doc,
  Yc2 as documentId,
  Lc2 as enableIndexedDbPersistence,
  Bc2 as enableMultiTabIndexedDbPersistence,
  jc2 as enableNetwork,
  Yu as endAt,
  Ju as endBefore,
  Fc2 as ensureFirestoreConfigured,
  Th as executeWrite,
  ah as getDoc,
  uh as getDocFromCache,
  hh as getDocFromServer,
  lh as getDocs,
  fh as getDocsFromCache,
  dh as getDocsFromServer,
  Oc2 as getFirestore,
  Vh as increment,
  $c2 as initializeFirestore,
  ju as limit,
  Qu as limitToLast,
  Gc2 as loadBundle,
  zc2 as namedQuery,
  yh as onSnapshot,
  ph as onSnapshotsInSync,
  qu as orderBy,
  Mu as query,
  Sc2 as queryEqual,
  Vc2 as refEqual,
  Ah as runTransaction,
  bh as serverTimestamp,
  wh as setDoc,
  k2 as setLogLevel,
  $u as snapshotEqual,
  zu as startAfter,
  Gu as startAt,
  Wc2 as terminate,
  _h as updateDoc,
  Kc2 as waitForPendingWrites,
  Bu as where,
  Sh as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_firestore.js.map
