"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.applyStateToMarker = applyStateToMarker;
exports.updateAllClasses = updateAllClasses;
exports.updateLastClasses = updateLastClasses;
exports.transformAllSelectors = transformAllSelectors;
exports.transformAllClasses = transformAllClasses;
exports.transformLastClasses = transformLastClasses;
exports.asValue = asValue;
exports.asColor = asColor;
exports.asLookupValue = asLookupValue;
exports.coerceValue = coerceValue;
var _postcssSelectorParser = _interopRequireDefault(require("postcss-selector-parser"));
var _escapeCommas = _interopRequireDefault(require("./escapeCommas"));
var _withAlphaVariable = require("./withAlphaVariable");
var _isKeyframeRule = _interopRequireDefault(require("./isKeyframeRule"));
var _dataTypes = require("./dataTypes");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function applyStateToMarker(selector, marker, state, join) {
    let markerIdx = selector.search(new RegExp(`${marker}[:[]`));
    if (markerIdx === -1) {
        return join(marker + state, selector);
    }
    let markerSelector = selector.slice(markerIdx, selector.indexOf(' ', markerIdx));
    return join(marker + state + markerSelector.slice(markerIdx + marker.length), selector.replace(markerSelector, ''));
}
function updateAllClasses(selectors, updateClass) {
    let parser = (0, _postcssSelectorParser).default((selectors)=>{
        selectors.walkClasses((sel)=>{
            let updatedClass = updateClass(sel.value, {
                withAttr (className, attr) {
                    sel.parent.insertAfter(sel, _postcssSelectorParser.default.attribute({
                        attribute: attr.slice(1, -1)
                    }));
                    return className;
                },
                withPseudo (className, pseudo) {
                    sel.parent.insertAfter(sel, _postcssSelectorParser.default.pseudo({
                        value: pseudo
                    }));
                    return className;
                }
            });
            sel.value = updatedClass;
            if (sel.raws && sel.raws.value) {
                sel.raws.value = (0, _escapeCommas).default(sel.raws.value);
            }
        });
    });
    let result = parser.processSync(selectors);
    return result;
}
function updateLastClasses(selectors, updateClass) {
    let parser = (0, _postcssSelectorParser).default((selectors)=>{
        selectors.each((sel)=>{
            let lastClass = sel.filter(({ type  })=>type === 'class'
            ).pop();
            if (lastClass === undefined) {
                return;
            }
            let updatedClass = updateClass(lastClass.value, {
                withPseudo (className, pseudo) {
                    lastClass.parent.insertAfter(lastClass, _postcssSelectorParser.default.pseudo({
                        value: `${pseudo}`
                    }));
                    return className;
                }
            });
            lastClass.value = updatedClass;
            if (lastClass.raws && lastClass.raws.value) {
                lastClass.raws.value = (0, _escapeCommas).default(lastClass.raws.value);
            }
        });
    });
    let result = parser.processSync(selectors);
    return result;
}
function splitByNotEscapedCommas(str) {
    let chunks = [];
    let currentChunk = '';
    for(let i = 0; i < str.length; i++){
        if (str[i] === ',' && str[i - 1] !== '\\') {
            chunks.push(currentChunk);
            currentChunk = '';
        } else {
            currentChunk += str[i];
        }
    }
    chunks.push(currentChunk);
    return chunks;
}
function transformAllSelectors(transformSelector, { wrap , withRule  } = {
}) {
    return ({ container  })=>{
        container.walkRules((rule)=>{
            if ((0, _isKeyframeRule).default(rule)) {
                return rule;
            }
            let transformed = splitByNotEscapedCommas(rule.selector).map(transformSelector).join(',');
            rule.selector = transformed;
            if (withRule) {
                withRule(rule);
            }
            return rule;
        });
        if (wrap) {
            let wrapper = wrap();
            let nodes = container.nodes;
            container.removeAll();
            wrapper.append(nodes);
            container.append(wrapper);
        }
    };
}
function transformAllClasses(transformClass, { wrap , withRule  } = {
}) {
    return ({ container  })=>{
        container.walkRules((rule)=>{
            let selector = rule.selector;
            let variantSelector = updateAllClasses(selector, transformClass);
            rule.selector = variantSelector;
            if (withRule) {
                withRule(rule);
            }
            return rule;
        });
        if (wrap) {
            let wrapper = wrap();
            let nodes = container.nodes;
            container.removeAll();
            wrapper.append(nodes);
            container.append(wrapper);
        }
    };
}
function transformLastClasses(transformClass, { wrap , withRule  } = {
}) {
    return ({ container  })=>{
        container.walkRules((rule)=>{
            let selector = rule.selector;
            let variantSelector = updateLastClasses(selector, transformClass);
            rule.selector = variantSelector;
            if (withRule) {
                withRule(rule);
            }
            return rule;
        });
        if (wrap) {
            let wrapper = wrap();
            let nodes = container.nodes;
            container.removeAll();
            wrapper.append(nodes);
            container.append(wrapper);
        }
    };
}
function asValue(modifier, lookup = {
}, { validate =()=>true
  } = {
}) {
    let value = lookup[modifier];
    if (value !== undefined) {
        return value;
    }
    if (!isArbitraryValue(modifier)) {
        return undefined;
    }
    value = modifier.slice(1, -1);
    if (!validate(value)) {
        return undefined;
    }
    return (0, _dataTypes).normalize(value);
}
function isArbitraryValue(input) {
    return input.startsWith('[') && input.endsWith(']');
}
function splitAlpha(modifier) {
    let slashIdx = modifier.lastIndexOf('/');
    if (slashIdx === -1 || slashIdx === modifier.length - 1) {
        return [
            modifier
        ];
    }
    return [
        modifier.slice(0, slashIdx),
        modifier.slice(slashIdx + 1)
    ];
}
function asColor(modifier, lookup = {
}, tailwindConfig = {
}) {
    if (lookup[modifier] !== undefined) {
        return lookup[modifier];
    }
    let [color, alpha] = splitAlpha(modifier);
    if (alpha !== undefined) {
        var ref, ref1;
        var _color;
        let normalizedColor = (_color = lookup[color]) !== null && _color !== void 0 ? _color : isArbitraryValue(color) ? color.slice(1, -1) : undefined;
        if (normalizedColor === undefined) {
            return undefined;
        }
        if (isArbitraryValue(alpha)) {
            return (0, _withAlphaVariable).withAlphaValue(normalizedColor, alpha.slice(1, -1));
        }
        if (((ref = tailwindConfig.theme) === null || ref === void 0 ? void 0 : (ref1 = ref.opacity) === null || ref1 === void 0 ? void 0 : ref1[alpha]) === undefined) {
            return undefined;
        }
        return (0, _withAlphaVariable).withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha]);
    }
    return asValue(modifier, lookup, {
        validate: _dataTypes.color
    });
}
function asLookupValue(modifier, lookup = {
}) {
    return lookup[modifier];
}
function guess(validate) {
    return (modifier, lookup)=>{
        return asValue(modifier, lookup, {
            validate
        });
    };
}
let typeMap = {
    any: asValue,
    color: asColor,
    url: guess(_dataTypes.url),
    image: guess(_dataTypes.image),
    length: guess(_dataTypes.length),
    percentage: guess(_dataTypes.percentage),
    position: guess(_dataTypes.position),
    lookup: asLookupValue,
    'generic-name': guess(_dataTypes.genericName),
    'family-name': guess(_dataTypes.familyName),
    number: guess(_dataTypes.number),
    'line-width': guess(_dataTypes.lineWidth),
    'absolute-size': guess(_dataTypes.absoluteSize),
    'relative-size': guess(_dataTypes.relativeSize)
};
let supportedTypes = Object.keys(typeMap);
function splitAtFirst(input, delim) {
    let idx = input.indexOf(delim);
    if (idx === -1) return [
        undefined,
        input
    ];
    return [
        input.slice(0, idx),
        input.slice(idx + 1)
    ];
}
function coerceValue(types, modifier, values, tailwindConfig) {
    if (isArbitraryValue(modifier)) {
        let [explicitType, value] = splitAtFirst(modifier.slice(1, -1), ':');
        if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {
            return [];
        }
        if (value.length > 0 && supportedTypes.includes(explicitType)) {
            return [
                asValue(`[${value}]`, values, tailwindConfig),
                explicitType
            ];
        }
    }
    // Find first matching type
    for (let type of [].concat(types)){
        let result = typeMap[type](modifier, values, tailwindConfig);
        if (result) return [
            result,
            type
        ];
    }
    return [];
}
